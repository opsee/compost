// Code generated by protoc-gen-gogo.
// source: types.proto
// DO NOT EDIT!

/*
	Package ecs is a generated protocol buffer package.

	It is generated from these files:
		types.proto

	It has these top-level messages:
		Attribute
		Container
		ContainerDefinition
		ContainerInstance
		ContainerOverride
		Deployment
		DeploymentConfiguration
		DescribeContainerInstancesInput
		DescribeContainerInstancesOutput
		DescribeServicesInput
		DescribeServicesOutput
		DescribeTaskDefinitionInput
		DescribeTaskDefinitionOutput
		DescribeTasksInput
		DescribeTasksOutput
		Failure
		HostEntry
		HostVolumeProperties
		KeyValuePair
		ListClustersInput
		ListClustersOutput
		ListContainerInstancesInput
		ListContainerInstancesOutput
		ListServicesInput
		ListServicesOutput
		ListTasksInput
		ListTasksOutput
		LoadBalancer
		LogConfiguration
		MountPoint
		NetworkBinding
		PortMapping
		Resource
		Service
		ServiceEvent
		Task
		TaskDefinition
		TaskOverride
		Ulimit
		VersionInfo
		Volume
		VolumeFrom
*/
package ecs

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/opsee/protobuf/opseeproto"
import opsee_types "github.com/opsee/protobuf/opseeproto/types"

import bytes "bytes"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"
import github_com_opsee_protobuf_plugin_graphql_scalars "github.com/opsee/protobuf/plugin/graphql/scalars"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Attribute struct {
	Name             *string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Value            *string `protobuf:"bytes,3,opt,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Attribute) Reset()                    { *m = Attribute{} }
func (m *Attribute) String() string            { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()               {}
func (*Attribute) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Attribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Attribute) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Container struct {
	ContainerArn     *string           `protobuf:"bytes,2,opt,name=ContainerArn,json=containerArn" json:"ContainerArn,omitempty"`
	ExitCode         *int64            `protobuf:"zigzag64,3,opt,name=ExitCode,json=exitCode" json:"ExitCode,omitempty"`
	LastStatus       *string           `protobuf:"bytes,4,opt,name=LastStatus,json=lastStatus" json:"LastStatus,omitempty"`
	Name             *string           `protobuf:"bytes,5,opt,name=Name,json=name" json:"Name,omitempty"`
	NetworkBindings  []*NetworkBinding `protobuf:"bytes,6,rep,name=NetworkBindings,json=networkBindings" json:"NetworkBindings,omitempty"`
	Reason           *string           `protobuf:"bytes,7,opt,name=Reason,json=reason" json:"Reason,omitempty"`
	TaskArn          *string           `protobuf:"bytes,8,opt,name=TaskArn,json=taskArn" json:"TaskArn,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *Container) GetContainerArn() string {
	if m != nil && m.ContainerArn != nil {
		return *m.ContainerArn
	}
	return ""
}

func (m *Container) GetExitCode() int64 {
	if m != nil && m.ExitCode != nil {
		return *m.ExitCode
	}
	return 0
}

func (m *Container) GetLastStatus() string {
	if m != nil && m.LastStatus != nil {
		return *m.LastStatus
	}
	return ""
}

func (m *Container) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Container) GetNetworkBindings() []*NetworkBinding {
	if m != nil {
		return m.NetworkBindings
	}
	return nil
}

func (m *Container) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

func (m *Container) GetTaskArn() string {
	if m != nil && m.TaskArn != nil {
		return *m.TaskArn
	}
	return ""
}

type ContainerDefinition struct {
	Command                []string          `protobuf:"bytes,2,rep,name=Command,json=command" json:"Command,omitempty"`
	Cpu                    *int64            `protobuf:"zigzag64,3,opt,name=Cpu,json=cpu" json:"Cpu,omitempty"`
	DisableNetworking      *bool             `protobuf:"varint,4,opt,name=DisableNetworking,json=disableNetworking" json:"DisableNetworking,omitempty"`
	DnsSearchDomains       []string          `protobuf:"bytes,5,rep,name=DnsSearchDomains,json=dnsSearchDomains" json:"DnsSearchDomains,omitempty"`
	DnsServers             []string          `protobuf:"bytes,6,rep,name=DnsServers,json=dnsServers" json:"DnsServers,omitempty"`
	DockerLabels           map[string]string `protobuf:"bytes,7,rep,name=DockerLabels,json=dockerLabels" json:"DockerLabels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	DockerSecurityOptions  []string          `protobuf:"bytes,8,rep,name=DockerSecurityOptions,json=dockerSecurityOptions" json:"DockerSecurityOptions,omitempty"`
	EntryPoint             []string          `protobuf:"bytes,9,rep,name=EntryPoint,json=entryPoint" json:"EntryPoint,omitempty"`
	Environment            []*KeyValuePair   `protobuf:"bytes,10,rep,name=Environment,json=environment" json:"Environment,omitempty"`
	Essential              *bool             `protobuf:"varint,11,opt,name=Essential,json=essential" json:"Essential,omitempty"`
	ExtraHosts             []*HostEntry      `protobuf:"bytes,12,rep,name=ExtraHosts,json=extraHosts" json:"ExtraHosts,omitempty"`
	Hostname               *string           `protobuf:"bytes,13,opt,name=Hostname,json=hostname" json:"Hostname,omitempty"`
	Image                  *string           `protobuf:"bytes,14,opt,name=Image,json=image" json:"Image,omitempty"`
	Links                  []string          `protobuf:"bytes,15,rep,name=Links,json=links" json:"Links,omitempty"`
	LogConfiguration       *LogConfiguration `protobuf:"bytes,16,opt,name=LogConfiguration,json=logConfiguration" json:"LogConfiguration,omitempty"`
	Memory                 *int64            `protobuf:"zigzag64,17,opt,name=Memory,json=memory" json:"Memory,omitempty"`
	MountPoints            []*MountPoint     `protobuf:"bytes,18,rep,name=MountPoints,json=mountPoints" json:"MountPoints,omitempty"`
	Name                   *string           `protobuf:"bytes,19,opt,name=Name,json=name" json:"Name,omitempty"`
	PortMappings           []*PortMapping    `protobuf:"bytes,20,rep,name=PortMappings,json=portMappings" json:"PortMappings,omitempty"`
	Privileged             *bool             `protobuf:"varint,21,opt,name=Privileged,json=privileged" json:"Privileged,omitempty"`
	ReadonlyRootFilesystem *bool             `protobuf:"varint,22,opt,name=ReadonlyRootFilesystem,json=readonlyRootFilesystem" json:"ReadonlyRootFilesystem,omitempty"`
	Ulimits                []*Ulimit         `protobuf:"bytes,23,rep,name=Ulimits,json=ulimits" json:"Ulimits,omitempty"`
	User                   *string           `protobuf:"bytes,24,opt,name=User,json=user" json:"User,omitempty"`
	VolumesFrom            []*VolumeFrom     `protobuf:"bytes,25,rep,name=VolumesFrom,json=volumesFrom" json:"VolumesFrom,omitempty"`
	WorkingDirectory       *string           `protobuf:"bytes,26,opt,name=WorkingDirectory,json=workingDirectory" json:"WorkingDirectory,omitempty"`
	XXX_unrecognized       []byte            `json:"-"`
}

func (m *ContainerDefinition) Reset()                    { *m = ContainerDefinition{} }
func (m *ContainerDefinition) String() string            { return proto.CompactTextString(m) }
func (*ContainerDefinition) ProtoMessage()               {}
func (*ContainerDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *ContainerDefinition) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerDefinition) GetCpu() int64 {
	if m != nil && m.Cpu != nil {
		return *m.Cpu
	}
	return 0
}

func (m *ContainerDefinition) GetDisableNetworking() bool {
	if m != nil && m.DisableNetworking != nil {
		return *m.DisableNetworking
	}
	return false
}

func (m *ContainerDefinition) GetDnsSearchDomains() []string {
	if m != nil {
		return m.DnsSearchDomains
	}
	return nil
}

func (m *ContainerDefinition) GetDnsServers() []string {
	if m != nil {
		return m.DnsServers
	}
	return nil
}

func (m *ContainerDefinition) GetDockerLabels() map[string]string {
	if m != nil {
		return m.DockerLabels
	}
	return nil
}

func (m *ContainerDefinition) GetDockerSecurityOptions() []string {
	if m != nil {
		return m.DockerSecurityOptions
	}
	return nil
}

func (m *ContainerDefinition) GetEntryPoint() []string {
	if m != nil {
		return m.EntryPoint
	}
	return nil
}

func (m *ContainerDefinition) GetEnvironment() []*KeyValuePair {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *ContainerDefinition) GetEssential() bool {
	if m != nil && m.Essential != nil {
		return *m.Essential
	}
	return false
}

func (m *ContainerDefinition) GetExtraHosts() []*HostEntry {
	if m != nil {
		return m.ExtraHosts
	}
	return nil
}

func (m *ContainerDefinition) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *ContainerDefinition) GetImage() string {
	if m != nil && m.Image != nil {
		return *m.Image
	}
	return ""
}

func (m *ContainerDefinition) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *ContainerDefinition) GetLogConfiguration() *LogConfiguration {
	if m != nil {
		return m.LogConfiguration
	}
	return nil
}

func (m *ContainerDefinition) GetMemory() int64 {
	if m != nil && m.Memory != nil {
		return *m.Memory
	}
	return 0
}

func (m *ContainerDefinition) GetMountPoints() []*MountPoint {
	if m != nil {
		return m.MountPoints
	}
	return nil
}

func (m *ContainerDefinition) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ContainerDefinition) GetPortMappings() []*PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *ContainerDefinition) GetPrivileged() bool {
	if m != nil && m.Privileged != nil {
		return *m.Privileged
	}
	return false
}

func (m *ContainerDefinition) GetReadonlyRootFilesystem() bool {
	if m != nil && m.ReadonlyRootFilesystem != nil {
		return *m.ReadonlyRootFilesystem
	}
	return false
}

func (m *ContainerDefinition) GetUlimits() []*Ulimit {
	if m != nil {
		return m.Ulimits
	}
	return nil
}

func (m *ContainerDefinition) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *ContainerDefinition) GetVolumesFrom() []*VolumeFrom {
	if m != nil {
		return m.VolumesFrom
	}
	return nil
}

func (m *ContainerDefinition) GetWorkingDirectory() string {
	if m != nil && m.WorkingDirectory != nil {
		return *m.WorkingDirectory
	}
	return ""
}

type ContainerInstance struct {
	AgentConnected       *bool        `protobuf:"varint,2,opt,name=AgentConnected,json=agentConnected" json:"AgentConnected,omitempty"`
	AgentUpdateStatus    *string      `protobuf:"bytes,3,opt,name=AgentUpdateStatus,json=agentUpdateStatus" json:"AgentUpdateStatus,omitempty"`
	Attributes           []*Attribute `protobuf:"bytes,4,rep,name=Attributes,json=attributes" json:"Attributes,omitempty"`
	ContainerInstanceArn *string      `protobuf:"bytes,5,opt,name=ContainerInstanceArn,json=containerInstanceArn" json:"ContainerInstanceArn,omitempty"`
	Ec2InstanceId        *string      `protobuf:"bytes,6,opt,name=Ec2InstanceId,json=ec2InstanceId" json:"Ec2InstanceId,omitempty"`
	PendingTasksCount    *int64       `protobuf:"zigzag64,7,opt,name=PendingTasksCount,json=pendingTasksCount" json:"PendingTasksCount,omitempty"`
	RegisteredResources  []*Resource  `protobuf:"bytes,8,rep,name=RegisteredResources,json=registeredResources" json:"RegisteredResources,omitempty"`
	RemainingResources   []*Resource  `protobuf:"bytes,9,rep,name=RemainingResources,json=remainingResources" json:"RemainingResources,omitempty"`
	RunningTasksCount    *int64       `protobuf:"zigzag64,10,opt,name=RunningTasksCount,json=runningTasksCount" json:"RunningTasksCount,omitempty"`
	Status               *string      `protobuf:"bytes,11,opt,name=Status,json=status" json:"Status,omitempty"`
	VersionInfo          *VersionInfo `protobuf:"bytes,12,opt,name=VersionInfo,json=versionInfo" json:"VersionInfo,omitempty"`
	XXX_unrecognized     []byte       `json:"-"`
}

func (m *ContainerInstance) Reset()                    { *m = ContainerInstance{} }
func (m *ContainerInstance) String() string            { return proto.CompactTextString(m) }
func (*ContainerInstance) ProtoMessage()               {}
func (*ContainerInstance) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *ContainerInstance) GetAgentConnected() bool {
	if m != nil && m.AgentConnected != nil {
		return *m.AgentConnected
	}
	return false
}

func (m *ContainerInstance) GetAgentUpdateStatus() string {
	if m != nil && m.AgentUpdateStatus != nil {
		return *m.AgentUpdateStatus
	}
	return ""
}

func (m *ContainerInstance) GetAttributes() []*Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ContainerInstance) GetContainerInstanceArn() string {
	if m != nil && m.ContainerInstanceArn != nil {
		return *m.ContainerInstanceArn
	}
	return ""
}

func (m *ContainerInstance) GetEc2InstanceId() string {
	if m != nil && m.Ec2InstanceId != nil {
		return *m.Ec2InstanceId
	}
	return ""
}

func (m *ContainerInstance) GetPendingTasksCount() int64 {
	if m != nil && m.PendingTasksCount != nil {
		return *m.PendingTasksCount
	}
	return 0
}

func (m *ContainerInstance) GetRegisteredResources() []*Resource {
	if m != nil {
		return m.RegisteredResources
	}
	return nil
}

func (m *ContainerInstance) GetRemainingResources() []*Resource {
	if m != nil {
		return m.RemainingResources
	}
	return nil
}

func (m *ContainerInstance) GetRunningTasksCount() int64 {
	if m != nil && m.RunningTasksCount != nil {
		return *m.RunningTasksCount
	}
	return 0
}

func (m *ContainerInstance) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *ContainerInstance) GetVersionInfo() *VersionInfo {
	if m != nil {
		return m.VersionInfo
	}
	return nil
}

type ContainerOverride struct {
	Command          []string        `protobuf:"bytes,2,rep,name=Command,json=command" json:"Command,omitempty"`
	Environment      []*KeyValuePair `protobuf:"bytes,3,rep,name=Environment,json=environment" json:"Environment,omitempty"`
	Name             *string         `protobuf:"bytes,4,opt,name=Name,json=name" json:"Name,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ContainerOverride) Reset()                    { *m = ContainerOverride{} }
func (m *ContainerOverride) String() string            { return proto.CompactTextString(m) }
func (*ContainerOverride) ProtoMessage()               {}
func (*ContainerOverride) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *ContainerOverride) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerOverride) GetEnvironment() []*KeyValuePair {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *ContainerOverride) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Deployment struct {
	CreatedAt        *opsee_types.Timestamp `protobuf:"bytes,2,opt,name=CreatedAt,json=createdAt" json:"CreatedAt,omitempty"`
	DesiredCount     *int64                 `protobuf:"zigzag64,3,opt,name=DesiredCount,json=desiredCount" json:"DesiredCount,omitempty"`
	Id               *string                `protobuf:"bytes,4,opt,name=Id,json=id" json:"Id,omitempty"`
	PendingCount     *int64                 `protobuf:"zigzag64,5,opt,name=PendingCount,json=pendingCount" json:"PendingCount,omitempty"`
	RunningCount     *int64                 `protobuf:"zigzag64,6,opt,name=RunningCount,json=runningCount" json:"RunningCount,omitempty"`
	Status           *string                `protobuf:"bytes,7,opt,name=Status,json=status" json:"Status,omitempty"`
	TaskDefinition   *string                `protobuf:"bytes,8,opt,name=TaskDefinition,json=taskDefinition" json:"TaskDefinition,omitempty"`
	UpdatedAt        *opsee_types.Timestamp `protobuf:"bytes,9,opt,name=UpdatedAt,json=updatedAt" json:"UpdatedAt,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *Deployment) Reset()                    { *m = Deployment{} }
func (m *Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()               {}
func (*Deployment) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *Deployment) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Deployment) GetDesiredCount() int64 {
	if m != nil && m.DesiredCount != nil {
		return *m.DesiredCount
	}
	return 0
}

func (m *Deployment) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Deployment) GetPendingCount() int64 {
	if m != nil && m.PendingCount != nil {
		return *m.PendingCount
	}
	return 0
}

func (m *Deployment) GetRunningCount() int64 {
	if m != nil && m.RunningCount != nil {
		return *m.RunningCount
	}
	return 0
}

func (m *Deployment) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *Deployment) GetTaskDefinition() string {
	if m != nil && m.TaskDefinition != nil {
		return *m.TaskDefinition
	}
	return ""
}

func (m *Deployment) GetUpdatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

type DeploymentConfiguration struct {
	MaximumPercent        *int64 `protobuf:"zigzag64,2,opt,name=MaximumPercent,json=maximumPercent" json:"MaximumPercent,omitempty"`
	MinimumHealthyPercent *int64 `protobuf:"zigzag64,3,opt,name=MinimumHealthyPercent,json=minimumHealthyPercent" json:"MinimumHealthyPercent,omitempty"`
	XXX_unrecognized      []byte `json:"-"`
}

func (m *DeploymentConfiguration) Reset()                    { *m = DeploymentConfiguration{} }
func (m *DeploymentConfiguration) String() string            { return proto.CompactTextString(m) }
func (*DeploymentConfiguration) ProtoMessage()               {}
func (*DeploymentConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *DeploymentConfiguration) GetMaximumPercent() int64 {
	if m != nil && m.MaximumPercent != nil {
		return *m.MaximumPercent
	}
	return 0
}

func (m *DeploymentConfiguration) GetMinimumHealthyPercent() int64 {
	if m != nil && m.MinimumHealthyPercent != nil {
		return *m.MinimumHealthyPercent
	}
	return 0
}

type DescribeContainerInstancesInput struct {
	Cluster            *string  `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	ContainerInstances []string `protobuf:"bytes,3,rep,name=ContainerInstances,json=containerInstances" json:"ContainerInstances,omitempty"`
	XXX_unrecognized   []byte   `json:"-"`
}

func (m *DescribeContainerInstancesInput) Reset()         { *m = DescribeContainerInstancesInput{} }
func (m *DescribeContainerInstancesInput) String() string { return proto.CompactTextString(m) }
func (*DescribeContainerInstancesInput) ProtoMessage()    {}
func (*DescribeContainerInstancesInput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{7}
}

func (m *DescribeContainerInstancesInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *DescribeContainerInstancesInput) GetContainerInstances() []string {
	if m != nil {
		return m.ContainerInstances
	}
	return nil
}

type DescribeContainerInstancesOutput struct {
	ContainerInstances []*ContainerInstance `protobuf:"bytes,2,rep,name=ContainerInstances,json=containerInstances" json:"ContainerInstances,omitempty"`
	Failures           []*Failure           `protobuf:"bytes,3,rep,name=Failures,json=failures" json:"Failures,omitempty"`
	XXX_unrecognized   []byte               `json:"-"`
}

func (m *DescribeContainerInstancesOutput) Reset()         { *m = DescribeContainerInstancesOutput{} }
func (m *DescribeContainerInstancesOutput) String() string { return proto.CompactTextString(m) }
func (*DescribeContainerInstancesOutput) ProtoMessage()    {}
func (*DescribeContainerInstancesOutput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{8}
}

func (m *DescribeContainerInstancesOutput) GetContainerInstances() []*ContainerInstance {
	if m != nil {
		return m.ContainerInstances
	}
	return nil
}

func (m *DescribeContainerInstancesOutput) GetFailures() []*Failure {
	if m != nil {
		return m.Failures
	}
	return nil
}

type DescribeServicesInput struct {
	Cluster          *string  `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	Services         []string `protobuf:"bytes,3,rep,name=Services,json=services" json:"Services,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DescribeServicesInput) Reset()                    { *m = DescribeServicesInput{} }
func (m *DescribeServicesInput) String() string            { return proto.CompactTextString(m) }
func (*DescribeServicesInput) ProtoMessage()               {}
func (*DescribeServicesInput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *DescribeServicesInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *DescribeServicesInput) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

type DescribeServicesOutput struct {
	Failures         []*Failure `protobuf:"bytes,2,rep,name=Failures,json=failures" json:"Failures,omitempty"`
	Services         []*Service `protobuf:"bytes,3,rep,name=Services,json=services" json:"Services,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *DescribeServicesOutput) Reset()                    { *m = DescribeServicesOutput{} }
func (m *DescribeServicesOutput) String() string            { return proto.CompactTextString(m) }
func (*DescribeServicesOutput) ProtoMessage()               {}
func (*DescribeServicesOutput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *DescribeServicesOutput) GetFailures() []*Failure {
	if m != nil {
		return m.Failures
	}
	return nil
}

func (m *DescribeServicesOutput) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type DescribeTaskDefinitionInput struct {
	TaskDefinition   *string `protobuf:"bytes,2,opt,name=TaskDefinition,json=taskDefinition" json:"TaskDefinition,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DescribeTaskDefinitionInput) Reset()         { *m = DescribeTaskDefinitionInput{} }
func (m *DescribeTaskDefinitionInput) String() string { return proto.CompactTextString(m) }
func (*DescribeTaskDefinitionInput) ProtoMessage()    {}
func (*DescribeTaskDefinitionInput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{11}
}

func (m *DescribeTaskDefinitionInput) GetTaskDefinition() string {
	if m != nil && m.TaskDefinition != nil {
		return *m.TaskDefinition
	}
	return ""
}

type DescribeTaskDefinitionOutput struct {
	TaskDefinition   *TaskDefinition `protobuf:"bytes,2,opt,name=TaskDefinition,json=taskDefinition" json:"TaskDefinition,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *DescribeTaskDefinitionOutput) Reset()         { *m = DescribeTaskDefinitionOutput{} }
func (m *DescribeTaskDefinitionOutput) String() string { return proto.CompactTextString(m) }
func (*DescribeTaskDefinitionOutput) ProtoMessage()    {}
func (*DescribeTaskDefinitionOutput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{12}
}

func (m *DescribeTaskDefinitionOutput) GetTaskDefinition() *TaskDefinition {
	if m != nil {
		return m.TaskDefinition
	}
	return nil
}

type DescribeTasksInput struct {
	Cluster          *string  `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	Tasks            []string `protobuf:"bytes,3,rep,name=Tasks,json=tasks" json:"Tasks,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DescribeTasksInput) Reset()                    { *m = DescribeTasksInput{} }
func (m *DescribeTasksInput) String() string            { return proto.CompactTextString(m) }
func (*DescribeTasksInput) ProtoMessage()               {}
func (*DescribeTasksInput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *DescribeTasksInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *DescribeTasksInput) GetTasks() []string {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type DescribeTasksOutput struct {
	Failures         []*Failure `protobuf:"bytes,2,rep,name=Failures,json=failures" json:"Failures,omitempty"`
	Tasks            []*Task    `protobuf:"bytes,3,rep,name=Tasks,json=tasks" json:"Tasks,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *DescribeTasksOutput) Reset()                    { *m = DescribeTasksOutput{} }
func (m *DescribeTasksOutput) String() string            { return proto.CompactTextString(m) }
func (*DescribeTasksOutput) ProtoMessage()               {}
func (*DescribeTasksOutput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *DescribeTasksOutput) GetFailures() []*Failure {
	if m != nil {
		return m.Failures
	}
	return nil
}

func (m *DescribeTasksOutput) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type Failure struct {
	Arn              *string `protobuf:"bytes,2,opt,name=Arn,json=arn" json:"Arn,omitempty"`
	Reason           *string `protobuf:"bytes,3,opt,name=Reason,json=reason" json:"Reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Failure) Reset()                    { *m = Failure{} }
func (m *Failure) String() string            { return proto.CompactTextString(m) }
func (*Failure) ProtoMessage()               {}
func (*Failure) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *Failure) GetArn() string {
	if m != nil && m.Arn != nil {
		return *m.Arn
	}
	return ""
}

func (m *Failure) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

type HostEntry struct {
	Hostname         *string `protobuf:"bytes,2,opt,name=Hostname,json=hostname" json:"Hostname,omitempty"`
	IpAddress        *string `protobuf:"bytes,3,opt,name=IpAddress,json=ipAddress" json:"IpAddress,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HostEntry) Reset()                    { *m = HostEntry{} }
func (m *HostEntry) String() string            { return proto.CompactTextString(m) }
func (*HostEntry) ProtoMessage()               {}
func (*HostEntry) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *HostEntry) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *HostEntry) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

type HostVolumeProperties struct {
	SourcePath       *string `protobuf:"bytes,2,opt,name=SourcePath,json=sourcePath" json:"SourcePath,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *HostVolumeProperties) Reset()                    { *m = HostVolumeProperties{} }
func (m *HostVolumeProperties) String() string            { return proto.CompactTextString(m) }
func (*HostVolumeProperties) ProtoMessage()               {}
func (*HostVolumeProperties) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *HostVolumeProperties) GetSourcePath() string {
	if m != nil && m.SourcePath != nil {
		return *m.SourcePath
	}
	return ""
}

type KeyValuePair struct {
	Name             *string `protobuf:"bytes,2,opt,name=Name,json=name" json:"Name,omitempty"`
	Value            *string `protobuf:"bytes,3,opt,name=Value,json=value" json:"Value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *KeyValuePair) Reset()                    { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()               {}
func (*KeyValuePair) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *KeyValuePair) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *KeyValuePair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type ListClustersInput struct {
	MaxResults       *int64  `protobuf:"zigzag64,2,opt,name=MaxResults,json=maxResults" json:"MaxResults,omitempty"`
	NextToken        *string `protobuf:"bytes,3,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ListClustersInput) Reset()                    { *m = ListClustersInput{} }
func (m *ListClustersInput) String() string            { return proto.CompactTextString(m) }
func (*ListClustersInput) ProtoMessage()               {}
func (*ListClustersInput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *ListClustersInput) GetMaxResults() int64 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *ListClustersInput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

type ListClustersOutput struct {
	ClusterArns      []string `protobuf:"bytes,2,rep,name=ClusterArns,json=clusterArns" json:"ClusterArns,omitempty"`
	NextToken        *string  `protobuf:"bytes,3,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ListClustersOutput) Reset()                    { *m = ListClustersOutput{} }
func (m *ListClustersOutput) String() string            { return proto.CompactTextString(m) }
func (*ListClustersOutput) ProtoMessage()               {}
func (*ListClustersOutput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *ListClustersOutput) GetClusterArns() []string {
	if m != nil {
		return m.ClusterArns
	}
	return nil
}

func (m *ListClustersOutput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

type ListContainerInstancesInput struct {
	Cluster          *string `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	MaxResults       *int64  `protobuf:"zigzag64,3,opt,name=MaxResults,json=maxResults" json:"MaxResults,omitempty"`
	NextToken        *string `protobuf:"bytes,4,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ListContainerInstancesInput) Reset()         { *m = ListContainerInstancesInput{} }
func (m *ListContainerInstancesInput) String() string { return proto.CompactTextString(m) }
func (*ListContainerInstancesInput) ProtoMessage()    {}
func (*ListContainerInstancesInput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{21}
}

func (m *ListContainerInstancesInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *ListContainerInstancesInput) GetMaxResults() int64 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *ListContainerInstancesInput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

type ListContainerInstancesOutput struct {
	ContainerInstanceArns []string `protobuf:"bytes,2,rep,name=ContainerInstanceArns,json=containerInstanceArns" json:"ContainerInstanceArns,omitempty"`
	NextToken             *string  `protobuf:"bytes,3,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	XXX_unrecognized      []byte   `json:"-"`
}

func (m *ListContainerInstancesOutput) Reset()         { *m = ListContainerInstancesOutput{} }
func (m *ListContainerInstancesOutput) String() string { return proto.CompactTextString(m) }
func (*ListContainerInstancesOutput) ProtoMessage()    {}
func (*ListContainerInstancesOutput) Descriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{22}
}

func (m *ListContainerInstancesOutput) GetContainerInstanceArns() []string {
	if m != nil {
		return m.ContainerInstanceArns
	}
	return nil
}

func (m *ListContainerInstancesOutput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

type ListServicesInput struct {
	Cluster          *string `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	MaxResults       *int64  `protobuf:"zigzag64,3,opt,name=MaxResults,json=maxResults" json:"MaxResults,omitempty"`
	NextToken        *string `protobuf:"bytes,4,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ListServicesInput) Reset()                    { *m = ListServicesInput{} }
func (m *ListServicesInput) String() string            { return proto.CompactTextString(m) }
func (*ListServicesInput) ProtoMessage()               {}
func (*ListServicesInput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *ListServicesInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *ListServicesInput) GetMaxResults() int64 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *ListServicesInput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

type ListServicesOutput struct {
	NextToken        *string  `protobuf:"bytes,2,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	ServiceArns      []string `protobuf:"bytes,3,rep,name=ServiceArns,json=serviceArns" json:"ServiceArns,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ListServicesOutput) Reset()                    { *m = ListServicesOutput{} }
func (m *ListServicesOutput) String() string            { return proto.CompactTextString(m) }
func (*ListServicesOutput) ProtoMessage()               {}
func (*ListServicesOutput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{24} }

func (m *ListServicesOutput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

func (m *ListServicesOutput) GetServiceArns() []string {
	if m != nil {
		return m.ServiceArns
	}
	return nil
}

type ListTasksInput struct {
	Cluster           *string `protobuf:"bytes,2,opt,name=Cluster,json=cluster" json:"Cluster,omitempty"`
	ContainerInstance *string `protobuf:"bytes,3,opt,name=ContainerInstance,json=containerInstance" json:"ContainerInstance,omitempty"`
	DesiredStatus     *string `protobuf:"bytes,4,opt,name=DesiredStatus,json=desiredStatus" json:"DesiredStatus,omitempty"`
	Family            *string `protobuf:"bytes,5,opt,name=Family,json=family" json:"Family,omitempty"`
	MaxResults        *int64  `protobuf:"zigzag64,6,opt,name=MaxResults,json=maxResults" json:"MaxResults,omitempty"`
	NextToken         *string `protobuf:"bytes,7,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	ServiceName       *string `protobuf:"bytes,8,opt,name=ServiceName,json=serviceName" json:"ServiceName,omitempty"`
	StartedBy         *string `protobuf:"bytes,9,opt,name=StartedBy,json=startedBy" json:"StartedBy,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *ListTasksInput) Reset()                    { *m = ListTasksInput{} }
func (m *ListTasksInput) String() string            { return proto.CompactTextString(m) }
func (*ListTasksInput) ProtoMessage()               {}
func (*ListTasksInput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{25} }

func (m *ListTasksInput) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *ListTasksInput) GetContainerInstance() string {
	if m != nil && m.ContainerInstance != nil {
		return *m.ContainerInstance
	}
	return ""
}

func (m *ListTasksInput) GetDesiredStatus() string {
	if m != nil && m.DesiredStatus != nil {
		return *m.DesiredStatus
	}
	return ""
}

func (m *ListTasksInput) GetFamily() string {
	if m != nil && m.Family != nil {
		return *m.Family
	}
	return ""
}

func (m *ListTasksInput) GetMaxResults() int64 {
	if m != nil && m.MaxResults != nil {
		return *m.MaxResults
	}
	return 0
}

func (m *ListTasksInput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

func (m *ListTasksInput) GetServiceName() string {
	if m != nil && m.ServiceName != nil {
		return *m.ServiceName
	}
	return ""
}

func (m *ListTasksInput) GetStartedBy() string {
	if m != nil && m.StartedBy != nil {
		return *m.StartedBy
	}
	return ""
}

type ListTasksOutput struct {
	NextToken        *string  `protobuf:"bytes,2,opt,name=NextToken,json=nextToken" json:"NextToken,omitempty"`
	TaskArns         []string `protobuf:"bytes,3,rep,name=TaskArns,json=taskArns" json:"TaskArns,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ListTasksOutput) Reset()                    { *m = ListTasksOutput{} }
func (m *ListTasksOutput) String() string            { return proto.CompactTextString(m) }
func (*ListTasksOutput) ProtoMessage()               {}
func (*ListTasksOutput) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{26} }

func (m *ListTasksOutput) GetNextToken() string {
	if m != nil && m.NextToken != nil {
		return *m.NextToken
	}
	return ""
}

func (m *ListTasksOutput) GetTaskArns() []string {
	if m != nil {
		return m.TaskArns
	}
	return nil
}

type LoadBalancer struct {
	ContainerName    *string `protobuf:"bytes,2,opt,name=ContainerName,json=containerName" json:"ContainerName,omitempty"`
	ContainerPort    *int64  `protobuf:"zigzag64,3,opt,name=ContainerPort,json=containerPort" json:"ContainerPort,omitempty"`
	LoadBalancerName *string `protobuf:"bytes,4,opt,name=LoadBalancerName,json=loadBalancerName" json:"LoadBalancerName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoadBalancer) Reset()                    { *m = LoadBalancer{} }
func (m *LoadBalancer) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancer) ProtoMessage()               {}
func (*LoadBalancer) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{27} }

func (m *LoadBalancer) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *LoadBalancer) GetContainerPort() int64 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *LoadBalancer) GetLoadBalancerName() string {
	if m != nil && m.LoadBalancerName != nil {
		return *m.LoadBalancerName
	}
	return ""
}

type LogConfiguration struct {
	LogDriver        *string           `protobuf:"bytes,2,opt,name=LogDriver,json=logDriver" json:"LogDriver,omitempty"`
	Options          map[string]string `protobuf:"bytes,3,rep,name=Options,json=options" json:"Options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *LogConfiguration) Reset()                    { *m = LogConfiguration{} }
func (m *LogConfiguration) String() string            { return proto.CompactTextString(m) }
func (*LogConfiguration) ProtoMessage()               {}
func (*LogConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{28} }

func (m *LogConfiguration) GetLogDriver() string {
	if m != nil && m.LogDriver != nil {
		return *m.LogDriver
	}
	return ""
}

func (m *LogConfiguration) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

type MountPoint struct {
	ContainerPath    *string `protobuf:"bytes,2,opt,name=ContainerPath,json=containerPath" json:"ContainerPath,omitempty"`
	ReadOnly         *bool   `protobuf:"varint,3,opt,name=ReadOnly,json=readOnly" json:"ReadOnly,omitempty"`
	SourceVolume     *string `protobuf:"bytes,4,opt,name=SourceVolume,json=sourceVolume" json:"SourceVolume,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *MountPoint) Reset()                    { *m = MountPoint{} }
func (m *MountPoint) String() string            { return proto.CompactTextString(m) }
func (*MountPoint) ProtoMessage()               {}
func (*MountPoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{29} }

func (m *MountPoint) GetContainerPath() string {
	if m != nil && m.ContainerPath != nil {
		return *m.ContainerPath
	}
	return ""
}

func (m *MountPoint) GetReadOnly() bool {
	if m != nil && m.ReadOnly != nil {
		return *m.ReadOnly
	}
	return false
}

func (m *MountPoint) GetSourceVolume() string {
	if m != nil && m.SourceVolume != nil {
		return *m.SourceVolume
	}
	return ""
}

type NetworkBinding struct {
	BindIP           *string `protobuf:"bytes,2,opt,name=BindIP,json=bindIP" json:"BindIP,omitempty"`
	ContainerPort    *int64  `protobuf:"zigzag64,3,opt,name=ContainerPort,json=containerPort" json:"ContainerPort,omitempty"`
	HostPort         *int64  `protobuf:"zigzag64,4,opt,name=HostPort,json=hostPort" json:"HostPort,omitempty"`
	Protocol         *string `protobuf:"bytes,5,opt,name=Protocol,json=protocol" json:"Protocol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NetworkBinding) Reset()                    { *m = NetworkBinding{} }
func (m *NetworkBinding) String() string            { return proto.CompactTextString(m) }
func (*NetworkBinding) ProtoMessage()               {}
func (*NetworkBinding) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{30} }

func (m *NetworkBinding) GetBindIP() string {
	if m != nil && m.BindIP != nil {
		return *m.BindIP
	}
	return ""
}

func (m *NetworkBinding) GetContainerPort() int64 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *NetworkBinding) GetHostPort() int64 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *NetworkBinding) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

type PortMapping struct {
	ContainerPort    *int64  `protobuf:"zigzag64,2,opt,name=ContainerPort,json=containerPort" json:"ContainerPort,omitempty"`
	HostPort         *int64  `protobuf:"zigzag64,3,opt,name=HostPort,json=hostPort" json:"HostPort,omitempty"`
	Protocol         *string `protobuf:"bytes,4,opt,name=Protocol,json=protocol" json:"Protocol,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PortMapping) Reset()                    { *m = PortMapping{} }
func (m *PortMapping) String() string            { return proto.CompactTextString(m) }
func (*PortMapping) ProtoMessage()               {}
func (*PortMapping) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{31} }

func (m *PortMapping) GetContainerPort() int64 {
	if m != nil && m.ContainerPort != nil {
		return *m.ContainerPort
	}
	return 0
}

func (m *PortMapping) GetHostPort() int64 {
	if m != nil && m.HostPort != nil {
		return *m.HostPort
	}
	return 0
}

func (m *PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

type Resource struct {
	DoubleValue      *float64 `protobuf:"fixed64,2,opt,name=DoubleValue,json=doubleValue" json:"DoubleValue,omitempty"`
	IntegerValue     *int64   `protobuf:"zigzag64,3,opt,name=IntegerValue,json=integerValue" json:"IntegerValue,omitempty"`
	LongValue        *int64   `protobuf:"zigzag64,4,opt,name=LongValue,json=longValue" json:"LongValue,omitempty"`
	Name             *string  `protobuf:"bytes,5,opt,name=Name,json=name" json:"Name,omitempty"`
	StringSetValue   []string `protobuf:"bytes,6,rep,name=StringSetValue,json=stringSetValue" json:"StringSetValue,omitempty"`
	Type             *string  `protobuf:"bytes,7,opt,name=Type,json=type" json:"Type,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Resource) Reset()                    { *m = Resource{} }
func (m *Resource) String() string            { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()               {}
func (*Resource) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{32} }

func (m *Resource) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Resource) GetIntegerValue() int64 {
	if m != nil && m.IntegerValue != nil {
		return *m.IntegerValue
	}
	return 0
}

func (m *Resource) GetLongValue() int64 {
	if m != nil && m.LongValue != nil {
		return *m.LongValue
	}
	return 0
}

func (m *Resource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Resource) GetStringSetValue() []string {
	if m != nil {
		return m.StringSetValue
	}
	return nil
}

func (m *Resource) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

type Service struct {
	ClusterArn              *string                  `protobuf:"bytes,2,opt,name=ClusterArn,json=clusterArn" json:"ClusterArn,omitempty"`
	CreatedAt               *opsee_types.Timestamp   `protobuf:"bytes,3,opt,name=CreatedAt,json=createdAt" json:"CreatedAt,omitempty"`
	DeploymentConfiguration *DeploymentConfiguration `protobuf:"bytes,4,opt,name=DeploymentConfiguration,json=deploymentConfiguration" json:"DeploymentConfiguration,omitempty"`
	Deployments             []*Deployment            `protobuf:"bytes,5,rep,name=Deployments,json=deployments" json:"Deployments,omitempty"`
	DesiredCount            *int64                   `protobuf:"zigzag64,6,opt,name=DesiredCount,json=desiredCount" json:"DesiredCount,omitempty"`
	Events                  []*ServiceEvent          `protobuf:"bytes,7,rep,name=Events,json=events" json:"Events,omitempty"`
	LoadBalancers           []*LoadBalancer          `protobuf:"bytes,8,rep,name=LoadBalancers,json=loadBalancers" json:"LoadBalancers,omitempty"`
	PendingCount            *int64                   `protobuf:"zigzag64,9,opt,name=PendingCount,json=pendingCount" json:"PendingCount,omitempty"`
	RoleArn                 *string                  `protobuf:"bytes,10,opt,name=RoleArn,json=roleArn" json:"RoleArn,omitempty"`
	RunningCount            *int64                   `protobuf:"zigzag64,11,opt,name=RunningCount,json=runningCount" json:"RunningCount,omitempty"`
	ServiceArn              *string                  `protobuf:"bytes,12,opt,name=ServiceArn,json=serviceArn" json:"ServiceArn,omitempty"`
	ServiceName             *string                  `protobuf:"bytes,13,opt,name=ServiceName,json=serviceName" json:"ServiceName,omitempty"`
	Status                  *string                  `protobuf:"bytes,14,opt,name=Status,json=status" json:"Status,omitempty"`
	TaskDefinition          *string                  `protobuf:"bytes,15,opt,name=TaskDefinition,json=taskDefinition" json:"TaskDefinition,omitempty"`
	XXX_unrecognized        []byte                   `json:"-"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{33} }

func (m *Service) GetClusterArn() string {
	if m != nil && m.ClusterArn != nil {
		return *m.ClusterArn
	}
	return ""
}

func (m *Service) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Service) GetDeploymentConfiguration() *DeploymentConfiguration {
	if m != nil {
		return m.DeploymentConfiguration
	}
	return nil
}

func (m *Service) GetDeployments() []*Deployment {
	if m != nil {
		return m.Deployments
	}
	return nil
}

func (m *Service) GetDesiredCount() int64 {
	if m != nil && m.DesiredCount != nil {
		return *m.DesiredCount
	}
	return 0
}

func (m *Service) GetEvents() []*ServiceEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Service) GetLoadBalancers() []*LoadBalancer {
	if m != nil {
		return m.LoadBalancers
	}
	return nil
}

func (m *Service) GetPendingCount() int64 {
	if m != nil && m.PendingCount != nil {
		return *m.PendingCount
	}
	return 0
}

func (m *Service) GetRoleArn() string {
	if m != nil && m.RoleArn != nil {
		return *m.RoleArn
	}
	return ""
}

func (m *Service) GetRunningCount() int64 {
	if m != nil && m.RunningCount != nil {
		return *m.RunningCount
	}
	return 0
}

func (m *Service) GetServiceArn() string {
	if m != nil && m.ServiceArn != nil {
		return *m.ServiceArn
	}
	return ""
}

func (m *Service) GetServiceName() string {
	if m != nil && m.ServiceName != nil {
		return *m.ServiceName
	}
	return ""
}

func (m *Service) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *Service) GetTaskDefinition() string {
	if m != nil && m.TaskDefinition != nil {
		return *m.TaskDefinition
	}
	return ""
}

type ServiceEvent struct {
	CreatedAt        *opsee_types.Timestamp `protobuf:"bytes,2,opt,name=CreatedAt,json=createdAt" json:"CreatedAt,omitempty"`
	Id               *string                `protobuf:"bytes,3,opt,name=Id,json=id" json:"Id,omitempty"`
	Message          *string                `protobuf:"bytes,4,opt,name=Message,json=message" json:"Message,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *ServiceEvent) Reset()                    { *m = ServiceEvent{} }
func (m *ServiceEvent) String() string            { return proto.CompactTextString(m) }
func (*ServiceEvent) ProtoMessage()               {}
func (*ServiceEvent) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{34} }

func (m *ServiceEvent) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *ServiceEvent) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ServiceEvent) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

type Task struct {
	ClusterArn           *string                `protobuf:"bytes,2,opt,name=ClusterArn,json=clusterArn" json:"ClusterArn,omitempty"`
	ContainerInstanceArn *string                `protobuf:"bytes,3,opt,name=ContainerInstanceArn,json=containerInstanceArn" json:"ContainerInstanceArn,omitempty"`
	Containers           []*Container           `protobuf:"bytes,4,rep,name=Containers,json=containers" json:"Containers,omitempty"`
	CreatedAt            *opsee_types.Timestamp `protobuf:"bytes,5,opt,name=CreatedAt,json=createdAt" json:"CreatedAt,omitempty"`
	DesiredStatus        *string                `protobuf:"bytes,6,opt,name=DesiredStatus,json=desiredStatus" json:"DesiredStatus,omitempty"`
	LastStatus           *string                `protobuf:"bytes,7,opt,name=LastStatus,json=lastStatus" json:"LastStatus,omitempty"`
	Overrides            *TaskOverride          `protobuf:"bytes,8,opt,name=Overrides,json=overrides" json:"Overrides,omitempty"`
	StartedAt            *opsee_types.Timestamp `protobuf:"bytes,9,opt,name=StartedAt,json=startedAt" json:"StartedAt,omitempty"`
	StartedBy            *string                `protobuf:"bytes,10,opt,name=StartedBy,json=startedBy" json:"StartedBy,omitempty"`
	StoppedAt            *opsee_types.Timestamp `protobuf:"bytes,11,opt,name=StoppedAt,json=stoppedAt" json:"StoppedAt,omitempty"`
	StoppedReason        *string                `protobuf:"bytes,12,opt,name=StoppedReason,json=stoppedReason" json:"StoppedReason,omitempty"`
	TaskArn              *string                `protobuf:"bytes,13,opt,name=TaskArn,json=taskArn" json:"TaskArn,omitempty"`
	TaskDefinitionArn    *string                `protobuf:"bytes,14,opt,name=TaskDefinitionArn,json=taskDefinitionArn" json:"TaskDefinitionArn,omitempty"`
	XXX_unrecognized     []byte                 `json:"-"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{35} }

func (m *Task) GetClusterArn() string {
	if m != nil && m.ClusterArn != nil {
		return *m.ClusterArn
	}
	return ""
}

func (m *Task) GetContainerInstanceArn() string {
	if m != nil && m.ContainerInstanceArn != nil {
		return *m.ContainerInstanceArn
	}
	return ""
}

func (m *Task) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *Task) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Task) GetDesiredStatus() string {
	if m != nil && m.DesiredStatus != nil {
		return *m.DesiredStatus
	}
	return ""
}

func (m *Task) GetLastStatus() string {
	if m != nil && m.LastStatus != nil {
		return *m.LastStatus
	}
	return ""
}

func (m *Task) GetOverrides() *TaskOverride {
	if m != nil {
		return m.Overrides
	}
	return nil
}

func (m *Task) GetStartedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *Task) GetStartedBy() string {
	if m != nil && m.StartedBy != nil {
		return *m.StartedBy
	}
	return ""
}

func (m *Task) GetStoppedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.StoppedAt
	}
	return nil
}

func (m *Task) GetStoppedReason() string {
	if m != nil && m.StoppedReason != nil {
		return *m.StoppedReason
	}
	return ""
}

func (m *Task) GetTaskArn() string {
	if m != nil && m.TaskArn != nil {
		return *m.TaskArn
	}
	return ""
}

func (m *Task) GetTaskDefinitionArn() string {
	if m != nil && m.TaskDefinitionArn != nil {
		return *m.TaskDefinitionArn
	}
	return ""
}

type TaskDefinition struct {
	ContainerDefinitions []*ContainerDefinition `protobuf:"bytes,2,rep,name=ContainerDefinitions,json=containerDefinitions" json:"ContainerDefinitions,omitempty"`
	Family               *string                `protobuf:"bytes,3,opt,name=Family,json=family" json:"Family,omitempty"`
	RequiresAttributes   []*Attribute           `protobuf:"bytes,4,rep,name=RequiresAttributes,json=requiresAttributes" json:"RequiresAttributes,omitempty"`
	Revision             *int64                 `protobuf:"zigzag64,5,opt,name=Revision,json=revision" json:"Revision,omitempty"`
	Status               *string                `protobuf:"bytes,6,opt,name=Status,json=status" json:"Status,omitempty"`
	TaskDefinitionArn    *string                `protobuf:"bytes,7,opt,name=TaskDefinitionArn,json=taskDefinitionArn" json:"TaskDefinitionArn,omitempty"`
	Volumes              []*Volume              `protobuf:"bytes,8,rep,name=Volumes,json=volumes" json:"Volumes,omitempty"`
	XXX_unrecognized     []byte                 `json:"-"`
}

func (m *TaskDefinition) Reset()                    { *m = TaskDefinition{} }
func (m *TaskDefinition) String() string            { return proto.CompactTextString(m) }
func (*TaskDefinition) ProtoMessage()               {}
func (*TaskDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{36} }

func (m *TaskDefinition) GetContainerDefinitions() []*ContainerDefinition {
	if m != nil {
		return m.ContainerDefinitions
	}
	return nil
}

func (m *TaskDefinition) GetFamily() string {
	if m != nil && m.Family != nil {
		return *m.Family
	}
	return ""
}

func (m *TaskDefinition) GetRequiresAttributes() []*Attribute {
	if m != nil {
		return m.RequiresAttributes
	}
	return nil
}

func (m *TaskDefinition) GetRevision() int64 {
	if m != nil && m.Revision != nil {
		return *m.Revision
	}
	return 0
}

func (m *TaskDefinition) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *TaskDefinition) GetTaskDefinitionArn() string {
	if m != nil && m.TaskDefinitionArn != nil {
		return *m.TaskDefinitionArn
	}
	return ""
}

func (m *TaskDefinition) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type TaskOverride struct {
	ContainerOverrides []*ContainerOverride `protobuf:"bytes,2,rep,name=ContainerOverrides,json=containerOverrides" json:"ContainerOverrides,omitempty"`
	XXX_unrecognized   []byte               `json:"-"`
}

func (m *TaskOverride) Reset()                    { *m = TaskOverride{} }
func (m *TaskOverride) String() string            { return proto.CompactTextString(m) }
func (*TaskOverride) ProtoMessage()               {}
func (*TaskOverride) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{37} }

func (m *TaskOverride) GetContainerOverrides() []*ContainerOverride {
	if m != nil {
		return m.ContainerOverrides
	}
	return nil
}

type Ulimit struct {
	HardLimit        *int64  `protobuf:"zigzag64,2,opt,name=HardLimit,json=hardLimit" json:"HardLimit,omitempty"`
	Name             *string `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
	SoftLimit        *int64  `protobuf:"zigzag64,4,opt,name=SoftLimit,json=softLimit" json:"SoftLimit,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Ulimit) Reset()                    { *m = Ulimit{} }
func (m *Ulimit) String() string            { return proto.CompactTextString(m) }
func (*Ulimit) ProtoMessage()               {}
func (*Ulimit) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{38} }

func (m *Ulimit) GetHardLimit() int64 {
	if m != nil && m.HardLimit != nil {
		return *m.HardLimit
	}
	return 0
}

func (m *Ulimit) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Ulimit) GetSoftLimit() int64 {
	if m != nil && m.SoftLimit != nil {
		return *m.SoftLimit
	}
	return 0
}

type VersionInfo struct {
	AgentHash        *string `protobuf:"bytes,2,opt,name=AgentHash,json=agentHash" json:"AgentHash,omitempty"`
	AgentVersion     *string `protobuf:"bytes,3,opt,name=AgentVersion,json=agentVersion" json:"AgentVersion,omitempty"`
	DockerVersion    *string `protobuf:"bytes,4,opt,name=DockerVersion,json=dockerVersion" json:"DockerVersion,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VersionInfo) Reset()                    { *m = VersionInfo{} }
func (m *VersionInfo) String() string            { return proto.CompactTextString(m) }
func (*VersionInfo) ProtoMessage()               {}
func (*VersionInfo) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{39} }

func (m *VersionInfo) GetAgentHash() string {
	if m != nil && m.AgentHash != nil {
		return *m.AgentHash
	}
	return ""
}

func (m *VersionInfo) GetAgentVersion() string {
	if m != nil && m.AgentVersion != nil {
		return *m.AgentVersion
	}
	return ""
}

func (m *VersionInfo) GetDockerVersion() string {
	if m != nil && m.DockerVersion != nil {
		return *m.DockerVersion
	}
	return ""
}

type Volume struct {
	Host             *HostVolumeProperties `protobuf:"bytes,2,opt,name=Host,json=host" json:"Host,omitempty"`
	Name             *string               `protobuf:"bytes,3,opt,name=Name,json=name" json:"Name,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{40} }

func (m *Volume) GetHost() *HostVolumeProperties {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Volume) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type VolumeFrom struct {
	ReadOnly         *bool   `protobuf:"varint,2,opt,name=ReadOnly,json=readOnly" json:"ReadOnly,omitempty"`
	SourceContainer  *string `protobuf:"bytes,3,opt,name=SourceContainer,json=sourceContainer" json:"SourceContainer,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *VolumeFrom) Reset()                    { *m = VolumeFrom{} }
func (m *VolumeFrom) String() string            { return proto.CompactTextString(m) }
func (*VolumeFrom) ProtoMessage()               {}
func (*VolumeFrom) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{41} }

func (m *VolumeFrom) GetReadOnly() bool {
	if m != nil && m.ReadOnly != nil {
		return *m.ReadOnly
	}
	return false
}

func (m *VolumeFrom) GetSourceContainer() string {
	if m != nil && m.SourceContainer != nil {
		return *m.SourceContainer
	}
	return ""
}

func init() {
	proto.RegisterType((*Attribute)(nil), "opsee.aws.ecs.Attribute")
	proto.RegisterType((*Container)(nil), "opsee.aws.ecs.Container")
	proto.RegisterType((*ContainerDefinition)(nil), "opsee.aws.ecs.ContainerDefinition")
	proto.RegisterType((*ContainerInstance)(nil), "opsee.aws.ecs.ContainerInstance")
	proto.RegisterType((*ContainerOverride)(nil), "opsee.aws.ecs.ContainerOverride")
	proto.RegisterType((*Deployment)(nil), "opsee.aws.ecs.Deployment")
	proto.RegisterType((*DeploymentConfiguration)(nil), "opsee.aws.ecs.DeploymentConfiguration")
	proto.RegisterType((*DescribeContainerInstancesInput)(nil), "opsee.aws.ecs.DescribeContainerInstancesInput")
	proto.RegisterType((*DescribeContainerInstancesOutput)(nil), "opsee.aws.ecs.DescribeContainerInstancesOutput")
	proto.RegisterType((*DescribeServicesInput)(nil), "opsee.aws.ecs.DescribeServicesInput")
	proto.RegisterType((*DescribeServicesOutput)(nil), "opsee.aws.ecs.DescribeServicesOutput")
	proto.RegisterType((*DescribeTaskDefinitionInput)(nil), "opsee.aws.ecs.DescribeTaskDefinitionInput")
	proto.RegisterType((*DescribeTaskDefinitionOutput)(nil), "opsee.aws.ecs.DescribeTaskDefinitionOutput")
	proto.RegisterType((*DescribeTasksInput)(nil), "opsee.aws.ecs.DescribeTasksInput")
	proto.RegisterType((*DescribeTasksOutput)(nil), "opsee.aws.ecs.DescribeTasksOutput")
	proto.RegisterType((*Failure)(nil), "opsee.aws.ecs.Failure")
	proto.RegisterType((*HostEntry)(nil), "opsee.aws.ecs.HostEntry")
	proto.RegisterType((*HostVolumeProperties)(nil), "opsee.aws.ecs.HostVolumeProperties")
	proto.RegisterType((*KeyValuePair)(nil), "opsee.aws.ecs.KeyValuePair")
	proto.RegisterType((*ListClustersInput)(nil), "opsee.aws.ecs.ListClustersInput")
	proto.RegisterType((*ListClustersOutput)(nil), "opsee.aws.ecs.ListClustersOutput")
	proto.RegisterType((*ListContainerInstancesInput)(nil), "opsee.aws.ecs.ListContainerInstancesInput")
	proto.RegisterType((*ListContainerInstancesOutput)(nil), "opsee.aws.ecs.ListContainerInstancesOutput")
	proto.RegisterType((*ListServicesInput)(nil), "opsee.aws.ecs.ListServicesInput")
	proto.RegisterType((*ListServicesOutput)(nil), "opsee.aws.ecs.ListServicesOutput")
	proto.RegisterType((*ListTasksInput)(nil), "opsee.aws.ecs.ListTasksInput")
	proto.RegisterType((*ListTasksOutput)(nil), "opsee.aws.ecs.ListTasksOutput")
	proto.RegisterType((*LoadBalancer)(nil), "opsee.aws.ecs.LoadBalancer")
	proto.RegisterType((*LogConfiguration)(nil), "opsee.aws.ecs.LogConfiguration")
	proto.RegisterType((*MountPoint)(nil), "opsee.aws.ecs.MountPoint")
	proto.RegisterType((*NetworkBinding)(nil), "opsee.aws.ecs.NetworkBinding")
	proto.RegisterType((*PortMapping)(nil), "opsee.aws.ecs.PortMapping")
	proto.RegisterType((*Resource)(nil), "opsee.aws.ecs.Resource")
	proto.RegisterType((*Service)(nil), "opsee.aws.ecs.Service")
	proto.RegisterType((*ServiceEvent)(nil), "opsee.aws.ecs.ServiceEvent")
	proto.RegisterType((*Task)(nil), "opsee.aws.ecs.Task")
	proto.RegisterType((*TaskDefinition)(nil), "opsee.aws.ecs.TaskDefinition")
	proto.RegisterType((*TaskOverride)(nil), "opsee.aws.ecs.TaskOverride")
	proto.RegisterType((*Ulimit)(nil), "opsee.aws.ecs.Ulimit")
	proto.RegisterType((*VersionInfo)(nil), "opsee.aws.ecs.VersionInfo")
	proto.RegisterType((*Volume)(nil), "opsee.aws.ecs.Volume")
	proto.RegisterType((*VolumeFrom)(nil), "opsee.aws.ecs.VolumeFrom")
}
func (this *Attribute) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attribute)
	if !ok {
		that2, ok := that.(Attribute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Container) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Container)
	if !ok {
		that2, ok := that.(Container)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ContainerArn != nil && that1.ContainerArn != nil {
		if *this.ContainerArn != *that1.ContainerArn {
			return false
		}
	} else if this.ContainerArn != nil {
		return false
	} else if that1.ContainerArn != nil {
		return false
	}
	if this.ExitCode != nil && that1.ExitCode != nil {
		if *this.ExitCode != *that1.ExitCode {
			return false
		}
	} else if this.ExitCode != nil {
		return false
	} else if that1.ExitCode != nil {
		return false
	}
	if this.LastStatus != nil && that1.LastStatus != nil {
		if *this.LastStatus != *that1.LastStatus {
			return false
		}
	} else if this.LastStatus != nil {
		return false
	} else if that1.LastStatus != nil {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if len(this.NetworkBindings) != len(that1.NetworkBindings) {
		return false
	}
	for i := range this.NetworkBindings {
		if !this.NetworkBindings[i].Equal(that1.NetworkBindings[i]) {
			return false
		}
	}
	if this.Reason != nil && that1.Reason != nil {
		if *this.Reason != *that1.Reason {
			return false
		}
	} else if this.Reason != nil {
		return false
	} else if that1.Reason != nil {
		return false
	}
	if this.TaskArn != nil && that1.TaskArn != nil {
		if *this.TaskArn != *that1.TaskArn {
			return false
		}
	} else if this.TaskArn != nil {
		return false
	} else if that1.TaskArn != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainerDefinition) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerDefinition)
	if !ok {
		that2, ok := that.(ContainerDefinition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if this.Cpu != nil && that1.Cpu != nil {
		if *this.Cpu != *that1.Cpu {
			return false
		}
	} else if this.Cpu != nil {
		return false
	} else if that1.Cpu != nil {
		return false
	}
	if this.DisableNetworking != nil && that1.DisableNetworking != nil {
		if *this.DisableNetworking != *that1.DisableNetworking {
			return false
		}
	} else if this.DisableNetworking != nil {
		return false
	} else if that1.DisableNetworking != nil {
		return false
	}
	if len(this.DnsSearchDomains) != len(that1.DnsSearchDomains) {
		return false
	}
	for i := range this.DnsSearchDomains {
		if this.DnsSearchDomains[i] != that1.DnsSearchDomains[i] {
			return false
		}
	}
	if len(this.DnsServers) != len(that1.DnsServers) {
		return false
	}
	for i := range this.DnsServers {
		if this.DnsServers[i] != that1.DnsServers[i] {
			return false
		}
	}
	if len(this.DockerLabels) != len(that1.DockerLabels) {
		return false
	}
	for i := range this.DockerLabels {
		if this.DockerLabels[i] != that1.DockerLabels[i] {
			return false
		}
	}
	if len(this.DockerSecurityOptions) != len(that1.DockerSecurityOptions) {
		return false
	}
	for i := range this.DockerSecurityOptions {
		if this.DockerSecurityOptions[i] != that1.DockerSecurityOptions[i] {
			return false
		}
	}
	if len(this.EntryPoint) != len(that1.EntryPoint) {
		return false
	}
	for i := range this.EntryPoint {
		if this.EntryPoint[i] != that1.EntryPoint[i] {
			return false
		}
	}
	if len(this.Environment) != len(that1.Environment) {
		return false
	}
	for i := range this.Environment {
		if !this.Environment[i].Equal(that1.Environment[i]) {
			return false
		}
	}
	if this.Essential != nil && that1.Essential != nil {
		if *this.Essential != *that1.Essential {
			return false
		}
	} else if this.Essential != nil {
		return false
	} else if that1.Essential != nil {
		return false
	}
	if len(this.ExtraHosts) != len(that1.ExtraHosts) {
		return false
	}
	for i := range this.ExtraHosts {
		if !this.ExtraHosts[i].Equal(that1.ExtraHosts[i]) {
			return false
		}
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.Image != nil && that1.Image != nil {
		if *this.Image != *that1.Image {
			return false
		}
	} else if this.Image != nil {
		return false
	} else if that1.Image != nil {
		return false
	}
	if len(this.Links) != len(that1.Links) {
		return false
	}
	for i := range this.Links {
		if this.Links[i] != that1.Links[i] {
			return false
		}
	}
	if !this.LogConfiguration.Equal(that1.LogConfiguration) {
		return false
	}
	if this.Memory != nil && that1.Memory != nil {
		if *this.Memory != *that1.Memory {
			return false
		}
	} else if this.Memory != nil {
		return false
	} else if that1.Memory != nil {
		return false
	}
	if len(this.MountPoints) != len(that1.MountPoints) {
		return false
	}
	for i := range this.MountPoints {
		if !this.MountPoints[i].Equal(that1.MountPoints[i]) {
			return false
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if len(this.PortMappings) != len(that1.PortMappings) {
		return false
	}
	for i := range this.PortMappings {
		if !this.PortMappings[i].Equal(that1.PortMappings[i]) {
			return false
		}
	}
	if this.Privileged != nil && that1.Privileged != nil {
		if *this.Privileged != *that1.Privileged {
			return false
		}
	} else if this.Privileged != nil {
		return false
	} else if that1.Privileged != nil {
		return false
	}
	if this.ReadonlyRootFilesystem != nil && that1.ReadonlyRootFilesystem != nil {
		if *this.ReadonlyRootFilesystem != *that1.ReadonlyRootFilesystem {
			return false
		}
	} else if this.ReadonlyRootFilesystem != nil {
		return false
	} else if that1.ReadonlyRootFilesystem != nil {
		return false
	}
	if len(this.Ulimits) != len(that1.Ulimits) {
		return false
	}
	for i := range this.Ulimits {
		if !this.Ulimits[i].Equal(that1.Ulimits[i]) {
			return false
		}
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	if len(this.VolumesFrom) != len(that1.VolumesFrom) {
		return false
	}
	for i := range this.VolumesFrom {
		if !this.VolumesFrom[i].Equal(that1.VolumesFrom[i]) {
			return false
		}
	}
	if this.WorkingDirectory != nil && that1.WorkingDirectory != nil {
		if *this.WorkingDirectory != *that1.WorkingDirectory {
			return false
		}
	} else if this.WorkingDirectory != nil {
		return false
	} else if that1.WorkingDirectory != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainerInstance) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInstance)
	if !ok {
		that2, ok := that.(ContainerInstance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.AgentConnected != nil && that1.AgentConnected != nil {
		if *this.AgentConnected != *that1.AgentConnected {
			return false
		}
	} else if this.AgentConnected != nil {
		return false
	} else if that1.AgentConnected != nil {
		return false
	}
	if this.AgentUpdateStatus != nil && that1.AgentUpdateStatus != nil {
		if *this.AgentUpdateStatus != *that1.AgentUpdateStatus {
			return false
		}
	} else if this.AgentUpdateStatus != nil {
		return false
	} else if that1.AgentUpdateStatus != nil {
		return false
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(that1.Attributes[i]) {
			return false
		}
	}
	if this.ContainerInstanceArn != nil && that1.ContainerInstanceArn != nil {
		if *this.ContainerInstanceArn != *that1.ContainerInstanceArn {
			return false
		}
	} else if this.ContainerInstanceArn != nil {
		return false
	} else if that1.ContainerInstanceArn != nil {
		return false
	}
	if this.Ec2InstanceId != nil && that1.Ec2InstanceId != nil {
		if *this.Ec2InstanceId != *that1.Ec2InstanceId {
			return false
		}
	} else if this.Ec2InstanceId != nil {
		return false
	} else if that1.Ec2InstanceId != nil {
		return false
	}
	if this.PendingTasksCount != nil && that1.PendingTasksCount != nil {
		if *this.PendingTasksCount != *that1.PendingTasksCount {
			return false
		}
	} else if this.PendingTasksCount != nil {
		return false
	} else if that1.PendingTasksCount != nil {
		return false
	}
	if len(this.RegisteredResources) != len(that1.RegisteredResources) {
		return false
	}
	for i := range this.RegisteredResources {
		if !this.RegisteredResources[i].Equal(that1.RegisteredResources[i]) {
			return false
		}
	}
	if len(this.RemainingResources) != len(that1.RemainingResources) {
		return false
	}
	for i := range this.RemainingResources {
		if !this.RemainingResources[i].Equal(that1.RemainingResources[i]) {
			return false
		}
	}
	if this.RunningTasksCount != nil && that1.RunningTasksCount != nil {
		if *this.RunningTasksCount != *that1.RunningTasksCount {
			return false
		}
	} else if this.RunningTasksCount != nil {
		return false
	} else if that1.RunningTasksCount != nil {
		return false
	}
	if this.Status != nil && that1.Status != nil {
		if *this.Status != *that1.Status {
			return false
		}
	} else if this.Status != nil {
		return false
	} else if that1.Status != nil {
		return false
	}
	if !this.VersionInfo.Equal(that1.VersionInfo) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainerOverride) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerOverride)
	if !ok {
		that2, ok := that.(ContainerOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Environment) != len(that1.Environment) {
		return false
	}
	for i := range this.Environment {
		if !this.Environment[i].Equal(that1.Environment[i]) {
			return false
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Deployment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Deployment)
	if !ok {
		that2, ok := that.(Deployment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.DesiredCount != nil && that1.DesiredCount != nil {
		if *this.DesiredCount != *that1.DesiredCount {
			return false
		}
	} else if this.DesiredCount != nil {
		return false
	} else if that1.DesiredCount != nil {
		return false
	}
	if this.Id != nil && that1.Id != nil {
		if *this.Id != *that1.Id {
			return false
		}
	} else if this.Id != nil {
		return false
	} else if that1.Id != nil {
		return false
	}
	if this.PendingCount != nil && that1.PendingCount != nil {
		if *this.PendingCount != *that1.PendingCount {
			return false
		}
	} else if this.PendingCount != nil {
		return false
	} else if that1.PendingCount != nil {
		return false
	}
	if this.RunningCount != nil && that1.RunningCount != nil {
		if *this.RunningCount != *that1.RunningCount {
			return false
		}
	} else if this.RunningCount != nil {
		return false
	} else if that1.RunningCount != nil {
		return false
	}
	if this.Status != nil && that1.Status != nil {
		if *this.Status != *that1.Status {
			return false
		}
	} else if this.Status != nil {
		return false
	} else if that1.Status != nil {
		return false
	}
	if this.TaskDefinition != nil && that1.TaskDefinition != nil {
		if *this.TaskDefinition != *that1.TaskDefinition {
			return false
		}
	} else if this.TaskDefinition != nil {
		return false
	} else if that1.TaskDefinition != nil {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DeploymentConfiguration) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeploymentConfiguration)
	if !ok {
		that2, ok := that.(DeploymentConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MaximumPercent != nil && that1.MaximumPercent != nil {
		if *this.MaximumPercent != *that1.MaximumPercent {
			return false
		}
	} else if this.MaximumPercent != nil {
		return false
	} else if that1.MaximumPercent != nil {
		return false
	}
	if this.MinimumHealthyPercent != nil && that1.MinimumHealthyPercent != nil {
		if *this.MinimumHealthyPercent != *that1.MinimumHealthyPercent {
			return false
		}
	} else if this.MinimumHealthyPercent != nil {
		return false
	} else if that1.MinimumHealthyPercent != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeContainerInstancesInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeContainerInstancesInput)
	if !ok {
		that2, ok := that.(DescribeContainerInstancesInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if len(this.ContainerInstances) != len(that1.ContainerInstances) {
		return false
	}
	for i := range this.ContainerInstances {
		if this.ContainerInstances[i] != that1.ContainerInstances[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeContainerInstancesOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeContainerInstancesOutput)
	if !ok {
		that2, ok := that.(DescribeContainerInstancesOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerInstances) != len(that1.ContainerInstances) {
		return false
	}
	for i := range this.ContainerInstances {
		if !this.ContainerInstances[i].Equal(that1.ContainerInstances[i]) {
			return false
		}
	}
	if len(this.Failures) != len(that1.Failures) {
		return false
	}
	for i := range this.Failures {
		if !this.Failures[i].Equal(that1.Failures[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeServicesInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeServicesInput)
	if !ok {
		that2, ok := that.(DescribeServicesInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeServicesOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeServicesOutput)
	if !ok {
		that2, ok := that.(DescribeServicesOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Failures) != len(that1.Failures) {
		return false
	}
	for i := range this.Failures {
		if !this.Failures[i].Equal(that1.Failures[i]) {
			return false
		}
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if !this.Services[i].Equal(that1.Services[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeTaskDefinitionInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeTaskDefinitionInput)
	if !ok {
		that2, ok := that.(DescribeTaskDefinitionInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TaskDefinition != nil && that1.TaskDefinition != nil {
		if *this.TaskDefinition != *that1.TaskDefinition {
			return false
		}
	} else if this.TaskDefinition != nil {
		return false
	} else if that1.TaskDefinition != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeTaskDefinitionOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeTaskDefinitionOutput)
	if !ok {
		that2, ok := that.(DescribeTaskDefinitionOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TaskDefinition.Equal(that1.TaskDefinition) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeTasksInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeTasksInput)
	if !ok {
		that2, ok := that.(DescribeTasksInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return false
	}
	for i := range this.Tasks {
		if this.Tasks[i] != that1.Tasks[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescribeTasksOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DescribeTasksOutput)
	if !ok {
		that2, ok := that.(DescribeTasksOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Failures) != len(that1.Failures) {
		return false
	}
	for i := range this.Failures {
		if !this.Failures[i].Equal(that1.Failures[i]) {
			return false
		}
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return false
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(that1.Tasks[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Failure) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Failure)
	if !ok {
		that2, ok := that.(Failure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Arn != nil && that1.Arn != nil {
		if *this.Arn != *that1.Arn {
			return false
		}
	} else if this.Arn != nil {
		return false
	} else if that1.Arn != nil {
		return false
	}
	if this.Reason != nil && that1.Reason != nil {
		if *this.Reason != *that1.Reason {
			return false
		}
	} else if this.Reason != nil {
		return false
	} else if that1.Reason != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HostEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HostEntry)
	if !ok {
		that2, ok := that.(HostEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.IpAddress != nil && that1.IpAddress != nil {
		if *this.IpAddress != *that1.IpAddress {
			return false
		}
	} else if this.IpAddress != nil {
		return false
	} else if that1.IpAddress != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *HostVolumeProperties) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HostVolumeProperties)
	if !ok {
		that2, ok := that.(HostVolumeProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SourcePath != nil && that1.SourcePath != nil {
		if *this.SourcePath != *that1.SourcePath {
			return false
		}
	} else if this.SourcePath != nil {
		return false
	} else if that1.SourcePath != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *KeyValuePair) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*KeyValuePair)
	if !ok {
		that2, ok := that.(KeyValuePair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListClustersInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListClustersInput)
	if !ok {
		that2, ok := that.(ListClustersInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MaxResults != nil && that1.MaxResults != nil {
		if *this.MaxResults != *that1.MaxResults {
			return false
		}
	} else if this.MaxResults != nil {
		return false
	} else if that1.MaxResults != nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListClustersOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListClustersOutput)
	if !ok {
		that2, ok := that.(ListClustersOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ClusterArns) != len(that1.ClusterArns) {
		return false
	}
	for i := range this.ClusterArns {
		if this.ClusterArns[i] != that1.ClusterArns[i] {
			return false
		}
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListContainerInstancesInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListContainerInstancesInput)
	if !ok {
		that2, ok := that.(ListContainerInstancesInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if this.MaxResults != nil && that1.MaxResults != nil {
		if *this.MaxResults != *that1.MaxResults {
			return false
		}
	} else if this.MaxResults != nil {
		return false
	} else if that1.MaxResults != nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListContainerInstancesOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListContainerInstancesOutput)
	if !ok {
		that2, ok := that.(ListContainerInstancesOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerInstanceArns) != len(that1.ContainerInstanceArns) {
		return false
	}
	for i := range this.ContainerInstanceArns {
		if this.ContainerInstanceArns[i] != that1.ContainerInstanceArns[i] {
			return false
		}
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListServicesInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListServicesInput)
	if !ok {
		that2, ok := that.(ListServicesInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if this.MaxResults != nil && that1.MaxResults != nil {
		if *this.MaxResults != *that1.MaxResults {
			return false
		}
	} else if this.MaxResults != nil {
		return false
	} else if that1.MaxResults != nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListServicesOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListServicesOutput)
	if !ok {
		that2, ok := that.(ListServicesOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if len(this.ServiceArns) != len(that1.ServiceArns) {
		return false
	}
	for i := range this.ServiceArns {
		if this.ServiceArns[i] != that1.ServiceArns[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListTasksInput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListTasksInput)
	if !ok {
		that2, ok := that.(ListTasksInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Cluster != nil && that1.Cluster != nil {
		if *this.Cluster != *that1.Cluster {
			return false
		}
	} else if this.Cluster != nil {
		return false
	} else if that1.Cluster != nil {
		return false
	}
	if this.ContainerInstance != nil && that1.ContainerInstance != nil {
		if *this.ContainerInstance != *that1.ContainerInstance {
			return false
		}
	} else if this.ContainerInstance != nil {
		return false
	} else if that1.ContainerInstance != nil {
		return false
	}
	if this.DesiredStatus != nil && that1.DesiredStatus != nil {
		if *this.DesiredStatus != *that1.DesiredStatus {
			return false
		}
	} else if this.DesiredStatus != nil {
		return false
	} else if that1.DesiredStatus != nil {
		return false
	}
	if this.Family != nil && that1.Family != nil {
		if *this.Family != *that1.Family {
			return false
		}
	} else if this.Family != nil {
		return false
	} else if that1.Family != nil {
		return false
	}
	if this.MaxResults != nil && that1.MaxResults != nil {
		if *this.MaxResults != *that1.MaxResults {
			return false
		}
	} else if this.MaxResults != nil {
		return false
	} else if that1.MaxResults != nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if this.ServiceName != nil && that1.ServiceName != nil {
		if *this.ServiceName != *that1.ServiceName {
			return false
		}
	} else if this.ServiceName != nil {
		return false
	} else if that1.ServiceName != nil {
		return false
	}
	if this.StartedBy != nil && that1.StartedBy != nil {
		if *this.StartedBy != *that1.StartedBy {
			return false
		}
	} else if this.StartedBy != nil {
		return false
	} else if that1.StartedBy != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListTasksOutput) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ListTasksOutput)
	if !ok {
		that2, ok := that.(ListTasksOutput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NextToken != nil && that1.NextToken != nil {
		if *this.NextToken != *that1.NextToken {
			return false
		}
	} else if this.NextToken != nil {
		return false
	} else if that1.NextToken != nil {
		return false
	}
	if len(this.TaskArns) != len(that1.TaskArns) {
		return false
	}
	for i := range this.TaskArns {
		if this.TaskArns[i] != that1.TaskArns[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LoadBalancer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LoadBalancer)
	if !ok {
		that2, ok := that.(LoadBalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ContainerName != nil && that1.ContainerName != nil {
		if *this.ContainerName != *that1.ContainerName {
			return false
		}
	} else if this.ContainerName != nil {
		return false
	} else if that1.ContainerName != nil {
		return false
	}
	if this.ContainerPort != nil && that1.ContainerPort != nil {
		if *this.ContainerPort != *that1.ContainerPort {
			return false
		}
	} else if this.ContainerPort != nil {
		return false
	} else if that1.ContainerPort != nil {
		return false
	}
	if this.LoadBalancerName != nil && that1.LoadBalancerName != nil {
		if *this.LoadBalancerName != *that1.LoadBalancerName {
			return false
		}
	} else if this.LoadBalancerName != nil {
		return false
	} else if that1.LoadBalancerName != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LogConfiguration) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LogConfiguration)
	if !ok {
		that2, ok := that.(LogConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LogDriver != nil && that1.LogDriver != nil {
		if *this.LogDriver != *that1.LogDriver {
			return false
		}
	} else if this.LogDriver != nil {
		return false
	} else if that1.LogDriver != nil {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MountPoint) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MountPoint)
	if !ok {
		that2, ok := that.(MountPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ContainerPath != nil && that1.ContainerPath != nil {
		if *this.ContainerPath != *that1.ContainerPath {
			return false
		}
	} else if this.ContainerPath != nil {
		return false
	} else if that1.ContainerPath != nil {
		return false
	}
	if this.ReadOnly != nil && that1.ReadOnly != nil {
		if *this.ReadOnly != *that1.ReadOnly {
			return false
		}
	} else if this.ReadOnly != nil {
		return false
	} else if that1.ReadOnly != nil {
		return false
	}
	if this.SourceVolume != nil && that1.SourceVolume != nil {
		if *this.SourceVolume != *that1.SourceVolume {
			return false
		}
	} else if this.SourceVolume != nil {
		return false
	} else if that1.SourceVolume != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NetworkBinding) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetworkBinding)
	if !ok {
		that2, ok := that.(NetworkBinding)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.BindIP != nil && that1.BindIP != nil {
		if *this.BindIP != *that1.BindIP {
			return false
		}
	} else if this.BindIP != nil {
		return false
	} else if that1.BindIP != nil {
		return false
	}
	if this.ContainerPort != nil && that1.ContainerPort != nil {
		if *this.ContainerPort != *that1.ContainerPort {
			return false
		}
	} else if this.ContainerPort != nil {
		return false
	} else if that1.ContainerPort != nil {
		return false
	}
	if this.HostPort != nil && that1.HostPort != nil {
		if *this.HostPort != *that1.HostPort {
			return false
		}
	} else if this.HostPort != nil {
		return false
	} else if that1.HostPort != nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PortMapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PortMapping)
	if !ok {
		that2, ok := that.(PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ContainerPort != nil && that1.ContainerPort != nil {
		if *this.ContainerPort != *that1.ContainerPort {
			return false
		}
	} else if this.ContainerPort != nil {
		return false
	} else if that1.ContainerPort != nil {
		return false
	}
	if this.HostPort != nil && that1.HostPort != nil {
		if *this.HostPort != *that1.HostPort {
			return false
		}
	} else if this.HostPort != nil {
		return false
	} else if that1.HostPort != nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Resource) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DoubleValue != nil && that1.DoubleValue != nil {
		if *this.DoubleValue != *that1.DoubleValue {
			return false
		}
	} else if this.DoubleValue != nil {
		return false
	} else if that1.DoubleValue != nil {
		return false
	}
	if this.IntegerValue != nil && that1.IntegerValue != nil {
		if *this.IntegerValue != *that1.IntegerValue {
			return false
		}
	} else if this.IntegerValue != nil {
		return false
	} else if that1.IntegerValue != nil {
		return false
	}
	if this.LongValue != nil && that1.LongValue != nil {
		if *this.LongValue != *that1.LongValue {
			return false
		}
	} else if this.LongValue != nil {
		return false
	} else if that1.LongValue != nil {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if len(this.StringSetValue) != len(that1.StringSetValue) {
		return false
	}
	for i := range this.StringSetValue {
		if this.StringSetValue[i] != that1.StringSetValue[i] {
			return false
		}
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Service) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Service)
	if !ok {
		that2, ok := that.(Service)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClusterArn != nil && that1.ClusterArn != nil {
		if *this.ClusterArn != *that1.ClusterArn {
			return false
		}
	} else if this.ClusterArn != nil {
		return false
	} else if that1.ClusterArn != nil {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.DeploymentConfiguration.Equal(that1.DeploymentConfiguration) {
		return false
	}
	if len(this.Deployments) != len(that1.Deployments) {
		return false
	}
	for i := range this.Deployments {
		if !this.Deployments[i].Equal(that1.Deployments[i]) {
			return false
		}
	}
	if this.DesiredCount != nil && that1.DesiredCount != nil {
		if *this.DesiredCount != *that1.DesiredCount {
			return false
		}
	} else if this.DesiredCount != nil {
		return false
	} else if that1.DesiredCount != nil {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	if len(this.LoadBalancers) != len(that1.LoadBalancers) {
		return false
	}
	for i := range this.LoadBalancers {
		if !this.LoadBalancers[i].Equal(that1.LoadBalancers[i]) {
			return false
		}
	}
	if this.PendingCount != nil && that1.PendingCount != nil {
		if *this.PendingCount != *that1.PendingCount {
			return false
		}
	} else if this.PendingCount != nil {
		return false
	} else if that1.PendingCount != nil {
		return false
	}
	if this.RoleArn != nil && that1.RoleArn != nil {
		if *this.RoleArn != *that1.RoleArn {
			return false
		}
	} else if this.RoleArn != nil {
		return false
	} else if that1.RoleArn != nil {
		return false
	}
	if this.RunningCount != nil && that1.RunningCount != nil {
		if *this.RunningCount != *that1.RunningCount {
			return false
		}
	} else if this.RunningCount != nil {
		return false
	} else if that1.RunningCount != nil {
		return false
	}
	if this.ServiceArn != nil && that1.ServiceArn != nil {
		if *this.ServiceArn != *that1.ServiceArn {
			return false
		}
	} else if this.ServiceArn != nil {
		return false
	} else if that1.ServiceArn != nil {
		return false
	}
	if this.ServiceName != nil && that1.ServiceName != nil {
		if *this.ServiceName != *that1.ServiceName {
			return false
		}
	} else if this.ServiceName != nil {
		return false
	} else if that1.ServiceName != nil {
		return false
	}
	if this.Status != nil && that1.Status != nil {
		if *this.Status != *that1.Status {
			return false
		}
	} else if this.Status != nil {
		return false
	} else if that1.Status != nil {
		return false
	}
	if this.TaskDefinition != nil && that1.TaskDefinition != nil {
		if *this.TaskDefinition != *that1.TaskDefinition {
			return false
		}
	} else if this.TaskDefinition != nil {
		return false
	} else if that1.TaskDefinition != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ServiceEvent) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ServiceEvent)
	if !ok {
		that2, ok := that.(ServiceEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Id != nil && that1.Id != nil {
		if *this.Id != *that1.Id {
			return false
		}
	} else if this.Id != nil {
		return false
	} else if that1.Id != nil {
		return false
	}
	if this.Message != nil && that1.Message != nil {
		if *this.Message != *that1.Message {
			return false
		}
	} else if this.Message != nil {
		return false
	} else if that1.Message != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Task) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Task)
	if !ok {
		that2, ok := that.(Task)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClusterArn != nil && that1.ClusterArn != nil {
		if *this.ClusterArn != *that1.ClusterArn {
			return false
		}
	} else if this.ClusterArn != nil {
		return false
	} else if that1.ClusterArn != nil {
		return false
	}
	if this.ContainerInstanceArn != nil && that1.ContainerInstanceArn != nil {
		if *this.ContainerInstanceArn != *that1.ContainerInstanceArn {
			return false
		}
	} else if this.ContainerInstanceArn != nil {
		return false
	} else if that1.ContainerInstanceArn != nil {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.DesiredStatus != nil && that1.DesiredStatus != nil {
		if *this.DesiredStatus != *that1.DesiredStatus {
			return false
		}
	} else if this.DesiredStatus != nil {
		return false
	} else if that1.DesiredStatus != nil {
		return false
	}
	if this.LastStatus != nil && that1.LastStatus != nil {
		if *this.LastStatus != *that1.LastStatus {
			return false
		}
	} else if this.LastStatus != nil {
		return false
	} else if that1.LastStatus != nil {
		return false
	}
	if !this.Overrides.Equal(that1.Overrides) {
		return false
	}
	if !this.StartedAt.Equal(that1.StartedAt) {
		return false
	}
	if this.StartedBy != nil && that1.StartedBy != nil {
		if *this.StartedBy != *that1.StartedBy {
			return false
		}
	} else if this.StartedBy != nil {
		return false
	} else if that1.StartedBy != nil {
		return false
	}
	if !this.StoppedAt.Equal(that1.StoppedAt) {
		return false
	}
	if this.StoppedReason != nil && that1.StoppedReason != nil {
		if *this.StoppedReason != *that1.StoppedReason {
			return false
		}
	} else if this.StoppedReason != nil {
		return false
	} else if that1.StoppedReason != nil {
		return false
	}
	if this.TaskArn != nil && that1.TaskArn != nil {
		if *this.TaskArn != *that1.TaskArn {
			return false
		}
	} else if this.TaskArn != nil {
		return false
	} else if that1.TaskArn != nil {
		return false
	}
	if this.TaskDefinitionArn != nil && that1.TaskDefinitionArn != nil {
		if *this.TaskDefinitionArn != *that1.TaskDefinitionArn {
			return false
		}
	} else if this.TaskDefinitionArn != nil {
		return false
	} else if that1.TaskDefinitionArn != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TaskDefinition) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskDefinition)
	if !ok {
		that2, ok := that.(TaskDefinition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerDefinitions) != len(that1.ContainerDefinitions) {
		return false
	}
	for i := range this.ContainerDefinitions {
		if !this.ContainerDefinitions[i].Equal(that1.ContainerDefinitions[i]) {
			return false
		}
	}
	if this.Family != nil && that1.Family != nil {
		if *this.Family != *that1.Family {
			return false
		}
	} else if this.Family != nil {
		return false
	} else if that1.Family != nil {
		return false
	}
	if len(this.RequiresAttributes) != len(that1.RequiresAttributes) {
		return false
	}
	for i := range this.RequiresAttributes {
		if !this.RequiresAttributes[i].Equal(that1.RequiresAttributes[i]) {
			return false
		}
	}
	if this.Revision != nil && that1.Revision != nil {
		if *this.Revision != *that1.Revision {
			return false
		}
	} else if this.Revision != nil {
		return false
	} else if that1.Revision != nil {
		return false
	}
	if this.Status != nil && that1.Status != nil {
		if *this.Status != *that1.Status {
			return false
		}
	} else if this.Status != nil {
		return false
	} else if that1.Status != nil {
		return false
	}
	if this.TaskDefinitionArn != nil && that1.TaskDefinitionArn != nil {
		if *this.TaskDefinitionArn != *that1.TaskDefinitionArn {
			return false
		}
	} else if this.TaskDefinitionArn != nil {
		return false
	} else if that1.TaskDefinitionArn != nil {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(that1.Volumes[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TaskOverride) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskOverride)
	if !ok {
		that2, ok := that.(TaskOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.ContainerOverrides) != len(that1.ContainerOverrides) {
		return false
	}
	for i := range this.ContainerOverrides {
		if !this.ContainerOverrides[i].Equal(that1.ContainerOverrides[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Ulimit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ulimit)
	if !ok {
		that2, ok := that.(Ulimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HardLimit != nil && that1.HardLimit != nil {
		if *this.HardLimit != *that1.HardLimit {
			return false
		}
	} else if this.HardLimit != nil {
		return false
	} else if that1.HardLimit != nil {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.SoftLimit != nil && that1.SoftLimit != nil {
		if *this.SoftLimit != *that1.SoftLimit {
			return false
		}
	} else if this.SoftLimit != nil {
		return false
	} else if that1.SoftLimit != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VersionInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VersionInfo)
	if !ok {
		that2, ok := that.(VersionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.AgentHash != nil && that1.AgentHash != nil {
		if *this.AgentHash != *that1.AgentHash {
			return false
		}
	} else if this.AgentHash != nil {
		return false
	} else if that1.AgentHash != nil {
		return false
	}
	if this.AgentVersion != nil && that1.AgentVersion != nil {
		if *this.AgentVersion != *that1.AgentVersion {
			return false
		}
	} else if this.AgentVersion != nil {
		return false
	} else if that1.AgentVersion != nil {
		return false
	}
	if this.DockerVersion != nil && that1.DockerVersion != nil {
		if *this.DockerVersion != *that1.DockerVersion {
			return false
		}
	} else if this.DockerVersion != nil {
		return false
	} else if that1.DockerVersion != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Volume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Host.Equal(that1.Host) {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *VolumeFrom) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VolumeFrom)
	if !ok {
		that2, ok := that.(VolumeFrom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ReadOnly != nil && that1.ReadOnly != nil {
		if *this.ReadOnly != *that1.ReadOnly {
			return false
		}
	} else if this.ReadOnly != nil {
		return false
	} else if that1.ReadOnly != nil {
		return false
	}
	if this.SourceContainer != nil && that1.SourceContainer != nil {
		if *this.SourceContainer != *that1.SourceContainer {
			return false
		}
	} else if this.SourceContainer != nil {
		return false
	} else if that1.SourceContainer != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

type AttributeGetter interface {
	GetAttribute() *Attribute
}

var GraphQLAttributeType *github_com_graphql_go_graphql.Object

type ContainerGetter interface {
	GetContainer() *Container
}

var GraphQLContainerType *github_com_graphql_go_graphql.Object

type ContainerDefinitionGetter interface {
	GetContainerDefinition() *ContainerDefinition
}

var GraphQLContainerDefinitionType *github_com_graphql_go_graphql.Object
var GraphQLContainerDefinition_DockerLabelsEntryType = github_com_opsee_protobuf_plugin_graphql_scalars.Map

type ContainerInstanceGetter interface {
	GetContainerInstance() *ContainerInstance
}

var GraphQLContainerInstanceType *github_com_graphql_go_graphql.Object

type ContainerOverrideGetter interface {
	GetContainerOverride() *ContainerOverride
}

var GraphQLContainerOverrideType *github_com_graphql_go_graphql.Object

type DeploymentGetter interface {
	GetDeployment() *Deployment
}

var GraphQLDeploymentType *github_com_graphql_go_graphql.Object

type DeploymentConfigurationGetter interface {
	GetDeploymentConfiguration() *DeploymentConfiguration
}

var GraphQLDeploymentConfigurationType *github_com_graphql_go_graphql.Object

type DescribeContainerInstancesInputGetter interface {
	GetDescribeContainerInstancesInput() *DescribeContainerInstancesInput
}

var GraphQLDescribeContainerInstancesInputType *github_com_graphql_go_graphql.Object

type DescribeContainerInstancesOutputGetter interface {
	GetDescribeContainerInstancesOutput() *DescribeContainerInstancesOutput
}

var GraphQLDescribeContainerInstancesOutputType *github_com_graphql_go_graphql.Object

type DescribeServicesInputGetter interface {
	GetDescribeServicesInput() *DescribeServicesInput
}

var GraphQLDescribeServicesInputType *github_com_graphql_go_graphql.Object

type DescribeServicesOutputGetter interface {
	GetDescribeServicesOutput() *DescribeServicesOutput
}

var GraphQLDescribeServicesOutputType *github_com_graphql_go_graphql.Object

type DescribeTaskDefinitionInputGetter interface {
	GetDescribeTaskDefinitionInput() *DescribeTaskDefinitionInput
}

var GraphQLDescribeTaskDefinitionInputType *github_com_graphql_go_graphql.Object

type DescribeTaskDefinitionOutputGetter interface {
	GetDescribeTaskDefinitionOutput() *DescribeTaskDefinitionOutput
}

var GraphQLDescribeTaskDefinitionOutputType *github_com_graphql_go_graphql.Object

type DescribeTasksInputGetter interface {
	GetDescribeTasksInput() *DescribeTasksInput
}

var GraphQLDescribeTasksInputType *github_com_graphql_go_graphql.Object

type DescribeTasksOutputGetter interface {
	GetDescribeTasksOutput() *DescribeTasksOutput
}

var GraphQLDescribeTasksOutputType *github_com_graphql_go_graphql.Object

type FailureGetter interface {
	GetFailure() *Failure
}

var GraphQLFailureType *github_com_graphql_go_graphql.Object

type HostEntryGetter interface {
	GetHostEntry() *HostEntry
}

var GraphQLHostEntryType *github_com_graphql_go_graphql.Object

type HostVolumePropertiesGetter interface {
	GetHostVolumeProperties() *HostVolumeProperties
}

var GraphQLHostVolumePropertiesType *github_com_graphql_go_graphql.Object

type KeyValuePairGetter interface {
	GetKeyValuePair() *KeyValuePair
}

var GraphQLKeyValuePairType *github_com_graphql_go_graphql.Object

type ListClustersInputGetter interface {
	GetListClustersInput() *ListClustersInput
}

var GraphQLListClustersInputType *github_com_graphql_go_graphql.Object

type ListClustersOutputGetter interface {
	GetListClustersOutput() *ListClustersOutput
}

var GraphQLListClustersOutputType *github_com_graphql_go_graphql.Object

type ListContainerInstancesInputGetter interface {
	GetListContainerInstancesInput() *ListContainerInstancesInput
}

var GraphQLListContainerInstancesInputType *github_com_graphql_go_graphql.Object

type ListContainerInstancesOutputGetter interface {
	GetListContainerInstancesOutput() *ListContainerInstancesOutput
}

var GraphQLListContainerInstancesOutputType *github_com_graphql_go_graphql.Object

type ListServicesInputGetter interface {
	GetListServicesInput() *ListServicesInput
}

var GraphQLListServicesInputType *github_com_graphql_go_graphql.Object

type ListServicesOutputGetter interface {
	GetListServicesOutput() *ListServicesOutput
}

var GraphQLListServicesOutputType *github_com_graphql_go_graphql.Object

type ListTasksInputGetter interface {
	GetListTasksInput() *ListTasksInput
}

var GraphQLListTasksInputType *github_com_graphql_go_graphql.Object

type ListTasksOutputGetter interface {
	GetListTasksOutput() *ListTasksOutput
}

var GraphQLListTasksOutputType *github_com_graphql_go_graphql.Object

type LoadBalancerGetter interface {
	GetLoadBalancer() *LoadBalancer
}

var GraphQLLoadBalancerType *github_com_graphql_go_graphql.Object

type LogConfigurationGetter interface {
	GetLogConfiguration() *LogConfiguration
}

var GraphQLLogConfigurationType *github_com_graphql_go_graphql.Object
var GraphQLLogConfiguration_OptionsEntryType = github_com_opsee_protobuf_plugin_graphql_scalars.Map

type MountPointGetter interface {
	GetMountPoint() *MountPoint
}

var GraphQLMountPointType *github_com_graphql_go_graphql.Object

type NetworkBindingGetter interface {
	GetNetworkBinding() *NetworkBinding
}

var GraphQLNetworkBindingType *github_com_graphql_go_graphql.Object

type PortMappingGetter interface {
	GetPortMapping() *PortMapping
}

var GraphQLPortMappingType *github_com_graphql_go_graphql.Object

type ResourceGetter interface {
	GetResource() *Resource
}

var GraphQLResourceType *github_com_graphql_go_graphql.Object

type ServiceGetter interface {
	GetService() *Service
}

var GraphQLServiceType *github_com_graphql_go_graphql.Object

type ServiceEventGetter interface {
	GetServiceEvent() *ServiceEvent
}

var GraphQLServiceEventType *github_com_graphql_go_graphql.Object

type TaskGetter interface {
	GetTask() *Task
}

var GraphQLTaskType *github_com_graphql_go_graphql.Object

type TaskDefinitionGetter interface {
	GetTaskDefinition() *TaskDefinition
}

var GraphQLTaskDefinitionType *github_com_graphql_go_graphql.Object

type TaskOverrideGetter interface {
	GetTaskOverride() *TaskOverride
}

var GraphQLTaskOverrideType *github_com_graphql_go_graphql.Object

type UlimitGetter interface {
	GetUlimit() *Ulimit
}

var GraphQLUlimitType *github_com_graphql_go_graphql.Object

type VersionInfoGetter interface {
	GetVersionInfo() *VersionInfo
}

var GraphQLVersionInfoType *github_com_graphql_go_graphql.Object

type VolumeGetter interface {
	GetVolume() *Volume
}

var GraphQLVolumeType *github_com_graphql_go_graphql.Object

type VolumeFromGetter interface {
	GetVolumeFrom() *VolumeFrom
}

var GraphQLVolumeFromType *github_com_graphql_go_graphql.Object

func init() {
	GraphQLAttributeType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsAttribute",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Attribute)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(AttributeGetter)
						if ok {
							face := inter.GetAttribute()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"Value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Attribute)
						if ok {
							if obj.Value == nil {
								return nil, nil
							}
							return obj.GetValue(), nil
						}
						inter, ok := p.Source.(AttributeGetter)
						if ok {
							face := inter.GetAttribute()
							if face == nil {
								return nil, nil
							}
							if face.Value == nil {
								return nil, nil
							}
							return face.GetValue(), nil
						}
						return nil, fmt.Errorf("field Value not resolved")
					},
				},
			}
		}),
	})
	GraphQLContainerType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsContainer",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.ContainerArn == nil {
								return nil, nil
							}
							return obj.GetContainerArn(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.ContainerArn == nil {
								return nil, nil
							}
							return face.GetContainerArn(), nil
						}
						return nil, fmt.Errorf("field ContainerArn not resolved")
					},
				},
				"ExitCode": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.ExitCode == nil {
								return nil, nil
							}
							return obj.GetExitCode(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.ExitCode == nil {
								return nil, nil
							}
							return face.GetExitCode(), nil
						}
						return nil, fmt.Errorf("field ExitCode not resolved")
					},
				},
				"LastStatus": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.LastStatus == nil {
								return nil, nil
							}
							return obj.GetLastStatus(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.LastStatus == nil {
								return nil, nil
							}
							return face.GetLastStatus(), nil
						}
						return nil, fmt.Errorf("field LastStatus not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"NetworkBindings": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLNetworkBindingType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							return obj.NetworkBindings, nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							return face.NetworkBindings, nil
						}
						return nil, fmt.Errorf("field NetworkBindings not resolved")
					},
				},
				"Reason": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.Reason == nil {
								return nil, nil
							}
							return obj.GetReason(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.Reason == nil {
								return nil, nil
							}
							return face.GetReason(), nil
						}
						return nil, fmt.Errorf("field Reason not resolved")
					},
				},
				"TaskArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Container)
						if ok {
							if obj.TaskArn == nil {
								return nil, nil
							}
							return obj.GetTaskArn(), nil
						}
						inter, ok := p.Source.(ContainerGetter)
						if ok {
							face := inter.GetContainer()
							if face == nil {
								return nil, nil
							}
							if face.TaskArn == nil {
								return nil, nil
							}
							return face.GetTaskArn(), nil
						}
						return nil, fmt.Errorf("field TaskArn not resolved")
					},
				},
			}
		}),
	})
	GraphQLContainerDefinitionType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsContainerDefinition",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Command": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.Command, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.Command, nil
						}
						return nil, fmt.Errorf("field Command not resolved")
					},
				},
				"Cpu": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Cpu == nil {
								return nil, nil
							}
							return obj.GetCpu(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Cpu == nil {
								return nil, nil
							}
							return face.GetCpu(), nil
						}
						return nil, fmt.Errorf("field Cpu not resolved")
					},
				},
				"DisableNetworking": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.DisableNetworking == nil {
								return nil, nil
							}
							return obj.GetDisableNetworking(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.DisableNetworking == nil {
								return nil, nil
							}
							return face.GetDisableNetworking(), nil
						}
						return nil, fmt.Errorf("field DisableNetworking not resolved")
					},
				},
				"DnsSearchDomains": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.DnsSearchDomains, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.DnsSearchDomains, nil
						}
						return nil, fmt.Errorf("field DnsSearchDomains not resolved")
					},
				},
				"DnsServers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.DnsServers, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.DnsServers, nil
						}
						return nil, fmt.Errorf("field DnsServers not resolved")
					},
				},
				"DockerLabels": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLContainerDefinition_DockerLabelsEntryType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.DockerLabels, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.DockerLabels, nil
						}
						return nil, fmt.Errorf("field DockerLabels not resolved")
					},
				},
				"DockerSecurityOptions": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.DockerSecurityOptions, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.DockerSecurityOptions, nil
						}
						return nil, fmt.Errorf("field DockerSecurityOptions not resolved")
					},
				},
				"EntryPoint": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.EntryPoint, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.EntryPoint, nil
						}
						return nil, fmt.Errorf("field EntryPoint not resolved")
					},
				},
				"Environment": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLKeyValuePairType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.Environment, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.Environment, nil
						}
						return nil, fmt.Errorf("field Environment not resolved")
					},
				},
				"Essential": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Essential == nil {
								return nil, nil
							}
							return obj.GetEssential(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Essential == nil {
								return nil, nil
							}
							return face.GetEssential(), nil
						}
						return nil, fmt.Errorf("field Essential not resolved")
					},
				},
				"ExtraHosts": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLHostEntryType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.ExtraHosts, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.ExtraHosts, nil
						}
						return nil, fmt.Errorf("field ExtraHosts not resolved")
					},
				},
				"Hostname": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Hostname == nil {
								return nil, nil
							}
							return obj.GetHostname(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Hostname == nil {
								return nil, nil
							}
							return face.GetHostname(), nil
						}
						return nil, fmt.Errorf("field Hostname not resolved")
					},
				},
				"Image": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Image == nil {
								return nil, nil
							}
							return obj.GetImage(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Image == nil {
								return nil, nil
							}
							return face.GetImage(), nil
						}
						return nil, fmt.Errorf("field Image not resolved")
					},
				},
				"Links": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.Links, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.Links, nil
						}
						return nil, fmt.Errorf("field Links not resolved")
					},
				},
				"LogConfiguration": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLogConfigurationType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.LogConfiguration == nil {
								return nil, nil
							}
							return obj.GetLogConfiguration(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.LogConfiguration == nil {
								return nil, nil
							}
							return face.GetLogConfiguration(), nil
						}
						return nil, fmt.Errorf("field LogConfiguration not resolved")
					},
				},
				"Memory": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Memory == nil {
								return nil, nil
							}
							return obj.GetMemory(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Memory == nil {
								return nil, nil
							}
							return face.GetMemory(), nil
						}
						return nil, fmt.Errorf("field Memory not resolved")
					},
				},
				"MountPoints": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLMountPointType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.MountPoints, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.MountPoints, nil
						}
						return nil, fmt.Errorf("field MountPoints not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"PortMappings": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLPortMappingType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.PortMappings, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.PortMappings, nil
						}
						return nil, fmt.Errorf("field PortMappings not resolved")
					},
				},
				"Privileged": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.Privileged == nil {
								return nil, nil
							}
							return obj.GetPrivileged(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Privileged == nil {
								return nil, nil
							}
							return face.GetPrivileged(), nil
						}
						return nil, fmt.Errorf("field Privileged not resolved")
					},
				},
				"ReadonlyRootFilesystem": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.ReadonlyRootFilesystem == nil {
								return nil, nil
							}
							return obj.GetReadonlyRootFilesystem(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.ReadonlyRootFilesystem == nil {
								return nil, nil
							}
							return face.GetReadonlyRootFilesystem(), nil
						}
						return nil, fmt.Errorf("field ReadonlyRootFilesystem not resolved")
					},
				},
				"Ulimits": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLUlimitType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.Ulimits, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.Ulimits, nil
						}
						return nil, fmt.Errorf("field Ulimits not resolved")
					},
				},
				"User": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.User == nil {
								return nil, nil
							}
							return obj.GetUser(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.User == nil {
								return nil, nil
							}
							return face.GetUser(), nil
						}
						return nil, fmt.Errorf("field User not resolved")
					},
				},
				"VolumesFrom": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLVolumeFromType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							return obj.VolumesFrom, nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							return face.VolumesFrom, nil
						}
						return nil, fmt.Errorf("field VolumesFrom not resolved")
					},
				},
				"WorkingDirectory": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerDefinition)
						if ok {
							if obj.WorkingDirectory == nil {
								return nil, nil
							}
							return obj.GetWorkingDirectory(), nil
						}
						inter, ok := p.Source.(ContainerDefinitionGetter)
						if ok {
							face := inter.GetContainerDefinition()
							if face == nil {
								return nil, nil
							}
							if face.WorkingDirectory == nil {
								return nil, nil
							}
							return face.GetWorkingDirectory(), nil
						}
						return nil, fmt.Errorf("field WorkingDirectory not resolved")
					},
				},
			}
		}),
	})
	GraphQLContainerInstanceType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsContainerInstance",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"AgentConnected": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.AgentConnected == nil {
								return nil, nil
							}
							return obj.GetAgentConnected(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.AgentConnected == nil {
								return nil, nil
							}
							return face.GetAgentConnected(), nil
						}
						return nil, fmt.Errorf("field AgentConnected not resolved")
					},
				},
				"AgentUpdateStatus": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.AgentUpdateStatus == nil {
								return nil, nil
							}
							return obj.GetAgentUpdateStatus(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.AgentUpdateStatus == nil {
								return nil, nil
							}
							return face.GetAgentUpdateStatus(), nil
						}
						return nil, fmt.Errorf("field AgentUpdateStatus not resolved")
					},
				},
				"Attributes": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLAttributeType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							return obj.Attributes, nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							return face.Attributes, nil
						}
						return nil, fmt.Errorf("field Attributes not resolved")
					},
				},
				"ContainerInstanceArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.ContainerInstanceArn == nil {
								return nil, nil
							}
							return obj.GetContainerInstanceArn(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.ContainerInstanceArn == nil {
								return nil, nil
							}
							return face.GetContainerInstanceArn(), nil
						}
						return nil, fmt.Errorf("field ContainerInstanceArn not resolved")
					},
				},
				"Ec2InstanceId": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.Ec2InstanceId == nil {
								return nil, nil
							}
							return obj.GetEc2InstanceId(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.Ec2InstanceId == nil {
								return nil, nil
							}
							return face.GetEc2InstanceId(), nil
						}
						return nil, fmt.Errorf("field Ec2InstanceId not resolved")
					},
				},
				"PendingTasksCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.PendingTasksCount == nil {
								return nil, nil
							}
							return obj.GetPendingTasksCount(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.PendingTasksCount == nil {
								return nil, nil
							}
							return face.GetPendingTasksCount(), nil
						}
						return nil, fmt.Errorf("field PendingTasksCount not resolved")
					},
				},
				"RegisteredResources": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLResourceType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							return obj.RegisteredResources, nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							return face.RegisteredResources, nil
						}
						return nil, fmt.Errorf("field RegisteredResources not resolved")
					},
				},
				"RemainingResources": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLResourceType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							return obj.RemainingResources, nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							return face.RemainingResources, nil
						}
						return nil, fmt.Errorf("field RemainingResources not resolved")
					},
				},
				"RunningTasksCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.RunningTasksCount == nil {
								return nil, nil
							}
							return obj.GetRunningTasksCount(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.RunningTasksCount == nil {
								return nil, nil
							}
							return face.GetRunningTasksCount(), nil
						}
						return nil, fmt.Errorf("field RunningTasksCount not resolved")
					},
				},
				"Status": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.Status == nil {
								return nil, nil
							}
							return obj.GetStatus(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.Status == nil {
								return nil, nil
							}
							return face.GetStatus(), nil
						}
						return nil, fmt.Errorf("field Status not resolved")
					},
				},
				"VersionInfo": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLVersionInfoType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerInstance)
						if ok {
							if obj.VersionInfo == nil {
								return nil, nil
							}
							return obj.GetVersionInfo(), nil
						}
						inter, ok := p.Source.(ContainerInstanceGetter)
						if ok {
							face := inter.GetContainerInstance()
							if face == nil {
								return nil, nil
							}
							if face.VersionInfo == nil {
								return nil, nil
							}
							return face.GetVersionInfo(), nil
						}
						return nil, fmt.Errorf("field VersionInfo not resolved")
					},
				},
			}
		}),
	})
	GraphQLContainerOverrideType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsContainerOverride",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Command": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerOverride)
						if ok {
							return obj.Command, nil
						}
						inter, ok := p.Source.(ContainerOverrideGetter)
						if ok {
							face := inter.GetContainerOverride()
							if face == nil {
								return nil, nil
							}
							return face.Command, nil
						}
						return nil, fmt.Errorf("field Command not resolved")
					},
				},
				"Environment": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLKeyValuePairType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerOverride)
						if ok {
							return obj.Environment, nil
						}
						inter, ok := p.Source.(ContainerOverrideGetter)
						if ok {
							face := inter.GetContainerOverride()
							if face == nil {
								return nil, nil
							}
							return face.Environment, nil
						}
						return nil, fmt.Errorf("field Environment not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ContainerOverride)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(ContainerOverrideGetter)
						if ok {
							face := inter.GetContainerOverride()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
			}
		}),
	})
	GraphQLDeploymentType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDeployment",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"CreatedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field CreatedAt not resolved")
					},
				},
				"DesiredCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.DesiredCount == nil {
								return nil, nil
							}
							return obj.GetDesiredCount(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.DesiredCount == nil {
								return nil, nil
							}
							return face.GetDesiredCount(), nil
						}
						return nil, fmt.Errorf("field DesiredCount not resolved")
					},
				},
				"Id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.Id == nil {
								return nil, nil
							}
							return obj.GetId(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.Id == nil {
								return nil, nil
							}
							return face.GetId(), nil
						}
						return nil, fmt.Errorf("field Id not resolved")
					},
				},
				"PendingCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.PendingCount == nil {
								return nil, nil
							}
							return obj.GetPendingCount(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.PendingCount == nil {
								return nil, nil
							}
							return face.GetPendingCount(), nil
						}
						return nil, fmt.Errorf("field PendingCount not resolved")
					},
				},
				"RunningCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.RunningCount == nil {
								return nil, nil
							}
							return obj.GetRunningCount(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.RunningCount == nil {
								return nil, nil
							}
							return face.GetRunningCount(), nil
						}
						return nil, fmt.Errorf("field RunningCount not resolved")
					},
				},
				"Status": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.Status == nil {
								return nil, nil
							}
							return obj.GetStatus(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.Status == nil {
								return nil, nil
							}
							return face.GetStatus(), nil
						}
						return nil, fmt.Errorf("field Status not resolved")
					},
				},
				"TaskDefinition": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.TaskDefinition == nil {
								return nil, nil
							}
							return obj.GetTaskDefinition(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinition == nil {
								return nil, nil
							}
							return face.GetTaskDefinition(), nil
						}
						return nil, fmt.Errorf("field TaskDefinition not resolved")
					},
				},
				"UpdatedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Deployment)
						if ok {
							if obj.UpdatedAt == nil {
								return nil, nil
							}
							return obj.GetUpdatedAt(), nil
						}
						inter, ok := p.Source.(DeploymentGetter)
						if ok {
							face := inter.GetDeployment()
							if face == nil {
								return nil, nil
							}
							if face.UpdatedAt == nil {
								return nil, nil
							}
							return face.GetUpdatedAt(), nil
						}
						return nil, fmt.Errorf("field UpdatedAt not resolved")
					},
				},
			}
		}),
	})
	GraphQLDeploymentConfigurationType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDeploymentConfiguration",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"MaximumPercent": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DeploymentConfiguration)
						if ok {
							if obj.MaximumPercent == nil {
								return nil, nil
							}
							return obj.GetMaximumPercent(), nil
						}
						inter, ok := p.Source.(DeploymentConfigurationGetter)
						if ok {
							face := inter.GetDeploymentConfiguration()
							if face == nil {
								return nil, nil
							}
							if face.MaximumPercent == nil {
								return nil, nil
							}
							return face.GetMaximumPercent(), nil
						}
						return nil, fmt.Errorf("field MaximumPercent not resolved")
					},
				},
				"MinimumHealthyPercent": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DeploymentConfiguration)
						if ok {
							if obj.MinimumHealthyPercent == nil {
								return nil, nil
							}
							return obj.GetMinimumHealthyPercent(), nil
						}
						inter, ok := p.Source.(DeploymentConfigurationGetter)
						if ok {
							face := inter.GetDeploymentConfiguration()
							if face == nil {
								return nil, nil
							}
							if face.MinimumHealthyPercent == nil {
								return nil, nil
							}
							return face.GetMinimumHealthyPercent(), nil
						}
						return nil, fmt.Errorf("field MinimumHealthyPercent not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeContainerInstancesInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeContainerInstancesInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeContainerInstancesInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(DescribeContainerInstancesInputGetter)
						if ok {
							face := inter.GetDescribeContainerInstancesInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"ContainerInstances": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeContainerInstancesInput)
						if ok {
							return obj.ContainerInstances, nil
						}
						inter, ok := p.Source.(DescribeContainerInstancesInputGetter)
						if ok {
							face := inter.GetDescribeContainerInstancesInput()
							if face == nil {
								return nil, nil
							}
							return face.ContainerInstances, nil
						}
						return nil, fmt.Errorf("field ContainerInstances not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeContainerInstancesOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeContainerInstancesOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerInstances": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLContainerInstanceType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeContainerInstancesOutput)
						if ok {
							return obj.ContainerInstances, nil
						}
						inter, ok := p.Source.(DescribeContainerInstancesOutputGetter)
						if ok {
							face := inter.GetDescribeContainerInstancesOutput()
							if face == nil {
								return nil, nil
							}
							return face.ContainerInstances, nil
						}
						return nil, fmt.Errorf("field ContainerInstances not resolved")
					},
				},
				"Failures": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLFailureType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeContainerInstancesOutput)
						if ok {
							return obj.Failures, nil
						}
						inter, ok := p.Source.(DescribeContainerInstancesOutputGetter)
						if ok {
							face := inter.GetDescribeContainerInstancesOutput()
							if face == nil {
								return nil, nil
							}
							return face.Failures, nil
						}
						return nil, fmt.Errorf("field Failures not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeServicesInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeServicesInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeServicesInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(DescribeServicesInputGetter)
						if ok {
							face := inter.GetDescribeServicesInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"Services": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeServicesInput)
						if ok {
							return obj.Services, nil
						}
						inter, ok := p.Source.(DescribeServicesInputGetter)
						if ok {
							face := inter.GetDescribeServicesInput()
							if face == nil {
								return nil, nil
							}
							return face.Services, nil
						}
						return nil, fmt.Errorf("field Services not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeServicesOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeServicesOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Failures": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLFailureType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeServicesOutput)
						if ok {
							return obj.Failures, nil
						}
						inter, ok := p.Source.(DescribeServicesOutputGetter)
						if ok {
							face := inter.GetDescribeServicesOutput()
							if face == nil {
								return nil, nil
							}
							return face.Failures, nil
						}
						return nil, fmt.Errorf("field Failures not resolved")
					},
				},
				"Services": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLServiceType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeServicesOutput)
						if ok {
							return obj.Services, nil
						}
						inter, ok := p.Source.(DescribeServicesOutputGetter)
						if ok {
							face := inter.GetDescribeServicesOutput()
							if face == nil {
								return nil, nil
							}
							return face.Services, nil
						}
						return nil, fmt.Errorf("field Services not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeTaskDefinitionInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeTaskDefinitionInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"TaskDefinition": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTaskDefinitionInput)
						if ok {
							if obj.TaskDefinition == nil {
								return nil, nil
							}
							return obj.GetTaskDefinition(), nil
						}
						inter, ok := p.Source.(DescribeTaskDefinitionInputGetter)
						if ok {
							face := inter.GetDescribeTaskDefinitionInput()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinition == nil {
								return nil, nil
							}
							return face.GetTaskDefinition(), nil
						}
						return nil, fmt.Errorf("field TaskDefinition not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeTaskDefinitionOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeTaskDefinitionOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"TaskDefinition": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTaskDefinitionType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTaskDefinitionOutput)
						if ok {
							if obj.TaskDefinition == nil {
								return nil, nil
							}
							return obj.GetTaskDefinition(), nil
						}
						inter, ok := p.Source.(DescribeTaskDefinitionOutputGetter)
						if ok {
							face := inter.GetDescribeTaskDefinitionOutput()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinition == nil {
								return nil, nil
							}
							return face.GetTaskDefinition(), nil
						}
						return nil, fmt.Errorf("field TaskDefinition not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeTasksInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeTasksInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTasksInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(DescribeTasksInputGetter)
						if ok {
							face := inter.GetDescribeTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"Tasks": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTasksInput)
						if ok {
							return obj.Tasks, nil
						}
						inter, ok := p.Source.(DescribeTasksInputGetter)
						if ok {
							face := inter.GetDescribeTasksInput()
							if face == nil {
								return nil, nil
							}
							return face.Tasks, nil
						}
						return nil, fmt.Errorf("field Tasks not resolved")
					},
				},
			}
		}),
	})
	GraphQLDescribeTasksOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsDescribeTasksOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Failures": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLFailureType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTasksOutput)
						if ok {
							return obj.Failures, nil
						}
						inter, ok := p.Source.(DescribeTasksOutputGetter)
						if ok {
							face := inter.GetDescribeTasksOutput()
							if face == nil {
								return nil, nil
							}
							return face.Failures, nil
						}
						return nil, fmt.Errorf("field Failures not resolved")
					},
				},
				"Tasks": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLTaskType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*DescribeTasksOutput)
						if ok {
							return obj.Tasks, nil
						}
						inter, ok := p.Source.(DescribeTasksOutputGetter)
						if ok {
							face := inter.GetDescribeTasksOutput()
							if face == nil {
								return nil, nil
							}
							return face.Tasks, nil
						}
						return nil, fmt.Errorf("field Tasks not resolved")
					},
				},
			}
		}),
	})
	GraphQLFailureType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsFailure",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Arn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Failure)
						if ok {
							if obj.Arn == nil {
								return nil, nil
							}
							return obj.GetArn(), nil
						}
						inter, ok := p.Source.(FailureGetter)
						if ok {
							face := inter.GetFailure()
							if face == nil {
								return nil, nil
							}
							if face.Arn == nil {
								return nil, nil
							}
							return face.GetArn(), nil
						}
						return nil, fmt.Errorf("field Arn not resolved")
					},
				},
				"Reason": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Failure)
						if ok {
							if obj.Reason == nil {
								return nil, nil
							}
							return obj.GetReason(), nil
						}
						inter, ok := p.Source.(FailureGetter)
						if ok {
							face := inter.GetFailure()
							if face == nil {
								return nil, nil
							}
							if face.Reason == nil {
								return nil, nil
							}
							return face.GetReason(), nil
						}
						return nil, fmt.Errorf("field Reason not resolved")
					},
				},
			}
		}),
	})
	GraphQLHostEntryType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsHostEntry",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Hostname": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HostEntry)
						if ok {
							if obj.Hostname == nil {
								return nil, nil
							}
							return obj.GetHostname(), nil
						}
						inter, ok := p.Source.(HostEntryGetter)
						if ok {
							face := inter.GetHostEntry()
							if face == nil {
								return nil, nil
							}
							if face.Hostname == nil {
								return nil, nil
							}
							return face.GetHostname(), nil
						}
						return nil, fmt.Errorf("field Hostname not resolved")
					},
				},
				"IpAddress": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HostEntry)
						if ok {
							if obj.IpAddress == nil {
								return nil, nil
							}
							return obj.GetIpAddress(), nil
						}
						inter, ok := p.Source.(HostEntryGetter)
						if ok {
							face := inter.GetHostEntry()
							if face == nil {
								return nil, nil
							}
							if face.IpAddress == nil {
								return nil, nil
							}
							return face.GetIpAddress(), nil
						}
						return nil, fmt.Errorf("field IpAddress not resolved")
					},
				},
			}
		}),
	})
	GraphQLHostVolumePropertiesType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsHostVolumeProperties",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"SourcePath": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HostVolumeProperties)
						if ok {
							if obj.SourcePath == nil {
								return nil, nil
							}
							return obj.GetSourcePath(), nil
						}
						inter, ok := p.Source.(HostVolumePropertiesGetter)
						if ok {
							face := inter.GetHostVolumeProperties()
							if face == nil {
								return nil, nil
							}
							if face.SourcePath == nil {
								return nil, nil
							}
							return face.GetSourcePath(), nil
						}
						return nil, fmt.Errorf("field SourcePath not resolved")
					},
				},
			}
		}),
	})
	GraphQLKeyValuePairType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsKeyValuePair",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*KeyValuePair)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(KeyValuePairGetter)
						if ok {
							face := inter.GetKeyValuePair()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"Value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*KeyValuePair)
						if ok {
							if obj.Value == nil {
								return nil, nil
							}
							return obj.GetValue(), nil
						}
						inter, ok := p.Source.(KeyValuePairGetter)
						if ok {
							face := inter.GetKeyValuePair()
							if face == nil {
								return nil, nil
							}
							if face.Value == nil {
								return nil, nil
							}
							return face.GetValue(), nil
						}
						return nil, fmt.Errorf("field Value not resolved")
					},
				},
			}
		}),
	})
	GraphQLListClustersInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListClustersInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"MaxResults": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListClustersInput)
						if ok {
							if obj.MaxResults == nil {
								return nil, nil
							}
							return obj.GetMaxResults(), nil
						}
						inter, ok := p.Source.(ListClustersInputGetter)
						if ok {
							face := inter.GetListClustersInput()
							if face == nil {
								return nil, nil
							}
							if face.MaxResults == nil {
								return nil, nil
							}
							return face.GetMaxResults(), nil
						}
						return nil, fmt.Errorf("field MaxResults not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListClustersInput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListClustersInputGetter)
						if ok {
							face := inter.GetListClustersInput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
			}
		}),
	})
	GraphQLListClustersOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListClustersOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ClusterArns": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListClustersOutput)
						if ok {
							return obj.ClusterArns, nil
						}
						inter, ok := p.Source.(ListClustersOutputGetter)
						if ok {
							face := inter.GetListClustersOutput()
							if face == nil {
								return nil, nil
							}
							return face.ClusterArns, nil
						}
						return nil, fmt.Errorf("field ClusterArns not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListClustersOutput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListClustersOutputGetter)
						if ok {
							face := inter.GetListClustersOutput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
			}
		}),
	})
	GraphQLListContainerInstancesInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListContainerInstancesInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListContainerInstancesInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(ListContainerInstancesInputGetter)
						if ok {
							face := inter.GetListContainerInstancesInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"MaxResults": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListContainerInstancesInput)
						if ok {
							if obj.MaxResults == nil {
								return nil, nil
							}
							return obj.GetMaxResults(), nil
						}
						inter, ok := p.Source.(ListContainerInstancesInputGetter)
						if ok {
							face := inter.GetListContainerInstancesInput()
							if face == nil {
								return nil, nil
							}
							if face.MaxResults == nil {
								return nil, nil
							}
							return face.GetMaxResults(), nil
						}
						return nil, fmt.Errorf("field MaxResults not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListContainerInstancesInput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListContainerInstancesInputGetter)
						if ok {
							face := inter.GetListContainerInstancesInput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
			}
		}),
	})
	GraphQLListContainerInstancesOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListContainerInstancesOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerInstanceArns": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListContainerInstancesOutput)
						if ok {
							return obj.ContainerInstanceArns, nil
						}
						inter, ok := p.Source.(ListContainerInstancesOutputGetter)
						if ok {
							face := inter.GetListContainerInstancesOutput()
							if face == nil {
								return nil, nil
							}
							return face.ContainerInstanceArns, nil
						}
						return nil, fmt.Errorf("field ContainerInstanceArns not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListContainerInstancesOutput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListContainerInstancesOutputGetter)
						if ok {
							face := inter.GetListContainerInstancesOutput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
			}
		}),
	})
	GraphQLListServicesInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListServicesInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListServicesInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(ListServicesInputGetter)
						if ok {
							face := inter.GetListServicesInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"MaxResults": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListServicesInput)
						if ok {
							if obj.MaxResults == nil {
								return nil, nil
							}
							return obj.GetMaxResults(), nil
						}
						inter, ok := p.Source.(ListServicesInputGetter)
						if ok {
							face := inter.GetListServicesInput()
							if face == nil {
								return nil, nil
							}
							if face.MaxResults == nil {
								return nil, nil
							}
							return face.GetMaxResults(), nil
						}
						return nil, fmt.Errorf("field MaxResults not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListServicesInput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListServicesInputGetter)
						if ok {
							face := inter.GetListServicesInput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
			}
		}),
	})
	GraphQLListServicesOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListServicesOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListServicesOutput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListServicesOutputGetter)
						if ok {
							face := inter.GetListServicesOutput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
				"ServiceArns": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListServicesOutput)
						if ok {
							return obj.ServiceArns, nil
						}
						inter, ok := p.Source.(ListServicesOutputGetter)
						if ok {
							face := inter.GetListServicesOutput()
							if face == nil {
								return nil, nil
							}
							return face.ServiceArns, nil
						}
						return nil, fmt.Errorf("field ServiceArns not resolved")
					},
				},
			}
		}),
	})
	GraphQLListTasksInputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListTasksInput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Cluster": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.Cluster == nil {
								return nil, nil
							}
							return obj.GetCluster(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.Cluster == nil {
								return nil, nil
							}
							return face.GetCluster(), nil
						}
						return nil, fmt.Errorf("field Cluster not resolved")
					},
				},
				"ContainerInstance": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.ContainerInstance == nil {
								return nil, nil
							}
							return obj.GetContainerInstance(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.ContainerInstance == nil {
								return nil, nil
							}
							return face.GetContainerInstance(), nil
						}
						return nil, fmt.Errorf("field ContainerInstance not resolved")
					},
				},
				"DesiredStatus": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.DesiredStatus == nil {
								return nil, nil
							}
							return obj.GetDesiredStatus(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.DesiredStatus == nil {
								return nil, nil
							}
							return face.GetDesiredStatus(), nil
						}
						return nil, fmt.Errorf("field DesiredStatus not resolved")
					},
				},
				"Family": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.Family == nil {
								return nil, nil
							}
							return obj.GetFamily(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.Family == nil {
								return nil, nil
							}
							return face.GetFamily(), nil
						}
						return nil, fmt.Errorf("field Family not resolved")
					},
				},
				"MaxResults": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.MaxResults == nil {
								return nil, nil
							}
							return obj.GetMaxResults(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.MaxResults == nil {
								return nil, nil
							}
							return face.GetMaxResults(), nil
						}
						return nil, fmt.Errorf("field MaxResults not resolved")
					},
				},
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
				"ServiceName": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.ServiceName == nil {
								return nil, nil
							}
							return obj.GetServiceName(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.ServiceName == nil {
								return nil, nil
							}
							return face.GetServiceName(), nil
						}
						return nil, fmt.Errorf("field ServiceName not resolved")
					},
				},
				"StartedBy": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksInput)
						if ok {
							if obj.StartedBy == nil {
								return nil, nil
							}
							return obj.GetStartedBy(), nil
						}
						inter, ok := p.Source.(ListTasksInputGetter)
						if ok {
							face := inter.GetListTasksInput()
							if face == nil {
								return nil, nil
							}
							if face.StartedBy == nil {
								return nil, nil
							}
							return face.GetStartedBy(), nil
						}
						return nil, fmt.Errorf("field StartedBy not resolved")
					},
				},
			}
		}),
	})
	GraphQLListTasksOutputType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsListTasksOutput",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"NextToken": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksOutput)
						if ok {
							if obj.NextToken == nil {
								return nil, nil
							}
							return obj.GetNextToken(), nil
						}
						inter, ok := p.Source.(ListTasksOutputGetter)
						if ok {
							face := inter.GetListTasksOutput()
							if face == nil {
								return nil, nil
							}
							if face.NextToken == nil {
								return nil, nil
							}
							return face.GetNextToken(), nil
						}
						return nil, fmt.Errorf("field NextToken not resolved")
					},
				},
				"TaskArns": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ListTasksOutput)
						if ok {
							return obj.TaskArns, nil
						}
						inter, ok := p.Source.(ListTasksOutputGetter)
						if ok {
							face := inter.GetListTasksOutput()
							if face == nil {
								return nil, nil
							}
							return face.TaskArns, nil
						}
						return nil, fmt.Errorf("field TaskArns not resolved")
					},
				},
			}
		}),
	})
	GraphQLLoadBalancerType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsLoadBalancer",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerName": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LoadBalancer)
						if ok {
							if obj.ContainerName == nil {
								return nil, nil
							}
							return obj.GetContainerName(), nil
						}
						inter, ok := p.Source.(LoadBalancerGetter)
						if ok {
							face := inter.GetLoadBalancer()
							if face == nil {
								return nil, nil
							}
							if face.ContainerName == nil {
								return nil, nil
							}
							return face.GetContainerName(), nil
						}
						return nil, fmt.Errorf("field ContainerName not resolved")
					},
				},
				"ContainerPort": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LoadBalancer)
						if ok {
							if obj.ContainerPort == nil {
								return nil, nil
							}
							return obj.GetContainerPort(), nil
						}
						inter, ok := p.Source.(LoadBalancerGetter)
						if ok {
							face := inter.GetLoadBalancer()
							if face == nil {
								return nil, nil
							}
							if face.ContainerPort == nil {
								return nil, nil
							}
							return face.GetContainerPort(), nil
						}
						return nil, fmt.Errorf("field ContainerPort not resolved")
					},
				},
				"LoadBalancerName": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LoadBalancer)
						if ok {
							if obj.LoadBalancerName == nil {
								return nil, nil
							}
							return obj.GetLoadBalancerName(), nil
						}
						inter, ok := p.Source.(LoadBalancerGetter)
						if ok {
							face := inter.GetLoadBalancer()
							if face == nil {
								return nil, nil
							}
							if face.LoadBalancerName == nil {
								return nil, nil
							}
							return face.GetLoadBalancerName(), nil
						}
						return nil, fmt.Errorf("field LoadBalancerName not resolved")
					},
				},
			}
		}),
	})
	GraphQLLogConfigurationType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsLogConfiguration",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"LogDriver": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LogConfiguration)
						if ok {
							if obj.LogDriver == nil {
								return nil, nil
							}
							return obj.GetLogDriver(), nil
						}
						inter, ok := p.Source.(LogConfigurationGetter)
						if ok {
							face := inter.GetLogConfiguration()
							if face == nil {
								return nil, nil
							}
							if face.LogDriver == nil {
								return nil, nil
							}
							return face.GetLogDriver(), nil
						}
						return nil, fmt.Errorf("field LogDriver not resolved")
					},
				},
				"Options": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLogConfiguration_OptionsEntryType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LogConfiguration)
						if ok {
							return obj.Options, nil
						}
						inter, ok := p.Source.(LogConfigurationGetter)
						if ok {
							face := inter.GetLogConfiguration()
							if face == nil {
								return nil, nil
							}
							return face.Options, nil
						}
						return nil, fmt.Errorf("field Options not resolved")
					},
				},
			}
		}),
	})
	GraphQLMountPointType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsMountPoint",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerPath": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*MountPoint)
						if ok {
							if obj.ContainerPath == nil {
								return nil, nil
							}
							return obj.GetContainerPath(), nil
						}
						inter, ok := p.Source.(MountPointGetter)
						if ok {
							face := inter.GetMountPoint()
							if face == nil {
								return nil, nil
							}
							if face.ContainerPath == nil {
								return nil, nil
							}
							return face.GetContainerPath(), nil
						}
						return nil, fmt.Errorf("field ContainerPath not resolved")
					},
				},
				"ReadOnly": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*MountPoint)
						if ok {
							if obj.ReadOnly == nil {
								return nil, nil
							}
							return obj.GetReadOnly(), nil
						}
						inter, ok := p.Source.(MountPointGetter)
						if ok {
							face := inter.GetMountPoint()
							if face == nil {
								return nil, nil
							}
							if face.ReadOnly == nil {
								return nil, nil
							}
							return face.GetReadOnly(), nil
						}
						return nil, fmt.Errorf("field ReadOnly not resolved")
					},
				},
				"SourceVolume": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*MountPoint)
						if ok {
							if obj.SourceVolume == nil {
								return nil, nil
							}
							return obj.GetSourceVolume(), nil
						}
						inter, ok := p.Source.(MountPointGetter)
						if ok {
							face := inter.GetMountPoint()
							if face == nil {
								return nil, nil
							}
							if face.SourceVolume == nil {
								return nil, nil
							}
							return face.GetSourceVolume(), nil
						}
						return nil, fmt.Errorf("field SourceVolume not resolved")
					},
				},
			}
		}),
	})
	GraphQLNetworkBindingType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsNetworkBinding",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"BindIP": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*NetworkBinding)
						if ok {
							if obj.BindIP == nil {
								return nil, nil
							}
							return obj.GetBindIP(), nil
						}
						inter, ok := p.Source.(NetworkBindingGetter)
						if ok {
							face := inter.GetNetworkBinding()
							if face == nil {
								return nil, nil
							}
							if face.BindIP == nil {
								return nil, nil
							}
							return face.GetBindIP(), nil
						}
						return nil, fmt.Errorf("field BindIP not resolved")
					},
				},
				"ContainerPort": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*NetworkBinding)
						if ok {
							if obj.ContainerPort == nil {
								return nil, nil
							}
							return obj.GetContainerPort(), nil
						}
						inter, ok := p.Source.(NetworkBindingGetter)
						if ok {
							face := inter.GetNetworkBinding()
							if face == nil {
								return nil, nil
							}
							if face.ContainerPort == nil {
								return nil, nil
							}
							return face.GetContainerPort(), nil
						}
						return nil, fmt.Errorf("field ContainerPort not resolved")
					},
				},
				"HostPort": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*NetworkBinding)
						if ok {
							if obj.HostPort == nil {
								return nil, nil
							}
							return obj.GetHostPort(), nil
						}
						inter, ok := p.Source.(NetworkBindingGetter)
						if ok {
							face := inter.GetNetworkBinding()
							if face == nil {
								return nil, nil
							}
							if face.HostPort == nil {
								return nil, nil
							}
							return face.GetHostPort(), nil
						}
						return nil, fmt.Errorf("field HostPort not resolved")
					},
				},
				"Protocol": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*NetworkBinding)
						if ok {
							if obj.Protocol == nil {
								return nil, nil
							}
							return obj.GetProtocol(), nil
						}
						inter, ok := p.Source.(NetworkBindingGetter)
						if ok {
							face := inter.GetNetworkBinding()
							if face == nil {
								return nil, nil
							}
							if face.Protocol == nil {
								return nil, nil
							}
							return face.GetProtocol(), nil
						}
						return nil, fmt.Errorf("field Protocol not resolved")
					},
				},
			}
		}),
	})
	GraphQLPortMappingType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsPortMapping",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerPort": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*PortMapping)
						if ok {
							if obj.ContainerPort == nil {
								return nil, nil
							}
							return obj.GetContainerPort(), nil
						}
						inter, ok := p.Source.(PortMappingGetter)
						if ok {
							face := inter.GetPortMapping()
							if face == nil {
								return nil, nil
							}
							if face.ContainerPort == nil {
								return nil, nil
							}
							return face.GetContainerPort(), nil
						}
						return nil, fmt.Errorf("field ContainerPort not resolved")
					},
				},
				"HostPort": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*PortMapping)
						if ok {
							if obj.HostPort == nil {
								return nil, nil
							}
							return obj.GetHostPort(), nil
						}
						inter, ok := p.Source.(PortMappingGetter)
						if ok {
							face := inter.GetPortMapping()
							if face == nil {
								return nil, nil
							}
							if face.HostPort == nil {
								return nil, nil
							}
							return face.GetHostPort(), nil
						}
						return nil, fmt.Errorf("field HostPort not resolved")
					},
				},
				"Protocol": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*PortMapping)
						if ok {
							if obj.Protocol == nil {
								return nil, nil
							}
							return obj.GetProtocol(), nil
						}
						inter, ok := p.Source.(PortMappingGetter)
						if ok {
							face := inter.GetPortMapping()
							if face == nil {
								return nil, nil
							}
							if face.Protocol == nil {
								return nil, nil
							}
							return face.GetProtocol(), nil
						}
						return nil, fmt.Errorf("field Protocol not resolved")
					},
				},
			}
		}),
	})
	GraphQLResourceType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsResource",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"DoubleValue": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Float,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							if obj.DoubleValue == nil {
								return nil, nil
							}
							return obj.GetDoubleValue(), nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							if face.DoubleValue == nil {
								return nil, nil
							}
							return face.GetDoubleValue(), nil
						}
						return nil, fmt.Errorf("field DoubleValue not resolved")
					},
				},
				"IntegerValue": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							if obj.IntegerValue == nil {
								return nil, nil
							}
							return obj.GetIntegerValue(), nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							if face.IntegerValue == nil {
								return nil, nil
							}
							return face.GetIntegerValue(), nil
						}
						return nil, fmt.Errorf("field IntegerValue not resolved")
					},
				},
				"LongValue": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							if obj.LongValue == nil {
								return nil, nil
							}
							return obj.GetLongValue(), nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							if face.LongValue == nil {
								return nil, nil
							}
							return face.GetLongValue(), nil
						}
						return nil, fmt.Errorf("field LongValue not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"StringSetValue": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							return obj.StringSetValue, nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							return face.StringSetValue, nil
						}
						return nil, fmt.Errorf("field StringSetValue not resolved")
					},
				},
				"Type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Resource)
						if ok {
							if obj.Type == nil {
								return nil, nil
							}
							return obj.GetType(), nil
						}
						inter, ok := p.Source.(ResourceGetter)
						if ok {
							face := inter.GetResource()
							if face == nil {
								return nil, nil
							}
							if face.Type == nil {
								return nil, nil
							}
							return face.GetType(), nil
						}
						return nil, fmt.Errorf("field Type not resolved")
					},
				},
			}
		}),
	})
	GraphQLServiceType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsService",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ClusterArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.ClusterArn == nil {
								return nil, nil
							}
							return obj.GetClusterArn(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.ClusterArn == nil {
								return nil, nil
							}
							return face.GetClusterArn(), nil
						}
						return nil, fmt.Errorf("field ClusterArn not resolved")
					},
				},
				"CreatedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field CreatedAt not resolved")
					},
				},
				"DeploymentConfiguration": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLDeploymentConfigurationType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.DeploymentConfiguration == nil {
								return nil, nil
							}
							return obj.GetDeploymentConfiguration(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.DeploymentConfiguration == nil {
								return nil, nil
							}
							return face.GetDeploymentConfiguration(), nil
						}
						return nil, fmt.Errorf("field DeploymentConfiguration not resolved")
					},
				},
				"Deployments": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLDeploymentType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							return obj.Deployments, nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							return face.Deployments, nil
						}
						return nil, fmt.Errorf("field Deployments not resolved")
					},
				},
				"DesiredCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.DesiredCount == nil {
								return nil, nil
							}
							return obj.GetDesiredCount(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.DesiredCount == nil {
								return nil, nil
							}
							return face.GetDesiredCount(), nil
						}
						return nil, fmt.Errorf("field DesiredCount not resolved")
					},
				},
				"Events": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLServiceEventType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							return obj.Events, nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							return face.Events, nil
						}
						return nil, fmt.Errorf("field Events not resolved")
					},
				},
				"LoadBalancers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLLoadBalancerType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							return obj.LoadBalancers, nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							return face.LoadBalancers, nil
						}
						return nil, fmt.Errorf("field LoadBalancers not resolved")
					},
				},
				"PendingCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.PendingCount == nil {
								return nil, nil
							}
							return obj.GetPendingCount(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.PendingCount == nil {
								return nil, nil
							}
							return face.GetPendingCount(), nil
						}
						return nil, fmt.Errorf("field PendingCount not resolved")
					},
				},
				"RoleArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.RoleArn == nil {
								return nil, nil
							}
							return obj.GetRoleArn(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.RoleArn == nil {
								return nil, nil
							}
							return face.GetRoleArn(), nil
						}
						return nil, fmt.Errorf("field RoleArn not resolved")
					},
				},
				"RunningCount": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.RunningCount == nil {
								return nil, nil
							}
							return obj.GetRunningCount(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.RunningCount == nil {
								return nil, nil
							}
							return face.GetRunningCount(), nil
						}
						return nil, fmt.Errorf("field RunningCount not resolved")
					},
				},
				"ServiceArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.ServiceArn == nil {
								return nil, nil
							}
							return obj.GetServiceArn(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.ServiceArn == nil {
								return nil, nil
							}
							return face.GetServiceArn(), nil
						}
						return nil, fmt.Errorf("field ServiceArn not resolved")
					},
				},
				"ServiceName": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.ServiceName == nil {
								return nil, nil
							}
							return obj.GetServiceName(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.ServiceName == nil {
								return nil, nil
							}
							return face.GetServiceName(), nil
						}
						return nil, fmt.Errorf("field ServiceName not resolved")
					},
				},
				"Status": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.Status == nil {
								return nil, nil
							}
							return obj.GetStatus(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.Status == nil {
								return nil, nil
							}
							return face.GetStatus(), nil
						}
						return nil, fmt.Errorf("field Status not resolved")
					},
				},
				"TaskDefinition": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Service)
						if ok {
							if obj.TaskDefinition == nil {
								return nil, nil
							}
							return obj.GetTaskDefinition(), nil
						}
						inter, ok := p.Source.(ServiceGetter)
						if ok {
							face := inter.GetService()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinition == nil {
								return nil, nil
							}
							return face.GetTaskDefinition(), nil
						}
						return nil, fmt.Errorf("field TaskDefinition not resolved")
					},
				},
			}
		}),
	})
	GraphQLServiceEventType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsServiceEvent",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"CreatedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ServiceEvent)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(ServiceEventGetter)
						if ok {
							face := inter.GetServiceEvent()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field CreatedAt not resolved")
					},
				},
				"Id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ServiceEvent)
						if ok {
							if obj.Id == nil {
								return nil, nil
							}
							return obj.GetId(), nil
						}
						inter, ok := p.Source.(ServiceEventGetter)
						if ok {
							face := inter.GetServiceEvent()
							if face == nil {
								return nil, nil
							}
							if face.Id == nil {
								return nil, nil
							}
							return face.GetId(), nil
						}
						return nil, fmt.Errorf("field Id not resolved")
					},
				},
				"Message": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*ServiceEvent)
						if ok {
							if obj.Message == nil {
								return nil, nil
							}
							return obj.GetMessage(), nil
						}
						inter, ok := p.Source.(ServiceEventGetter)
						if ok {
							face := inter.GetServiceEvent()
							if face == nil {
								return nil, nil
							}
							if face.Message == nil {
								return nil, nil
							}
							return face.GetMessage(), nil
						}
						return nil, fmt.Errorf("field Message not resolved")
					},
				},
			}
		}),
	})
	GraphQLTaskType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsTask",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ClusterArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.ClusterArn == nil {
								return nil, nil
							}
							return obj.GetClusterArn(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.ClusterArn == nil {
								return nil, nil
							}
							return face.GetClusterArn(), nil
						}
						return nil, fmt.Errorf("field ClusterArn not resolved")
					},
				},
				"ContainerInstanceArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.ContainerInstanceArn == nil {
								return nil, nil
							}
							return obj.GetContainerInstanceArn(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.ContainerInstanceArn == nil {
								return nil, nil
							}
							return face.GetContainerInstanceArn(), nil
						}
						return nil, fmt.Errorf("field ContainerInstanceArn not resolved")
					},
				},
				"Containers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLContainerType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							return obj.Containers, nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							return face.Containers, nil
						}
						return nil, fmt.Errorf("field Containers not resolved")
					},
				},
				"CreatedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field CreatedAt not resolved")
					},
				},
				"DesiredStatus": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.DesiredStatus == nil {
								return nil, nil
							}
							return obj.GetDesiredStatus(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.DesiredStatus == nil {
								return nil, nil
							}
							return face.GetDesiredStatus(), nil
						}
						return nil, fmt.Errorf("field DesiredStatus not resolved")
					},
				},
				"LastStatus": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.LastStatus == nil {
								return nil, nil
							}
							return obj.GetLastStatus(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.LastStatus == nil {
								return nil, nil
							}
							return face.GetLastStatus(), nil
						}
						return nil, fmt.Errorf("field LastStatus not resolved")
					},
				},
				"Overrides": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTaskOverrideType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.Overrides == nil {
								return nil, nil
							}
							return obj.GetOverrides(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.Overrides == nil {
								return nil, nil
							}
							return face.GetOverrides(), nil
						}
						return nil, fmt.Errorf("field Overrides not resolved")
					},
				},
				"StartedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.StartedAt == nil {
								return nil, nil
							}
							return obj.GetStartedAt(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.StartedAt == nil {
								return nil, nil
							}
							return face.GetStartedAt(), nil
						}
						return nil, fmt.Errorf("field StartedAt not resolved")
					},
				},
				"StartedBy": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.StartedBy == nil {
								return nil, nil
							}
							return obj.GetStartedBy(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.StartedBy == nil {
								return nil, nil
							}
							return face.GetStartedBy(), nil
						}
						return nil, fmt.Errorf("field StartedBy not resolved")
					},
				},
				"StoppedAt": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.StoppedAt == nil {
								return nil, nil
							}
							return obj.GetStoppedAt(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.StoppedAt == nil {
								return nil, nil
							}
							return face.GetStoppedAt(), nil
						}
						return nil, fmt.Errorf("field StoppedAt not resolved")
					},
				},
				"StoppedReason": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.StoppedReason == nil {
								return nil, nil
							}
							return obj.GetStoppedReason(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.StoppedReason == nil {
								return nil, nil
							}
							return face.GetStoppedReason(), nil
						}
						return nil, fmt.Errorf("field StoppedReason not resolved")
					},
				},
				"TaskArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.TaskArn == nil {
								return nil, nil
							}
							return obj.GetTaskArn(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.TaskArn == nil {
								return nil, nil
							}
							return face.GetTaskArn(), nil
						}
						return nil, fmt.Errorf("field TaskArn not resolved")
					},
				},
				"TaskDefinitionArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Task)
						if ok {
							if obj.TaskDefinitionArn == nil {
								return nil, nil
							}
							return obj.GetTaskDefinitionArn(), nil
						}
						inter, ok := p.Source.(TaskGetter)
						if ok {
							face := inter.GetTask()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinitionArn == nil {
								return nil, nil
							}
							return face.GetTaskDefinitionArn(), nil
						}
						return nil, fmt.Errorf("field TaskDefinitionArn not resolved")
					},
				},
			}
		}),
	})
	GraphQLTaskDefinitionType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsTaskDefinition",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerDefinitions": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLContainerDefinitionType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							return obj.ContainerDefinitions, nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							return face.ContainerDefinitions, nil
						}
						return nil, fmt.Errorf("field ContainerDefinitions not resolved")
					},
				},
				"Family": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							if obj.Family == nil {
								return nil, nil
							}
							return obj.GetFamily(), nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Family == nil {
								return nil, nil
							}
							return face.GetFamily(), nil
						}
						return nil, fmt.Errorf("field Family not resolved")
					},
				},
				"RequiresAttributes": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLAttributeType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							return obj.RequiresAttributes, nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							return face.RequiresAttributes, nil
						}
						return nil, fmt.Errorf("field RequiresAttributes not resolved")
					},
				},
				"Revision": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							if obj.Revision == nil {
								return nil, nil
							}
							return obj.GetRevision(), nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Revision == nil {
								return nil, nil
							}
							return face.GetRevision(), nil
						}
						return nil, fmt.Errorf("field Revision not resolved")
					},
				},
				"Status": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							if obj.Status == nil {
								return nil, nil
							}
							return obj.GetStatus(), nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							if face.Status == nil {
								return nil, nil
							}
							return face.GetStatus(), nil
						}
						return nil, fmt.Errorf("field Status not resolved")
					},
				},
				"TaskDefinitionArn": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							if obj.TaskDefinitionArn == nil {
								return nil, nil
							}
							return obj.GetTaskDefinitionArn(), nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							if face.TaskDefinitionArn == nil {
								return nil, nil
							}
							return face.GetTaskDefinitionArn(), nil
						}
						return nil, fmt.Errorf("field TaskDefinitionArn not resolved")
					},
				},
				"Volumes": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLVolumeType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskDefinition)
						if ok {
							return obj.Volumes, nil
						}
						inter, ok := p.Source.(TaskDefinitionGetter)
						if ok {
							face := inter.GetTaskDefinition()
							if face == nil {
								return nil, nil
							}
							return face.Volumes, nil
						}
						return nil, fmt.Errorf("field Volumes not resolved")
					},
				},
			}
		}),
	})
	GraphQLTaskOverrideType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsTaskOverride",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ContainerOverrides": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLContainerOverrideType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*TaskOverride)
						if ok {
							return obj.ContainerOverrides, nil
						}
						inter, ok := p.Source.(TaskOverrideGetter)
						if ok {
							face := inter.GetTaskOverride()
							if face == nil {
								return nil, nil
							}
							return face.ContainerOverrides, nil
						}
						return nil, fmt.Errorf("field ContainerOverrides not resolved")
					},
				},
			}
		}),
	})
	GraphQLUlimitType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsUlimit",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"HardLimit": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Ulimit)
						if ok {
							if obj.HardLimit == nil {
								return nil, nil
							}
							return obj.GetHardLimit(), nil
						}
						inter, ok := p.Source.(UlimitGetter)
						if ok {
							face := inter.GetUlimit()
							if face == nil {
								return nil, nil
							}
							if face.HardLimit == nil {
								return nil, nil
							}
							return face.GetHardLimit(), nil
						}
						return nil, fmt.Errorf("field HardLimit not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Ulimit)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(UlimitGetter)
						if ok {
							face := inter.GetUlimit()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
				"SoftLimit": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Ulimit)
						if ok {
							if obj.SoftLimit == nil {
								return nil, nil
							}
							return obj.GetSoftLimit(), nil
						}
						inter, ok := p.Source.(UlimitGetter)
						if ok {
							face := inter.GetUlimit()
							if face == nil {
								return nil, nil
							}
							if face.SoftLimit == nil {
								return nil, nil
							}
							return face.GetSoftLimit(), nil
						}
						return nil, fmt.Errorf("field SoftLimit not resolved")
					},
				},
			}
		}),
	})
	GraphQLVersionInfoType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsVersionInfo",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"AgentHash": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*VersionInfo)
						if ok {
							if obj.AgentHash == nil {
								return nil, nil
							}
							return obj.GetAgentHash(), nil
						}
						inter, ok := p.Source.(VersionInfoGetter)
						if ok {
							face := inter.GetVersionInfo()
							if face == nil {
								return nil, nil
							}
							if face.AgentHash == nil {
								return nil, nil
							}
							return face.GetAgentHash(), nil
						}
						return nil, fmt.Errorf("field AgentHash not resolved")
					},
				},
				"AgentVersion": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*VersionInfo)
						if ok {
							if obj.AgentVersion == nil {
								return nil, nil
							}
							return obj.GetAgentVersion(), nil
						}
						inter, ok := p.Source.(VersionInfoGetter)
						if ok {
							face := inter.GetVersionInfo()
							if face == nil {
								return nil, nil
							}
							if face.AgentVersion == nil {
								return nil, nil
							}
							return face.GetAgentVersion(), nil
						}
						return nil, fmt.Errorf("field AgentVersion not resolved")
					},
				},
				"DockerVersion": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*VersionInfo)
						if ok {
							if obj.DockerVersion == nil {
								return nil, nil
							}
							return obj.GetDockerVersion(), nil
						}
						inter, ok := p.Source.(VersionInfoGetter)
						if ok {
							face := inter.GetVersionInfo()
							if face == nil {
								return nil, nil
							}
							if face.DockerVersion == nil {
								return nil, nil
							}
							return face.GetDockerVersion(), nil
						}
						return nil, fmt.Errorf("field DockerVersion not resolved")
					},
				},
			}
		}),
	})
	GraphQLVolumeType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsVolume",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"Host": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLHostVolumePropertiesType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Volume)
						if ok {
							if obj.Host == nil {
								return nil, nil
							}
							return obj.GetHost(), nil
						}
						inter, ok := p.Source.(VolumeGetter)
						if ok {
							face := inter.GetVolume()
							if face == nil {
								return nil, nil
							}
							if face.Host == nil {
								return nil, nil
							}
							return face.GetHost(), nil
						}
						return nil, fmt.Errorf("field Host not resolved")
					},
				},
				"Name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Volume)
						if ok {
							if obj.Name == nil {
								return nil, nil
							}
							return obj.GetName(), nil
						}
						inter, ok := p.Source.(VolumeGetter)
						if ok {
							face := inter.GetVolume()
							if face == nil {
								return nil, nil
							}
							if face.Name == nil {
								return nil, nil
							}
							return face.GetName(), nil
						}
						return nil, fmt.Errorf("field Name not resolved")
					},
				},
			}
		}),
	})
	GraphQLVolumeFromType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "ecsVolumeFrom",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"ReadOnly": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*VolumeFrom)
						if ok {
							if obj.ReadOnly == nil {
								return nil, nil
							}
							return obj.GetReadOnly(), nil
						}
						inter, ok := p.Source.(VolumeFromGetter)
						if ok {
							face := inter.GetVolumeFrom()
							if face == nil {
								return nil, nil
							}
							if face.ReadOnly == nil {
								return nil, nil
							}
							return face.GetReadOnly(), nil
						}
						return nil, fmt.Errorf("field ReadOnly not resolved")
					},
				},
				"SourceContainer": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*VolumeFrom)
						if ok {
							if obj.SourceContainer == nil {
								return nil, nil
							}
							return obj.GetSourceContainer(), nil
						}
						inter, ok := p.Source.(VolumeFromGetter)
						if ok {
							face := inter.GetVolumeFrom()
							if face == nil {
								return nil, nil
							}
							if face.SourceContainer == nil {
								return nil, nil
							}
							return face.GetSourceContainer(), nil
						}
						return nil, fmt.Errorf("field SourceContainer not resolved")
					},
				},
			}
		}),
	})
}
func (m *Attribute) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Attribute) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.Value != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Container) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Container) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerArn != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerArn)))
		i += copy(data[i:], *m.ContainerArn)
	}
	if m.ExitCode != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.ExitCode)<<1)^uint64((*m.ExitCode>>63))))
	}
	if m.LastStatus != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.LastStatus)))
		i += copy(data[i:], *m.LastStatus)
	}
	if m.Name != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if len(m.NetworkBindings) > 0 {
		for _, msg := range m.NetworkBindings {
			data[i] = 0x32
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Reason != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Reason)))
		i += copy(data[i:], *m.Reason)
	}
	if m.TaskArn != nil {
		data[i] = 0x42
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskArn)))
		i += copy(data[i:], *m.TaskArn)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerDefinition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerDefinition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Cpu != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.Cpu)<<1)^uint64((*m.Cpu>>63))))
	}
	if m.DisableNetworking != nil {
		data[i] = 0x20
		i++
		if *m.DisableNetworking {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.DnsSearchDomains) > 0 {
		for _, s := range m.DnsSearchDomains {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.DnsServers) > 0 {
		for _, s := range m.DnsServers {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.DockerLabels) > 0 {
		for k, _ := range m.DockerLabels {
			data[i] = 0x3a
			i++
			v := m.DockerLabels[k]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintTypes(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.DockerSecurityOptions) > 0 {
		for _, s := range m.DockerSecurityOptions {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.EntryPoint) > 0 {
		for _, s := range m.EntryPoint {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Environment) > 0 {
		for _, msg := range m.Environment {
			data[i] = 0x52
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Essential != nil {
		data[i] = 0x58
		i++
		if *m.Essential {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ExtraHosts) > 0 {
		for _, msg := range m.ExtraHosts {
			data[i] = 0x62
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Hostname != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Hostname)))
		i += copy(data[i:], *m.Hostname)
	}
	if m.Image != nil {
		data[i] = 0x72
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Image)))
		i += copy(data[i:], *m.Image)
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.LogConfiguration != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintTypes(data, i, uint64(m.LogConfiguration.Size()))
		n1, err := m.LogConfiguration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Memory != nil {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.Memory)<<1)^uint64((*m.Memory>>63))))
	}
	if len(m.MountPoints) > 0 {
		for _, msg := range m.MountPoints {
			data[i] = 0x92
			i++
			data[i] = 0x1
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Name != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if len(m.PortMappings) > 0 {
		for _, msg := range m.PortMappings {
			data[i] = 0xa2
			i++
			data[i] = 0x1
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Privileged != nil {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		if *m.Privileged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ReadonlyRootFilesystem != nil {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		if *m.ReadonlyRootFilesystem {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Ulimits) > 0 {
		for _, msg := range m.Ulimits {
			data[i] = 0xba
			i++
			data[i] = 0x1
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.User != nil {
		data[i] = 0xc2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.User)))
		i += copy(data[i:], *m.User)
	}
	if len(m.VolumesFrom) > 0 {
		for _, msg := range m.VolumesFrom {
			data[i] = 0xca
			i++
			data[i] = 0x1
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WorkingDirectory != nil {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.WorkingDirectory)))
		i += copy(data[i:], *m.WorkingDirectory)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerInstance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerInstance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AgentConnected != nil {
		data[i] = 0x10
		i++
		if *m.AgentConnected {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.AgentUpdateStatus != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.AgentUpdateStatus)))
		i += copy(data[i:], *m.AgentUpdateStatus)
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			data[i] = 0x22
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ContainerInstanceArn != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerInstanceArn)))
		i += copy(data[i:], *m.ContainerInstanceArn)
	}
	if m.Ec2InstanceId != nil {
		data[i] = 0x32
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Ec2InstanceId)))
		i += copy(data[i:], *m.Ec2InstanceId)
	}
	if m.PendingTasksCount != nil {
		data[i] = 0x38
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.PendingTasksCount)<<1)^uint64((*m.PendingTasksCount>>63))))
	}
	if len(m.RegisteredResources) > 0 {
		for _, msg := range m.RegisteredResources {
			data[i] = 0x42
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RemainingResources) > 0 {
		for _, msg := range m.RemainingResources {
			data[i] = 0x4a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RunningTasksCount != nil {
		data[i] = 0x50
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.RunningTasksCount)<<1)^uint64((*m.RunningTasksCount>>63))))
	}
	if m.Status != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Status)))
		i += copy(data[i:], *m.Status)
	}
	if m.VersionInfo != nil {
		data[i] = 0x62
		i++
		i = encodeVarintTypes(data, i, uint64(m.VersionInfo.Size()))
		n2, err := m.VersionInfo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerOverride) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerOverride) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Environment) > 0 {
		for _, msg := range m.Environment {
			data[i] = 0x1a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Name != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deployment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Deployment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreatedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(m.CreatedAt.Size()))
		n3, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DesiredCount != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.DesiredCount)<<1)^uint64((*m.DesiredCount>>63))))
	}
	if m.Id != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.PendingCount != nil {
		data[i] = 0x28
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.PendingCount)<<1)^uint64((*m.PendingCount>>63))))
	}
	if m.RunningCount != nil {
		data[i] = 0x30
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.RunningCount)<<1)^uint64((*m.RunningCount>>63))))
	}
	if m.Status != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Status)))
		i += copy(data[i:], *m.Status)
	}
	if m.TaskDefinition != nil {
		data[i] = 0x42
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskDefinition)))
		i += copy(data[i:], *m.TaskDefinition)
	}
	if m.UpdatedAt != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintTypes(data, i, uint64(m.UpdatedAt.Size()))
		n4, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeploymentConfiguration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeploymentConfiguration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaximumPercent != nil {
		data[i] = 0x10
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MaximumPercent)<<1)^uint64((*m.MaximumPercent>>63))))
	}
	if m.MinimumHealthyPercent != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MinimumHealthyPercent)<<1)^uint64((*m.MinimumHealthyPercent>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeContainerInstancesInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeContainerInstancesInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if len(m.ContainerInstances) > 0 {
		for _, s := range m.ContainerInstances {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeContainerInstancesOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeContainerInstancesOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerInstances) > 0 {
		for _, msg := range m.ContainerInstances {
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Failures) > 0 {
		for _, msg := range m.Failures {
			data[i] = 0x1a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeServicesInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeServicesInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeServicesOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeServicesOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Failures) > 0 {
		for _, msg := range m.Failures {
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			data[i] = 0x1a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeTaskDefinitionInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeTaskDefinitionInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskDefinition != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskDefinition)))
		i += copy(data[i:], *m.TaskDefinition)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeTaskDefinitionOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeTaskDefinitionOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskDefinition != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(m.TaskDefinition.Size()))
		n5, err := m.TaskDefinition.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeTasksInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeTasksInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if len(m.Tasks) > 0 {
		for _, s := range m.Tasks {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescribeTasksOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DescribeTasksOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Failures) > 0 {
		for _, msg := range m.Failures {
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			data[i] = 0x1a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Failure) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Failure) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Arn != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Arn)))
		i += copy(data[i:], *m.Arn)
	}
	if m.Reason != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Reason)))
		i += copy(data[i:], *m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HostEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HostEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hostname != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Hostname)))
		i += copy(data[i:], *m.Hostname)
	}
	if m.IpAddress != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.IpAddress)))
		i += copy(data[i:], *m.IpAddress)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HostVolumeProperties) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HostVolumeProperties) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourcePath != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.SourcePath)))
		i += copy(data[i:], *m.SourcePath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyValuePair) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KeyValuePair) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.Value != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListClustersInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListClustersInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxResults != nil {
		data[i] = 0x10
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MaxResults)<<1)^uint64((*m.MaxResults>>63))))
	}
	if m.NextToken != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListClustersOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListClustersOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterArns) > 0 {
		for _, s := range m.ClusterArns {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.NextToken != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListContainerInstancesInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListContainerInstancesInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if m.MaxResults != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MaxResults)<<1)^uint64((*m.MaxResults>>63))))
	}
	if m.NextToken != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListContainerInstancesOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListContainerInstancesOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerInstanceArns) > 0 {
		for _, s := range m.ContainerInstanceArns {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.NextToken != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListServicesInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListServicesInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if m.MaxResults != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MaxResults)<<1)^uint64((*m.MaxResults>>63))))
	}
	if m.NextToken != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListServicesOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListServicesOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NextToken != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if len(m.ServiceArns) > 0 {
		for _, s := range m.ServiceArns {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListTasksInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListTasksInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cluster != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Cluster)))
		i += copy(data[i:], *m.Cluster)
	}
	if m.ContainerInstance != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerInstance)))
		i += copy(data[i:], *m.ContainerInstance)
	}
	if m.DesiredStatus != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.DesiredStatus)))
		i += copy(data[i:], *m.DesiredStatus)
	}
	if m.Family != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Family)))
		i += copy(data[i:], *m.Family)
	}
	if m.MaxResults != nil {
		data[i] = 0x30
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.MaxResults)<<1)^uint64((*m.MaxResults>>63))))
	}
	if m.NextToken != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if m.ServiceName != nil {
		data[i] = 0x42
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ServiceName)))
		i += copy(data[i:], *m.ServiceName)
	}
	if m.StartedBy != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.StartedBy)))
		i += copy(data[i:], *m.StartedBy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListTasksOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListTasksOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NextToken != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.NextToken)))
		i += copy(data[i:], *m.NextToken)
	}
	if len(m.TaskArns) > 0 {
		for _, s := range m.TaskArns {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LoadBalancer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LoadBalancer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerName != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerName)))
		i += copy(data[i:], *m.ContainerName)
	}
	if m.ContainerPort != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.ContainerPort)<<1)^uint64((*m.ContainerPort>>63))))
	}
	if m.LoadBalancerName != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.LoadBalancerName)))
		i += copy(data[i:], *m.LoadBalancerName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogConfiguration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LogConfiguration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogDriver != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.LogDriver)))
		i += copy(data[i:], *m.LogDriver)
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			data[i] = 0x1a
			i++
			v := m.Options[k]
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			i = encodeVarintTypes(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintTypes(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MountPoint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MountPoint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerPath != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerPath)))
		i += copy(data[i:], *m.ContainerPath)
	}
	if m.ReadOnly != nil {
		data[i] = 0x18
		i++
		if *m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SourceVolume != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.SourceVolume)))
		i += copy(data[i:], *m.SourceVolume)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkBinding) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NetworkBinding) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BindIP != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.BindIP)))
		i += copy(data[i:], *m.BindIP)
	}
	if m.ContainerPort != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.ContainerPort)<<1)^uint64((*m.ContainerPort>>63))))
	}
	if m.HostPort != nil {
		data[i] = 0x20
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.HostPort)<<1)^uint64((*m.HostPort>>63))))
	}
	if m.Protocol != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Protocol)))
		i += copy(data[i:], *m.Protocol)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PortMapping) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PortMapping) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerPort != nil {
		data[i] = 0x10
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.ContainerPort)<<1)^uint64((*m.ContainerPort>>63))))
	}
	if m.HostPort != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.HostPort)<<1)^uint64((*m.HostPort>>63))))
	}
	if m.Protocol != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Protocol)))
		i += copy(data[i:], *m.Protocol)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Resource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Resource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DoubleValue != nil {
		data[i] = 0x11
		i++
		i = encodeFixed64Types(data, i, uint64(math.Float64bits(float64(*m.DoubleValue))))
	}
	if m.IntegerValue != nil {
		data[i] = 0x18
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.IntegerValue)<<1)^uint64((*m.IntegerValue>>63))))
	}
	if m.LongValue != nil {
		data[i] = 0x20
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.LongValue)<<1)^uint64((*m.LongValue>>63))))
	}
	if m.Name != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if len(m.StringSetValue) > 0 {
		for _, s := range m.StringSetValue {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Type != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Type)))
		i += copy(data[i:], *m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Service) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Service) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterArn != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ClusterArn)))
		i += copy(data[i:], *m.ClusterArn)
	}
	if m.CreatedAt != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(m.CreatedAt.Size()))
		n6, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DeploymentConfiguration != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(m.DeploymentConfiguration.Size()))
		n7, err := m.DeploymentConfiguration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Deployments) > 0 {
		for _, msg := range m.Deployments {
			data[i] = 0x2a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DesiredCount != nil {
		data[i] = 0x30
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.DesiredCount)<<1)^uint64((*m.DesiredCount>>63))))
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0x3a
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LoadBalancers) > 0 {
		for _, msg := range m.LoadBalancers {
			data[i] = 0x42
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PendingCount != nil {
		data[i] = 0x48
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.PendingCount)<<1)^uint64((*m.PendingCount>>63))))
	}
	if m.RoleArn != nil {
		data[i] = 0x52
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.RoleArn)))
		i += copy(data[i:], *m.RoleArn)
	}
	if m.RunningCount != nil {
		data[i] = 0x58
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.RunningCount)<<1)^uint64((*m.RunningCount>>63))))
	}
	if m.ServiceArn != nil {
		data[i] = 0x62
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ServiceArn)))
		i += copy(data[i:], *m.ServiceArn)
	}
	if m.ServiceName != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ServiceName)))
		i += copy(data[i:], *m.ServiceName)
	}
	if m.Status != nil {
		data[i] = 0x72
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Status)))
		i += copy(data[i:], *m.Status)
	}
	if m.TaskDefinition != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskDefinition)))
		i += copy(data[i:], *m.TaskDefinition)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServiceEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServiceEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreatedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(m.CreatedAt.Size()))
		n8, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Id != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.Message != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Message)))
		i += copy(data[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Task) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Task) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterArn != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ClusterArn)))
		i += copy(data[i:], *m.ClusterArn)
	}
	if m.ContainerInstanceArn != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.ContainerInstanceArn)))
		i += copy(data[i:], *m.ContainerInstanceArn)
	}
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			data[i] = 0x22
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreatedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintTypes(data, i, uint64(m.CreatedAt.Size()))
		n9, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DesiredStatus != nil {
		data[i] = 0x32
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.DesiredStatus)))
		i += copy(data[i:], *m.DesiredStatus)
	}
	if m.LastStatus != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.LastStatus)))
		i += copy(data[i:], *m.LastStatus)
	}
	if m.Overrides != nil {
		data[i] = 0x42
		i++
		i = encodeVarintTypes(data, i, uint64(m.Overrides.Size()))
		n10, err := m.Overrides.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.StartedAt != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintTypes(data, i, uint64(m.StartedAt.Size()))
		n11, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.StartedBy != nil {
		data[i] = 0x52
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.StartedBy)))
		i += copy(data[i:], *m.StartedBy)
	}
	if m.StoppedAt != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintTypes(data, i, uint64(m.StoppedAt.Size()))
		n12, err := m.StoppedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.StoppedReason != nil {
		data[i] = 0x62
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.StoppedReason)))
		i += copy(data[i:], *m.StoppedReason)
	}
	if m.TaskArn != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskArn)))
		i += copy(data[i:], *m.TaskArn)
	}
	if m.TaskDefinitionArn != nil {
		data[i] = 0x72
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskDefinitionArn)))
		i += copy(data[i:], *m.TaskDefinitionArn)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskDefinition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskDefinition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerDefinitions) > 0 {
		for _, msg := range m.ContainerDefinitions {
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Family != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Family)))
		i += copy(data[i:], *m.Family)
	}
	if len(m.RequiresAttributes) > 0 {
		for _, msg := range m.RequiresAttributes {
			data[i] = 0x22
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Revision != nil {
		data[i] = 0x28
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.Revision)<<1)^uint64((*m.Revision>>63))))
	}
	if m.Status != nil {
		data[i] = 0x32
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Status)))
		i += copy(data[i:], *m.Status)
	}
	if m.TaskDefinitionArn != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.TaskDefinitionArn)))
		i += copy(data[i:], *m.TaskDefinitionArn)
	}
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			data[i] = 0x42
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TaskOverride) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskOverride) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerOverrides) > 0 {
		for _, msg := range m.ContainerOverrides {
			data[i] = 0x12
			i++
			i = encodeVarintTypes(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ulimit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ulimit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HardLimit != nil {
		data[i] = 0x10
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.HardLimit)<<1)^uint64((*m.HardLimit>>63))))
	}
	if m.Name != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.SoftLimit != nil {
		data[i] = 0x20
		i++
		i = encodeVarintTypes(data, i, uint64((uint64(*m.SoftLimit)<<1)^uint64((*m.SoftLimit>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VersionInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AgentHash != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.AgentHash)))
		i += copy(data[i:], *m.AgentHash)
	}
	if m.AgentVersion != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.AgentVersion)))
		i += copy(data[i:], *m.AgentVersion)
	}
	if m.DockerVersion != nil {
		data[i] = 0x22
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.DockerVersion)))
		i += copy(data[i:], *m.DockerVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Volume) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Volume) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Host != nil {
		data[i] = 0x12
		i++
		i = encodeVarintTypes(data, i, uint64(m.Host.Size()))
		n13, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Name != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VolumeFrom) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VolumeFrom) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadOnly != nil {
		data[i] = 0x10
		i++
		if *m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SourceContainer != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintTypes(data, i, uint64(len(*m.SourceContainer)))
		i += copy(data[i:], *m.SourceContainer)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Types(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Types(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTypes(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedAttribute(r randyTypes, easy bool) *Attribute {
	this := &Attribute{}
	if r.Intn(10) != 0 {
		v1 := randStringTypes(r)
		this.Name = &v1
	}
	if r.Intn(10) != 0 {
		v2 := randStringTypes(r)
		this.Value = &v2
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedContainer(r randyTypes, easy bool) *Container {
	this := &Container{}
	if r.Intn(10) != 0 {
		v3 := randStringTypes(r)
		this.ContainerArn = &v3
	}
	if r.Intn(10) != 0 {
		v4 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v4 *= -1
		}
		this.ExitCode = &v4
	}
	if r.Intn(10) != 0 {
		v5 := randStringTypes(r)
		this.LastStatus = &v5
	}
	if r.Intn(10) != 0 {
		v6 := randStringTypes(r)
		this.Name = &v6
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.NetworkBindings = make([]*NetworkBinding, v7)
		for i := 0; i < v7; i++ {
			this.NetworkBindings[i] = NewPopulatedNetworkBinding(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := randStringTypes(r)
		this.Reason = &v8
	}
	if r.Intn(10) != 0 {
		v9 := randStringTypes(r)
		this.TaskArn = &v9
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 9)
	}
	return this
}

func NewPopulatedContainerDefinition(r randyTypes, easy bool) *ContainerDefinition {
	this := &ContainerDefinition{}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Command = make([]string, v10)
		for i := 0; i < v10; i++ {
			this.Command[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v11 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		this.Cpu = &v11
	}
	if r.Intn(10) != 0 {
		v12 := bool(bool(r.Intn(2) == 0))
		this.DisableNetworking = &v12
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(10)
		this.DnsSearchDomains = make([]string, v13)
		for i := 0; i < v13; i++ {
			this.DnsSearchDomains[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v14 := r.Intn(10)
		this.DnsServers = make([]string, v14)
		for i := 0; i < v14; i++ {
			this.DnsServers[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.DockerLabels = make(map[string]string)
		for i := 0; i < v15; i++ {
			this.DockerLabels[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v16 := r.Intn(10)
		this.DockerSecurityOptions = make([]string, v16)
		for i := 0; i < v16; i++ {
			this.DockerSecurityOptions[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(10)
		this.EntryPoint = make([]string, v17)
		for i := 0; i < v17; i++ {
			this.EntryPoint[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(5)
		this.Environment = make([]*KeyValuePair, v18)
		for i := 0; i < v18; i++ {
			this.Environment[i] = NewPopulatedKeyValuePair(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v19 := bool(bool(r.Intn(2) == 0))
		this.Essential = &v19
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(5)
		this.ExtraHosts = make([]*HostEntry, v20)
		for i := 0; i < v20; i++ {
			this.ExtraHosts[i] = NewPopulatedHostEntry(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v21 := randStringTypes(r)
		this.Hostname = &v21
	}
	if r.Intn(10) != 0 {
		v22 := randStringTypes(r)
		this.Image = &v22
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(10)
		this.Links = make([]string, v23)
		for i := 0; i < v23; i++ {
			this.Links[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		this.LogConfiguration = NewPopulatedLogConfiguration(r, easy)
	}
	if r.Intn(10) != 0 {
		v24 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v24 *= -1
		}
		this.Memory = &v24
	}
	if r.Intn(10) != 0 {
		v25 := r.Intn(5)
		this.MountPoints = make([]*MountPoint, v25)
		for i := 0; i < v25; i++ {
			this.MountPoints[i] = NewPopulatedMountPoint(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v26 := randStringTypes(r)
		this.Name = &v26
	}
	if r.Intn(10) != 0 {
		v27 := r.Intn(5)
		this.PortMappings = make([]*PortMapping, v27)
		for i := 0; i < v27; i++ {
			this.PortMappings[i] = NewPopulatedPortMapping(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v28 := bool(bool(r.Intn(2) == 0))
		this.Privileged = &v28
	}
	if r.Intn(10) != 0 {
		v29 := bool(bool(r.Intn(2) == 0))
		this.ReadonlyRootFilesystem = &v29
	}
	if r.Intn(10) != 0 {
		v30 := r.Intn(5)
		this.Ulimits = make([]*Ulimit, v30)
		for i := 0; i < v30; i++ {
			this.Ulimits[i] = NewPopulatedUlimit(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v31 := randStringTypes(r)
		this.User = &v31
	}
	if r.Intn(10) != 0 {
		v32 := r.Intn(5)
		this.VolumesFrom = make([]*VolumeFrom, v32)
		for i := 0; i < v32; i++ {
			this.VolumesFrom[i] = NewPopulatedVolumeFrom(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v33 := randStringTypes(r)
		this.WorkingDirectory = &v33
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 27)
	}
	return this
}

func NewPopulatedContainerInstance(r randyTypes, easy bool) *ContainerInstance {
	this := &ContainerInstance{}
	if r.Intn(10) != 0 {
		v34 := bool(bool(r.Intn(2) == 0))
		this.AgentConnected = &v34
	}
	if r.Intn(10) != 0 {
		v35 := randStringTypes(r)
		this.AgentUpdateStatus = &v35
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(5)
		this.Attributes = make([]*Attribute, v36)
		for i := 0; i < v36; i++ {
			this.Attributes[i] = NewPopulatedAttribute(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v37 := randStringTypes(r)
		this.ContainerInstanceArn = &v37
	}
	if r.Intn(10) != 0 {
		v38 := randStringTypes(r)
		this.Ec2InstanceId = &v38
	}
	if r.Intn(10) != 0 {
		v39 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v39 *= -1
		}
		this.PendingTasksCount = &v39
	}
	if r.Intn(10) != 0 {
		v40 := r.Intn(5)
		this.RegisteredResources = make([]*Resource, v40)
		for i := 0; i < v40; i++ {
			this.RegisteredResources[i] = NewPopulatedResource(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(5)
		this.RemainingResources = make([]*Resource, v41)
		for i := 0; i < v41; i++ {
			this.RemainingResources[i] = NewPopulatedResource(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v42 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v42 *= -1
		}
		this.RunningTasksCount = &v42
	}
	if r.Intn(10) != 0 {
		v43 := randStringTypes(r)
		this.Status = &v43
	}
	if r.Intn(10) != 0 {
		this.VersionInfo = NewPopulatedVersionInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 13)
	}
	return this
}

func NewPopulatedContainerOverride(r randyTypes, easy bool) *ContainerOverride {
	this := &ContainerOverride{}
	if r.Intn(10) != 0 {
		v44 := r.Intn(10)
		this.Command = make([]string, v44)
		for i := 0; i < v44; i++ {
			this.Command[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(5)
		this.Environment = make([]*KeyValuePair, v45)
		for i := 0; i < v45; i++ {
			this.Environment[i] = NewPopulatedKeyValuePair(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v46 := randStringTypes(r)
		this.Name = &v46
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedDeployment(r randyTypes, easy bool) *Deployment {
	this := &Deployment{}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		v47 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v47 *= -1
		}
		this.DesiredCount = &v47
	}
	if r.Intn(10) != 0 {
		v48 := randStringTypes(r)
		this.Id = &v48
	}
	if r.Intn(10) != 0 {
		v49 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v49 *= -1
		}
		this.PendingCount = &v49
	}
	if r.Intn(10) != 0 {
		v50 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v50 *= -1
		}
		this.RunningCount = &v50
	}
	if r.Intn(10) != 0 {
		v51 := randStringTypes(r)
		this.Status = &v51
	}
	if r.Intn(10) != 0 {
		v52 := randStringTypes(r)
		this.TaskDefinition = &v52
	}
	if r.Intn(10) != 0 {
		this.UpdatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 10)
	}
	return this
}

func NewPopulatedDeploymentConfiguration(r randyTypes, easy bool) *DeploymentConfiguration {
	this := &DeploymentConfiguration{}
	if r.Intn(10) != 0 {
		v53 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v53 *= -1
		}
		this.MaximumPercent = &v53
	}
	if r.Intn(10) != 0 {
		v54 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v54 *= -1
		}
		this.MinimumHealthyPercent = &v54
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeContainerInstancesInput(r randyTypes, easy bool) *DescribeContainerInstancesInput {
	this := &DescribeContainerInstancesInput{}
	if r.Intn(10) != 0 {
		v55 := randStringTypes(r)
		this.Cluster = &v55
	}
	if r.Intn(10) != 0 {
		v56 := r.Intn(10)
		this.ContainerInstances = make([]string, v56)
		for i := 0; i < v56; i++ {
			this.ContainerInstances[i] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeContainerInstancesOutput(r randyTypes, easy bool) *DescribeContainerInstancesOutput {
	this := &DescribeContainerInstancesOutput{}
	if r.Intn(10) != 0 {
		v57 := r.Intn(5)
		this.ContainerInstances = make([]*ContainerInstance, v57)
		for i := 0; i < v57; i++ {
			this.ContainerInstances[i] = NewPopulatedContainerInstance(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v58 := r.Intn(5)
		this.Failures = make([]*Failure, v58)
		for i := 0; i < v58; i++ {
			this.Failures[i] = NewPopulatedFailure(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeServicesInput(r randyTypes, easy bool) *DescribeServicesInput {
	this := &DescribeServicesInput{}
	if r.Intn(10) != 0 {
		v59 := randStringTypes(r)
		this.Cluster = &v59
	}
	if r.Intn(10) != 0 {
		v60 := r.Intn(10)
		this.Services = make([]string, v60)
		for i := 0; i < v60; i++ {
			this.Services[i] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeServicesOutput(r randyTypes, easy bool) *DescribeServicesOutput {
	this := &DescribeServicesOutput{}
	if r.Intn(10) != 0 {
		v61 := r.Intn(5)
		this.Failures = make([]*Failure, v61)
		for i := 0; i < v61; i++ {
			this.Failures[i] = NewPopulatedFailure(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v62 := r.Intn(5)
		this.Services = make([]*Service, v62)
		for i := 0; i < v62; i++ {
			this.Services[i] = NewPopulatedService(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeTaskDefinitionInput(r randyTypes, easy bool) *DescribeTaskDefinitionInput {
	this := &DescribeTaskDefinitionInput{}
	if r.Intn(10) != 0 {
		v63 := randStringTypes(r)
		this.TaskDefinition = &v63
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 3)
	}
	return this
}

func NewPopulatedDescribeTaskDefinitionOutput(r randyTypes, easy bool) *DescribeTaskDefinitionOutput {
	this := &DescribeTaskDefinitionOutput{}
	if r.Intn(10) != 0 {
		this.TaskDefinition = NewPopulatedTaskDefinition(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 3)
	}
	return this
}

func NewPopulatedDescribeTasksInput(r randyTypes, easy bool) *DescribeTasksInput {
	this := &DescribeTasksInput{}
	if r.Intn(10) != 0 {
		v64 := randStringTypes(r)
		this.Cluster = &v64
	}
	if r.Intn(10) != 0 {
		v65 := r.Intn(10)
		this.Tasks = make([]string, v65)
		for i := 0; i < v65; i++ {
			this.Tasks[i] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedDescribeTasksOutput(r randyTypes, easy bool) *DescribeTasksOutput {
	this := &DescribeTasksOutput{}
	if r.Intn(10) != 0 {
		v66 := r.Intn(5)
		this.Failures = make([]*Failure, v66)
		for i := 0; i < v66; i++ {
			this.Failures[i] = NewPopulatedFailure(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v67 := r.Intn(5)
		this.Tasks = make([]*Task, v67)
		for i := 0; i < v67; i++ {
			this.Tasks[i] = NewPopulatedTask(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedFailure(r randyTypes, easy bool) *Failure {
	this := &Failure{}
	if r.Intn(10) != 0 {
		v68 := randStringTypes(r)
		this.Arn = &v68
	}
	if r.Intn(10) != 0 {
		v69 := randStringTypes(r)
		this.Reason = &v69
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedHostEntry(r randyTypes, easy bool) *HostEntry {
	this := &HostEntry{}
	if r.Intn(10) != 0 {
		v70 := randStringTypes(r)
		this.Hostname = &v70
	}
	if r.Intn(10) != 0 {
		v71 := randStringTypes(r)
		this.IpAddress = &v71
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedHostVolumeProperties(r randyTypes, easy bool) *HostVolumeProperties {
	this := &HostVolumeProperties{}
	if r.Intn(10) != 0 {
		v72 := randStringTypes(r)
		this.SourcePath = &v72
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 3)
	}
	return this
}

func NewPopulatedKeyValuePair(r randyTypes, easy bool) *KeyValuePair {
	this := &KeyValuePair{}
	if r.Intn(10) != 0 {
		v73 := randStringTypes(r)
		this.Name = &v73
	}
	if r.Intn(10) != 0 {
		v74 := randStringTypes(r)
		this.Value = &v74
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedListClustersInput(r randyTypes, easy bool) *ListClustersInput {
	this := &ListClustersInput{}
	if r.Intn(10) != 0 {
		v75 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v75 *= -1
		}
		this.MaxResults = &v75
	}
	if r.Intn(10) != 0 {
		v76 := randStringTypes(r)
		this.NextToken = &v76
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedListClustersOutput(r randyTypes, easy bool) *ListClustersOutput {
	this := &ListClustersOutput{}
	if r.Intn(10) != 0 {
		v77 := r.Intn(10)
		this.ClusterArns = make([]string, v77)
		for i := 0; i < v77; i++ {
			this.ClusterArns[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v78 := randStringTypes(r)
		this.NextToken = &v78
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedListContainerInstancesInput(r randyTypes, easy bool) *ListContainerInstancesInput {
	this := &ListContainerInstancesInput{}
	if r.Intn(10) != 0 {
		v79 := randStringTypes(r)
		this.Cluster = &v79
	}
	if r.Intn(10) != 0 {
		v80 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v80 *= -1
		}
		this.MaxResults = &v80
	}
	if r.Intn(10) != 0 {
		v81 := randStringTypes(r)
		this.NextToken = &v81
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedListContainerInstancesOutput(r randyTypes, easy bool) *ListContainerInstancesOutput {
	this := &ListContainerInstancesOutput{}
	if r.Intn(10) != 0 {
		v82 := r.Intn(10)
		this.ContainerInstanceArns = make([]string, v82)
		for i := 0; i < v82; i++ {
			this.ContainerInstanceArns[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v83 := randStringTypes(r)
		this.NextToken = &v83
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedListServicesInput(r randyTypes, easy bool) *ListServicesInput {
	this := &ListServicesInput{}
	if r.Intn(10) != 0 {
		v84 := randStringTypes(r)
		this.Cluster = &v84
	}
	if r.Intn(10) != 0 {
		v85 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v85 *= -1
		}
		this.MaxResults = &v85
	}
	if r.Intn(10) != 0 {
		v86 := randStringTypes(r)
		this.NextToken = &v86
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedListServicesOutput(r randyTypes, easy bool) *ListServicesOutput {
	this := &ListServicesOutput{}
	if r.Intn(10) != 0 {
		v87 := randStringTypes(r)
		this.NextToken = &v87
	}
	if r.Intn(10) != 0 {
		v88 := r.Intn(10)
		this.ServiceArns = make([]string, v88)
		for i := 0; i < v88; i++ {
			this.ServiceArns[i] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedListTasksInput(r randyTypes, easy bool) *ListTasksInput {
	this := &ListTasksInput{}
	if r.Intn(10) != 0 {
		v89 := randStringTypes(r)
		this.Cluster = &v89
	}
	if r.Intn(10) != 0 {
		v90 := randStringTypes(r)
		this.ContainerInstance = &v90
	}
	if r.Intn(10) != 0 {
		v91 := randStringTypes(r)
		this.DesiredStatus = &v91
	}
	if r.Intn(10) != 0 {
		v92 := randStringTypes(r)
		this.Family = &v92
	}
	if r.Intn(10) != 0 {
		v93 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v93 *= -1
		}
		this.MaxResults = &v93
	}
	if r.Intn(10) != 0 {
		v94 := randStringTypes(r)
		this.NextToken = &v94
	}
	if r.Intn(10) != 0 {
		v95 := randStringTypes(r)
		this.ServiceName = &v95
	}
	if r.Intn(10) != 0 {
		v96 := randStringTypes(r)
		this.StartedBy = &v96
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 10)
	}
	return this
}

func NewPopulatedListTasksOutput(r randyTypes, easy bool) *ListTasksOutput {
	this := &ListTasksOutput{}
	if r.Intn(10) != 0 {
		v97 := randStringTypes(r)
		this.NextToken = &v97
	}
	if r.Intn(10) != 0 {
		v98 := r.Intn(10)
		this.TaskArns = make([]string, v98)
		for i := 0; i < v98; i++ {
			this.TaskArns[i] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedLoadBalancer(r randyTypes, easy bool) *LoadBalancer {
	this := &LoadBalancer{}
	if r.Intn(10) != 0 {
		v99 := randStringTypes(r)
		this.ContainerName = &v99
	}
	if r.Intn(10) != 0 {
		v100 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v100 *= -1
		}
		this.ContainerPort = &v100
	}
	if r.Intn(10) != 0 {
		v101 := randStringTypes(r)
		this.LoadBalancerName = &v101
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedLogConfiguration(r randyTypes, easy bool) *LogConfiguration {
	this := &LogConfiguration{}
	if r.Intn(10) != 0 {
		v102 := randStringTypes(r)
		this.LogDriver = &v102
	}
	if r.Intn(10) != 0 {
		v103 := r.Intn(10)
		this.Options = make(map[string]string)
		for i := 0; i < v103; i++ {
			this.Options[randStringTypes(r)] = randStringTypes(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedMountPoint(r randyTypes, easy bool) *MountPoint {
	this := &MountPoint{}
	if r.Intn(10) != 0 {
		v104 := randStringTypes(r)
		this.ContainerPath = &v104
	}
	if r.Intn(10) != 0 {
		v105 := bool(bool(r.Intn(2) == 0))
		this.ReadOnly = &v105
	}
	if r.Intn(10) != 0 {
		v106 := randStringTypes(r)
		this.SourceVolume = &v106
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedNetworkBinding(r randyTypes, easy bool) *NetworkBinding {
	this := &NetworkBinding{}
	if r.Intn(10) != 0 {
		v107 := randStringTypes(r)
		this.BindIP = &v107
	}
	if r.Intn(10) != 0 {
		v108 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v108 *= -1
		}
		this.ContainerPort = &v108
	}
	if r.Intn(10) != 0 {
		v109 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v109 *= -1
		}
		this.HostPort = &v109
	}
	if r.Intn(10) != 0 {
		v110 := randStringTypes(r)
		this.Protocol = &v110
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 6)
	}
	return this
}

func NewPopulatedPortMapping(r randyTypes, easy bool) *PortMapping {
	this := &PortMapping{}
	if r.Intn(10) != 0 {
		v111 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v111 *= -1
		}
		this.ContainerPort = &v111
	}
	if r.Intn(10) != 0 {
		v112 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v112 *= -1
		}
		this.HostPort = &v112
	}
	if r.Intn(10) != 0 {
		v113 := randStringTypes(r)
		this.Protocol = &v113
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedResource(r randyTypes, easy bool) *Resource {
	this := &Resource{}
	if r.Intn(10) != 0 {
		v114 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v114 *= -1
		}
		this.DoubleValue = &v114
	}
	if r.Intn(10) != 0 {
		v115 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v115 *= -1
		}
		this.IntegerValue = &v115
	}
	if r.Intn(10) != 0 {
		v116 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v116 *= -1
		}
		this.LongValue = &v116
	}
	if r.Intn(10) != 0 {
		v117 := randStringTypes(r)
		this.Name = &v117
	}
	if r.Intn(10) != 0 {
		v118 := r.Intn(10)
		this.StringSetValue = make([]string, v118)
		for i := 0; i < v118; i++ {
			this.StringSetValue[i] = randStringTypes(r)
		}
	}
	if r.Intn(10) != 0 {
		v119 := randStringTypes(r)
		this.Type = &v119
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 8)
	}
	return this
}

func NewPopulatedService(r randyTypes, easy bool) *Service {
	this := &Service{}
	if r.Intn(10) != 0 {
		v120 := randStringTypes(r)
		this.ClusterArn = &v120
	}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DeploymentConfiguration = NewPopulatedDeploymentConfiguration(r, easy)
	}
	if r.Intn(10) != 0 {
		v121 := r.Intn(5)
		this.Deployments = make([]*Deployment, v121)
		for i := 0; i < v121; i++ {
			this.Deployments[i] = NewPopulatedDeployment(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v122 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v122 *= -1
		}
		this.DesiredCount = &v122
	}
	if r.Intn(10) != 0 {
		v123 := r.Intn(5)
		this.Events = make([]*ServiceEvent, v123)
		for i := 0; i < v123; i++ {
			this.Events[i] = NewPopulatedServiceEvent(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v124 := r.Intn(5)
		this.LoadBalancers = make([]*LoadBalancer, v124)
		for i := 0; i < v124; i++ {
			this.LoadBalancers[i] = NewPopulatedLoadBalancer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v125 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v125 *= -1
		}
		this.PendingCount = &v125
	}
	if r.Intn(10) != 0 {
		v126 := randStringTypes(r)
		this.RoleArn = &v126
	}
	if r.Intn(10) != 0 {
		v127 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v127 *= -1
		}
		this.RunningCount = &v127
	}
	if r.Intn(10) != 0 {
		v128 := randStringTypes(r)
		this.ServiceArn = &v128
	}
	if r.Intn(10) != 0 {
		v129 := randStringTypes(r)
		this.ServiceName = &v129
	}
	if r.Intn(10) != 0 {
		v130 := randStringTypes(r)
		this.Status = &v130
	}
	if r.Intn(10) != 0 {
		v131 := randStringTypes(r)
		this.TaskDefinition = &v131
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 16)
	}
	return this
}

func NewPopulatedServiceEvent(r randyTypes, easy bool) *ServiceEvent {
	this := &ServiceEvent{}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		v132 := randStringTypes(r)
		this.Id = &v132
	}
	if r.Intn(10) != 0 {
		v133 := randStringTypes(r)
		this.Message = &v133
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedTask(r randyTypes, easy bool) *Task {
	this := &Task{}
	if r.Intn(10) != 0 {
		v134 := randStringTypes(r)
		this.ClusterArn = &v134
	}
	if r.Intn(10) != 0 {
		v135 := randStringTypes(r)
		this.ContainerInstanceArn = &v135
	}
	if r.Intn(10) != 0 {
		v136 := r.Intn(5)
		this.Containers = make([]*Container, v136)
		for i := 0; i < v136; i++ {
			this.Containers[i] = NewPopulatedContainer(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		v137 := randStringTypes(r)
		this.DesiredStatus = &v137
	}
	if r.Intn(10) != 0 {
		v138 := randStringTypes(r)
		this.LastStatus = &v138
	}
	if r.Intn(10) != 0 {
		this.Overrides = NewPopulatedTaskOverride(r, easy)
	}
	if r.Intn(10) != 0 {
		this.StartedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		v139 := randStringTypes(r)
		this.StartedBy = &v139
	}
	if r.Intn(10) != 0 {
		this.StoppedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		v140 := randStringTypes(r)
		this.StoppedReason = &v140
	}
	if r.Intn(10) != 0 {
		v141 := randStringTypes(r)
		this.TaskArn = &v141
	}
	if r.Intn(10) != 0 {
		v142 := randStringTypes(r)
		this.TaskDefinitionArn = &v142
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 15)
	}
	return this
}

func NewPopulatedTaskDefinition(r randyTypes, easy bool) *TaskDefinition {
	this := &TaskDefinition{}
	if r.Intn(10) != 0 {
		v143 := r.Intn(5)
		this.ContainerDefinitions = make([]*ContainerDefinition, v143)
		for i := 0; i < v143; i++ {
			this.ContainerDefinitions[i] = NewPopulatedContainerDefinition(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v144 := randStringTypes(r)
		this.Family = &v144
	}
	if r.Intn(10) != 0 {
		v145 := r.Intn(5)
		this.RequiresAttributes = make([]*Attribute, v145)
		for i := 0; i < v145; i++ {
			this.RequiresAttributes[i] = NewPopulatedAttribute(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v146 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v146 *= -1
		}
		this.Revision = &v146
	}
	if r.Intn(10) != 0 {
		v147 := randStringTypes(r)
		this.Status = &v147
	}
	if r.Intn(10) != 0 {
		v148 := randStringTypes(r)
		this.TaskDefinitionArn = &v148
	}
	if r.Intn(10) != 0 {
		v149 := r.Intn(5)
		this.Volumes = make([]*Volume, v149)
		for i := 0; i < v149; i++ {
			this.Volumes[i] = NewPopulatedVolume(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 9)
	}
	return this
}

func NewPopulatedTaskOverride(r randyTypes, easy bool) *TaskOverride {
	this := &TaskOverride{}
	if r.Intn(10) != 0 {
		v150 := r.Intn(5)
		this.ContainerOverrides = make([]*ContainerOverride, v150)
		for i := 0; i < v150; i++ {
			this.ContainerOverrides[i] = NewPopulatedContainerOverride(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 3)
	}
	return this
}

func NewPopulatedUlimit(r randyTypes, easy bool) *Ulimit {
	this := &Ulimit{}
	if r.Intn(10) != 0 {
		v151 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v151 *= -1
		}
		this.HardLimit = &v151
	}
	if r.Intn(10) != 0 {
		v152 := randStringTypes(r)
		this.Name = &v152
	}
	if r.Intn(10) != 0 {
		v153 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v153 *= -1
		}
		this.SoftLimit = &v153
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedVersionInfo(r randyTypes, easy bool) *VersionInfo {
	this := &VersionInfo{}
	if r.Intn(10) != 0 {
		v154 := randStringTypes(r)
		this.AgentHash = &v154
	}
	if r.Intn(10) != 0 {
		v155 := randStringTypes(r)
		this.AgentVersion = &v155
	}
	if r.Intn(10) != 0 {
		v156 := randStringTypes(r)
		this.DockerVersion = &v156
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 5)
	}
	return this
}

func NewPopulatedVolume(r randyTypes, easy bool) *Volume {
	this := &Volume{}
	if r.Intn(10) != 0 {
		this.Host = NewPopulatedHostVolumeProperties(r, easy)
	}
	if r.Intn(10) != 0 {
		v157 := randStringTypes(r)
		this.Name = &v157
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

func NewPopulatedVolumeFrom(r randyTypes, easy bool) *VolumeFrom {
	this := &VolumeFrom{}
	if r.Intn(10) != 0 {
		v158 := bool(bool(r.Intn(2) == 0))
		this.ReadOnly = &v158
	}
	if r.Intn(10) != 0 {
		v159 := randStringTypes(r)
		this.SourceContainer = &v159
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTypes(r, 4)
	}
	return this
}

type randyTypes interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTypes(r randyTypes) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTypes(r randyTypes) string {
	v160 := r.Intn(100)
	tmps := make([]rune, v160)
	for i := 0; i < v160; i++ {
		tmps[i] = randUTF8RuneTypes(r)
	}
	return string(tmps)
}
func randUnrecognizedTypes(r randyTypes, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldTypes(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldTypes(data []byte, r randyTypes, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateTypes(data, uint64(key))
		v161 := r.Int63()
		if r.Intn(2) == 0 {
			v161 *= -1
		}
		data = encodeVarintPopulateTypes(data, uint64(v161))
	case 1:
		data = encodeVarintPopulateTypes(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateTypes(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateTypes(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateTypes(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateTypes(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Attribute) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	if m.ContainerArn != nil {
		l = len(*m.ContainerArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExitCode != nil {
		n += 1 + sozTypes(uint64(*m.ExitCode))
	}
	if m.LastStatus != nil {
		l = len(*m.LastStatus)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.NetworkBindings) > 0 {
		for _, e := range m.NetworkBindings {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Reason != nil {
		l = len(*m.Reason)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskArn != nil {
		l = len(*m.TaskArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerDefinition) Size() (n int) {
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Cpu != nil {
		n += 1 + sozTypes(uint64(*m.Cpu))
	}
	if m.DisableNetworking != nil {
		n += 2
	}
	if len(m.DnsSearchDomains) > 0 {
		for _, s := range m.DnsSearchDomains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DnsServers) > 0 {
		for _, s := range m.DnsServers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DockerLabels) > 0 {
		for k, v := range m.DockerLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.DockerSecurityOptions) > 0 {
		for _, s := range m.DockerSecurityOptions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EntryPoint) > 0 {
		for _, s := range m.EntryPoint {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Environment) > 0 {
		for _, e := range m.Environment {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Essential != nil {
		n += 2
	}
	if len(m.ExtraHosts) > 0 {
		for _, e := range m.ExtraHosts {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Image != nil {
		l = len(*m.Image)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LogConfiguration != nil {
		l = m.LogConfiguration.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Memory != nil {
		n += 2 + sozTypes(uint64(*m.Memory))
	}
	if len(m.MountPoints) > 0 {
		for _, e := range m.MountPoints {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.PortMappings) > 0 {
		for _, e := range m.PortMappings {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Privileged != nil {
		n += 3
	}
	if m.ReadonlyRootFilesystem != nil {
		n += 3
	}
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.User != nil {
		l = len(*m.User)
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.VolumesFrom) > 0 {
		for _, e := range m.VolumesFrom {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.WorkingDirectory != nil {
		l = len(*m.WorkingDirectory)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerInstance) Size() (n int) {
	var l int
	_ = l
	if m.AgentConnected != nil {
		n += 2
	}
	if m.AgentUpdateStatus != nil {
		l = len(*m.AgentUpdateStatus)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ContainerInstanceArn != nil {
		l = len(*m.ContainerInstanceArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Ec2InstanceId != nil {
		l = len(*m.Ec2InstanceId)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PendingTasksCount != nil {
		n += 1 + sozTypes(uint64(*m.PendingTasksCount))
	}
	if len(m.RegisteredResources) > 0 {
		for _, e := range m.RegisteredResources {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RemainingResources) > 0 {
		for _, e := range m.RemainingResources {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RunningTasksCount != nil {
		n += 1 + sozTypes(uint64(*m.RunningTasksCount))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VersionInfo != nil {
		l = m.VersionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerOverride) Size() (n int) {
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Environment) > 0 {
		for _, e := range m.Environment {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment) Size() (n int) {
	var l int
	_ = l
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredCount != nil {
		n += 1 + sozTypes(uint64(*m.DesiredCount))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PendingCount != nil {
		n += 1 + sozTypes(uint64(*m.PendingCount))
	}
	if m.RunningCount != nil {
		n += 1 + sozTypes(uint64(*m.RunningCount))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskDefinition != nil {
		l = len(*m.TaskDefinition)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.MaximumPercent != nil {
		n += 1 + sozTypes(uint64(*m.MaximumPercent))
	}
	if m.MinimumHealthyPercent != nil {
		n += 1 + sozTypes(uint64(*m.MinimumHealthyPercent))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeContainerInstancesInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ContainerInstances) > 0 {
		for _, s := range m.ContainerInstances {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeContainerInstancesOutput) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerInstances) > 0 {
		for _, e := range m.ContainerInstances {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Failures) > 0 {
		for _, e := range m.Failures {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeServicesInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeServicesOutput) Size() (n int) {
	var l int
	_ = l
	if len(m.Failures) > 0 {
		for _, e := range m.Failures {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeTaskDefinitionInput) Size() (n int) {
	var l int
	_ = l
	if m.TaskDefinition != nil {
		l = len(*m.TaskDefinition)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeTaskDefinitionOutput) Size() (n int) {
	var l int
	_ = l
	if m.TaskDefinition != nil {
		l = m.TaskDefinition.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeTasksInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tasks) > 0 {
		for _, s := range m.Tasks {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescribeTasksOutput) Size() (n int) {
	var l int
	_ = l
	if len(m.Failures) > 0 {
		for _, e := range m.Failures {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Failure) Size() (n int) {
	var l int
	_ = l
	if m.Arn != nil {
		l = len(*m.Arn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Reason != nil {
		l = len(*m.Reason)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostEntry) Size() (n int) {
	var l int
	_ = l
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpAddress != nil {
		l = len(*m.IpAddress)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostVolumeProperties) Size() (n int) {
	var l int
	_ = l
	if m.SourcePath != nil {
		l = len(*m.SourcePath)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValuePair) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListClustersInput) Size() (n int) {
	var l int
	_ = l
	if m.MaxResults != nil {
		n += 1 + sozTypes(uint64(*m.MaxResults))
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListClustersOutput) Size() (n int) {
	var l int
	_ = l
	if len(m.ClusterArns) > 0 {
		for _, s := range m.ClusterArns {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListContainerInstancesInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxResults != nil {
		n += 1 + sozTypes(uint64(*m.MaxResults))
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListContainerInstancesOutput) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerInstanceArns) > 0 {
		for _, s := range m.ContainerInstanceArns {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListServicesInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxResults != nil {
		n += 1 + sozTypes(uint64(*m.MaxResults))
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListServicesOutput) Size() (n int) {
	var l int
	_ = l
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ServiceArns) > 0 {
		for _, s := range m.ServiceArns {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTasksInput) Size() (n int) {
	var l int
	_ = l
	if m.Cluster != nil {
		l = len(*m.Cluster)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerInstance != nil {
		l = len(*m.ContainerInstance)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredStatus != nil {
		l = len(*m.DesiredStatus)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Family != nil {
		l = len(*m.Family)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxResults != nil {
		n += 1 + sozTypes(uint64(*m.MaxResults))
	}
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServiceName != nil {
		l = len(*m.ServiceName)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StartedBy != nil {
		l = len(*m.StartedBy)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTasksOutput) Size() (n int) {
	var l int
	_ = l
	if m.NextToken != nil {
		l = len(*m.NextToken)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TaskArns) > 0 {
		for _, s := range m.TaskArns {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadBalancer) Size() (n int) {
	var l int
	_ = l
	if m.ContainerName != nil {
		l = len(*m.ContainerName)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerPort != nil {
		n += 1 + sozTypes(uint64(*m.ContainerPort))
	}
	if m.LoadBalancerName != nil {
		l = len(*m.LoadBalancerName)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.LogDriver != nil {
		l = len(*m.LogDriver)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MountPoint) Size() (n int) {
	var l int
	_ = l
	if m.ContainerPath != nil {
		l = len(*m.ContainerPath)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadOnly != nil {
		n += 2
	}
	if m.SourceVolume != nil {
		l = len(*m.SourceVolume)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkBinding) Size() (n int) {
	var l int
	_ = l
	if m.BindIP != nil {
		l = len(*m.BindIP)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerPort != nil {
		n += 1 + sozTypes(uint64(*m.ContainerPort))
	}
	if m.HostPort != nil {
		n += 1 + sozTypes(uint64(*m.HostPort))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PortMapping) Size() (n int) {
	var l int
	_ = l
	if m.ContainerPort != nil {
		n += 1 + sozTypes(uint64(*m.ContainerPort))
	}
	if m.HostPort != nil {
		n += 1 + sozTypes(uint64(*m.HostPort))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resource) Size() (n int) {
	var l int
	_ = l
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntegerValue != nil {
		n += 1 + sozTypes(uint64(*m.IntegerValue))
	}
	if m.LongValue != nil {
		n += 1 + sozTypes(uint64(*m.LongValue))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StringSetValue) > 0 {
		for _, s := range m.StringSetValue {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.ClusterArn != nil {
		l = len(*m.ClusterArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeploymentConfiguration != nil {
		l = m.DeploymentConfiguration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Deployments) > 0 {
		for _, e := range m.Deployments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DesiredCount != nil {
		n += 1 + sozTypes(uint64(*m.DesiredCount))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.LoadBalancers) > 0 {
		for _, e := range m.LoadBalancers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PendingCount != nil {
		n += 1 + sozTypes(uint64(*m.PendingCount))
	}
	if m.RoleArn != nil {
		l = len(*m.RoleArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RunningCount != nil {
		n += 1 + sozTypes(uint64(*m.RunningCount))
	}
	if m.ServiceArn != nil {
		l = len(*m.ServiceArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ServiceName != nil {
		l = len(*m.ServiceName)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskDefinition != nil {
		l = len(*m.TaskDefinition)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceEvent) Size() (n int) {
	var l int
	_ = l
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Task) Size() (n int) {
	var l int
	_ = l
	if m.ClusterArn != nil {
		l = len(*m.ClusterArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ContainerInstanceArn != nil {
		l = len(*m.ContainerInstanceArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesiredStatus != nil {
		l = len(*m.DesiredStatus)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastStatus != nil {
		l = len(*m.LastStatus)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Overrides != nil {
		l = m.Overrides.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StartedBy != nil {
		l = len(*m.StartedBy)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StoppedAt != nil {
		l = m.StoppedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StoppedReason != nil {
		l = len(*m.StoppedReason)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskArn != nil {
		l = len(*m.TaskArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskDefinitionArn != nil {
		l = len(*m.TaskDefinitionArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskDefinition) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerDefinitions) > 0 {
		for _, e := range m.ContainerDefinitions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Family != nil {
		l = len(*m.Family)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RequiresAttributes) > 0 {
		for _, e := range m.RequiresAttributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Revision != nil {
		n += 1 + sozTypes(uint64(*m.Revision))
	}
	if m.Status != nil {
		l = len(*m.Status)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TaskDefinitionArn != nil {
		l = len(*m.TaskDefinitionArn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskOverride) Size() (n int) {
	var l int
	_ = l
	if len(m.ContainerOverrides) > 0 {
		for _, e := range m.ContainerOverrides {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ulimit) Size() (n int) {
	var l int
	_ = l
	if m.HardLimit != nil {
		n += 1 + sozTypes(uint64(*m.HardLimit))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SoftLimit != nil {
		n += 1 + sozTypes(uint64(*m.SoftLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionInfo) Size() (n int) {
	var l int
	_ = l
	if m.AgentHash != nil {
		l = len(*m.AgentHash)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AgentVersion != nil {
		l = len(*m.AgentVersion)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DockerVersion != nil {
		l = len(*m.DockerVersion)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Volume) Size() (n int) {
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VolumeFrom) Size() (n int) {
	var l int
	_ = l
	if m.ReadOnly != nil {
		n += 2
	}
	if m.SourceContainer != nil {
		l = len(*m.SourceContainer)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Attribute) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerArn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ExitCode = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LastStatus = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkBindings = append(m.NetworkBindings, &NetworkBinding{})
			if err := m.NetworkBindings[len(m.NetworkBindings)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reason = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskArn = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerDefinition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Cpu = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableNetworking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DisableNetworking = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSearchDomains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsSearchDomains = append(m.DnsSearchDomains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServers = append(m.DnsServers, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTypes
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthTypes
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.DockerLabels == nil {
				m.DockerLabels = make(map[string]string)
			}
			m.DockerLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerSecurityOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerSecurityOptions = append(m.DockerSecurityOptions, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryPoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryPoint = append(m.EntryPoint, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = append(m.Environment, &KeyValuePair{})
			if err := m.Environment[len(m.Environment)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Essential", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Essential = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraHosts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraHosts = append(m.ExtraHosts, &HostEntry{})
			if err := m.ExtraHosts[len(m.ExtraHosts)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Image = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogConfiguration == nil {
				m.LogConfiguration = &LogConfiguration{}
			}
			if err := m.LogConfiguration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Memory = &v2
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPoints = append(m.MountPoints, &MountPoint{})
			if err := m.MountPoints[len(m.MountPoints)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMappings = append(m.PortMappings, &PortMapping{})
			if err := m.PortMappings[len(m.PortMappings)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Privileged = &b
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadonlyRootFilesystem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadonlyRootFilesystem = &b
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, &Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumesFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumesFrom = append(m.VolumesFrom, &VolumeFrom{})
			if err := m.VolumesFrom[len(m.VolumesFrom)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.WorkingDirectory = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInstance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AgentConnected = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentUpdateStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AgentUpdateStatus = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstanceArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerInstanceArn = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ec2InstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Ec2InstanceId = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTasksCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.PendingTasksCount = &v2
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisteredResources = append(m.RegisteredResources, &Resource{})
			if err := m.RegisteredResources[len(m.RegisteredResources)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemainingResources = append(m.RemainingResources, &Resource{})
			if err := m.RemainingResources[len(m.RemainingResources)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningTasksCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RunningTasksCount = &v2
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionInfo == nil {
				m.VersionInfo = &VersionInfo{}
			}
			if err := m.VersionInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerOverride) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = append(m.Environment, &KeyValuePair{})
			if err := m.Environment[len(m.Environment)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DesiredCount = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.PendingCount = &v2
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RunningCount = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskDefinition = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &opsee_types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentConfiguration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPercent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MaximumPercent = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumHealthyPercent", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MinimumHealthyPercent = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeContainerInstancesInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeContainerInstancesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeContainerInstancesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstances", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerInstances = append(m.ContainerInstances, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeContainerInstancesOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeContainerInstancesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeContainerInstancesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerInstances = append(m.ContainerInstances, &ContainerInstance{})
			if err := m.ContainerInstances[len(m.ContainerInstances)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failures = append(m.Failures, &Failure{})
			if err := m.Failures[len(m.Failures)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeServicesInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeServicesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeServicesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeServicesOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeServicesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeServicesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failures = append(m.Failures, &Failure{})
			if err := m.Failures[len(m.Failures)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &Service{})
			if err := m.Services[len(m.Services)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTaskDefinitionInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTaskDefinitionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTaskDefinitionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskDefinition = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTaskDefinitionOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTaskDefinitionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTaskDefinitionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskDefinition == nil {
				m.TaskDefinition = &TaskDefinition{}
			}
			if err := m.TaskDefinition.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTasksInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTasksInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTasksInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTasksOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTasksOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTasksOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failures = append(m.Failures, &Failure{})
			if err := m.Failures[len(m.Failures)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &Task{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Failure) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Arn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reason = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.IpAddress = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostVolumeProperties) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostVolumeProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostVolumeProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SourcePath = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValuePair) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValuePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValuePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListClustersInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListClustersInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListClustersInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MaxResults = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListClustersOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListClustersOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListClustersOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterArns = append(m.ClusterArns, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListContainerInstancesInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListContainerInstancesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListContainerInstancesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MaxResults = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListContainerInstancesOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListContainerInstancesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListContainerInstancesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstanceArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerInstanceArns = append(m.ContainerInstanceArns, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServicesInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServicesInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServicesInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MaxResults = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListServicesOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListServicesOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListServicesOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceArns = append(m.ServiceArns, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTasksInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTasksInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTasksInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cluster = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerInstance = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DesiredStatus = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Family = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.MaxResults = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ServiceName = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StartedBy = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTasksOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTasksOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTasksOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.NextToken = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskArns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskArns = append(m.TaskArns, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ContainerPort = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LoadBalancerName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogConfiguration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LogDriver = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTypes
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthTypes
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Options == nil {
				m.Options = make(map[string]string)
			}
			m.Options[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountPoint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerPath = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadOnly = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceVolume", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SourceVolume = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkBinding) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.BindIP = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ContainerPort = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.HostPort = &v2
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMapping) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.ContainerPort = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.HostPort = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.IntegerValue = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.LongValue = &v2
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringSetValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringSetValue = append(m.StringSetValue, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ClusterArn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentConfiguration == nil {
				m.DeploymentConfiguration = &DeploymentConfiguration{}
			}
			if err := m.DeploymentConfiguration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployments = append(m.Deployments, &Deployment{})
			if err := m.Deployments[len(m.Deployments)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.DesiredCount = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &ServiceEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancers = append(m.LoadBalancers, &LoadBalancer{})
			if err := m.LoadBalancers[len(m.LoadBalancers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.PendingCount = &v2
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.RoleArn = &s
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.RunningCount = &v2
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ServiceArn = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ServiceName = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskDefinition = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ClusterArn = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerInstanceArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ContainerInstanceArn = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DesiredStatus = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LastStatus = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Overrides == nil {
				m.Overrides = &TaskOverride{}
			}
			if err := m.Overrides.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &opsee_types.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StartedBy = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoppedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoppedAt == nil {
				m.StoppedAt = &opsee_types.Timestamp{}
			}
			if err := m.StoppedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoppedReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.StoppedReason = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskArn = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinitionArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskDefinitionArn = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskDefinition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerDefinitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerDefinitions = append(m.ContainerDefinitions, &ContainerDefinition{})
			if err := m.ContainerDefinitions[len(m.ContainerDefinitions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Family = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiresAttributes = append(m.RequiresAttributes, &Attribute{})
			if err := m.RequiresAttributes[len(m.RequiresAttributes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Revision = &v2
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Status = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskDefinitionArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TaskDefinitionArn = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, &Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskOverride) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerOverrides = append(m.ContainerOverrides, &ContainerOverride{})
			if err := m.ContainerOverrides[len(m.ContainerOverrides)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ulimit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ulimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ulimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardLimit", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.HardLimit = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftLimit", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.SoftLimit = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AgentHash = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AgentVersion = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DockerVersion = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &HostVolumeProperties{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeFrom) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadOnly = &b
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SourceContainer = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorTypes = []byte{
	// 2569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x19, 0xcb, 0x72, 0x1c, 0x49,
	0x31, 0xe6, 0xa1, 0x79, 0xd4, 0xcc, 0xe8, 0xd1, 0xb2, 0xe4, 0x5e, 0x79, 0x59, 0x9b, 0x86, 0xd8,
	0x30, 0x84, 0x91, 0x09, 0xad, 0x59, 0x8c, 0x97, 0x47, 0xc8, 0x96, 0x8c, 0x15, 0x96, 0xec, 0xa1,
	0x65, 0x9b, 0x0d, 0x4e, 0xdb, 0x9a, 0x2e, 0x8d, 0x3a, 0xd4, 0x8f, 0xa1, 0xaa, 0x5b, 0xf6, 0xdc,
	0x38, 0xc1, 0x0f, 0xf0, 0x05, 0x9c, 0xf6, 0x03, 0xf6, 0xc0, 0x89, 0x20, 0x82, 0x0b, 0x47, 0x7e,
	0x80, 0x08, 0xe0, 0x2b, 0x08, 0x0e, 0x04, 0x99, 0x55, 0xd5, 0xdd, 0xd5, 0x0f, 0x69, 0x64, 0xf6,
	0x30, 0x11, 0x53, 0x59, 0x99, 0x59, 0x95, 0x59, 0xf9, 0x6e, 0x32, 0x88, 0xe7, 0x33, 0xca, 0xb7,
	0x67, 0x2c, 0x8a, 0x23, 0x63, 0x14, 0xcd, 0x38, 0xa5, 0xdb, 0xce, 0x5b, 0xbe, 0x4d, 0x27, 0x7c,
	0xeb, 0x7b, 0x53, 0x2f, 0x3e, 0x4b, 0x4e, 0xb6, 0x27, 0x51, 0x70, 0x7f, 0x1a, 0x4d, 0xa3, 0xfb,
	0x02, 0xeb, 0x24, 0x39, 0x15, 0x2b, 0xb1, 0x10, 0xff, 0x24, 0xf5, 0xd6, 0xf7, 0x35, 0x74, 0xc1,
	0x28, 0xc7, 0x17, 0x4b, 0x49, 0x20, 0x8f, 0x90, 0x14, 0x8f, 0xae, 0x45, 0x21, 0x6e, 0x78, 0x3f,
	0xf6, 0x02, 0xca, 0x63, 0x27, 0x98, 0x49, 0x5a, 0xeb, 0x07, 0xa4, 0xbf, 0x1b, 0xc7, 0xcc, 0x3b,
	0x49, 0x62, 0x6a, 0x18, 0xa4, 0xfd, 0xc2, 0x09, 0xa8, 0xd9, 0xbc, 0xd3, 0xb8, 0xdb, 0xb7, 0xdb,
	0x21, 0xfc, 0x37, 0x6e, 0x90, 0xa5, 0x37, 0x8e, 0x9f, 0x50, 0xb3, 0x25, 0x80, 0x4b, 0x17, 0xb8,
	0xb0, 0xfe, 0xd3, 0x20, 0xfd, 0x27, 0x51, 0x18, 0x3b, 0x5e, 0x48, 0x99, 0x61, 0x91, 0x61, 0xb6,
	0xd8, 0x65, 0xa1, 0xa2, 0x1f, 0x4e, 0x34, 0x98, 0xb1, 0x45, 0x7a, 0xfb, 0xef, 0xbc, 0xf8, 0x49,
	0xe4, 0x4a, 0x56, 0x86, 0xdd, 0xa3, 0x6a, 0x6d, 0x7c, 0x44, 0xc8, 0xa1, 0xc3, 0xe3, 0xe3, 0xd8,
	0x89, 0x13, 0x6e, 0xb6, 0x05, 0x35, 0xf1, 0x33, 0x48, 0x76, 0xaf, 0x25, 0xed, 0x5e, 0x3f, 0x27,
	0x2b, 0x2f, 0x68, 0xfc, 0x36, 0x62, 0xe7, 0x8f, 0xbd, 0xd0, 0xf5, 0xc2, 0x29, 0x37, 0x3b, 0x77,
	0x5a, 0x77, 0x07, 0x3b, 0xdf, 0xd8, 0x2e, 0xa8, 0x7f, 0xbb, 0x88, 0x65, 0xaf, 0x84, 0x45, 0x2a,
	0x63, 0x93, 0x74, 0x6c, 0xea, 0xf0, 0x28, 0x34, 0xbb, 0x82, 0x7d, 0x87, 0x89, 0x95, 0x61, 0x92,
	0xee, 0x2b, 0x87, 0x9f, 0xa3, 0x3c, 0x3d, 0xb1, 0xd1, 0x8d, 0xe5, 0xd2, 0xfa, 0x5d, 0x9f, 0xac,
	0x67, 0xf2, 0xee, 0xd1, 0x53, 0x2f, 0xf4, 0x62, 0x4f, 0x52, 0x3c, 0x89, 0x82, 0xc0, 0x09, 0x5d,
	0xd0, 0x40, 0x0b, 0x29, 0x26, 0x72, 0x69, 0xac, 0x92, 0xd6, 0x93, 0x59, 0xa2, 0xe4, 0x6e, 0x4d,
	0x66, 0x89, 0x71, 0x8f, 0xac, 0xed, 0x79, 0xdc, 0x39, 0xf1, 0xa9, 0xba, 0x1f, 0xdc, 0x45, 0x48,
	0xde, 0xb3, 0xd7, 0xdc, 0xf2, 0x86, 0xf1, 0x5d, 0xb2, 0xba, 0x17, 0xf2, 0x63, 0xea, 0xb0, 0xc9,
	0xd9, 0x5e, 0x14, 0xc0, 0xc1, 0x1c, 0x94, 0x81, 0x47, 0xac, 0xba, 0x25, 0x38, 0x2a, 0x53, 0xe0,
	0xb2, 0x0b, 0xca, 0xa4, 0x4e, 0x40, 0x99, 0x6e, 0x06, 0x31, 0x3e, 0x27, 0xc3, 0xbd, 0x68, 0x72,
	0x4e, 0xd9, 0xa1, 0x73, 0x42, 0x7d, 0x0e, 0x52, 0xa3, 0xd6, 0x1e, 0x94, 0xb4, 0x56, 0x23, 0xdf,
	0xb6, 0x4e, 0xb6, 0x1f, 0xc6, 0x6c, 0x6e, 0x0f, 0x5d, 0x0d, 0x64, 0x3c, 0x20, 0x1b, 0x12, 0xe5,
	0x98, 0x4e, 0x12, 0xe6, 0xc5, 0xf3, 0x97, 0x33, 0xa4, 0xe3, 0xa0, 0x3f, 0xbc, 0xc4, 0x86, 0x5b,
	0xb7, 0x89, 0xf7, 0x15, 0xcc, 0xc6, 0x91, 0x17, 0xc6, 0x66, 0x5f, 0xde, 0x97, 0x66, 0x10, 0xe3,
	0x27, 0x64, 0xb0, 0x1f, 0x5e, 0x78, 0x2c, 0x0a, 0x03, 0x80, 0x9a, 0x44, 0x5c, 0xf7, 0x56, 0xe9,
	0xba, 0xcf, 0xe9, 0x5c, 0x58, 0xe9, 0xd8, 0xf1, 0x98, 0x3d, 0xa0, 0x39, 0xbe, 0xf1, 0x21, 0xe9,
	0xef, 0x73, 0x0e, 0xff, 0x3c, 0xc7, 0x37, 0x07, 0x42, 0xc1, 0x7d, 0x9a, 0x02, 0x8c, 0x87, 0x70,
	0xf8, 0xbb, 0x98, 0x39, 0xcf, 0x22, 0x1e, 0x73, 0x73, 0x28, 0x78, 0x9b, 0x25, 0xde, 0xb8, 0x27,
	0xc5, 0x25, 0x34, 0xc3, 0x45, 0x7b, 0xc6, 0x3f, 0x68, 0x8b, 0xe6, 0x48, 0xd8, 0x47, 0xef, 0x4c,
	0xad, 0xd1, 0x67, 0x0e, 0x02, 0x67, 0x4a, 0xcd, 0x65, 0xe9, 0x33, 0x1e, 0x2e, 0x10, 0x7a, 0xe8,
	0x85, 0xe7, 0xdc, 0x5c, 0x11, 0x32, 0x2e, 0xf9, 0xb8, 0x30, 0x9e, 0x93, 0xd5, 0xc3, 0x68, 0x0a,
	0xea, 0x3e, 0xf5, 0xa6, 0x09, 0x73, 0x50, 0x27, 0xe6, 0x2a, 0x90, 0x0d, 0x76, 0x6e, 0x97, 0xee,
	0x51, 0x46, 0xb3, 0x57, 0xfd, 0x12, 0x04, 0x6d, 0xf9, 0x88, 0x06, 0x11, 0x9b, 0x9b, 0x6b, 0xc2,
	0xd4, 0x3a, 0x81, 0x58, 0x19, 0x9f, 0x91, 0xc1, 0x51, 0x94, 0x84, 0xb1, 0xd0, 0x28, 0x37, 0x0d,
	0x21, 0xe7, 0x07, 0x25, 0xfe, 0x39, 0x86, 0x3d, 0x08, 0x72, 0xec, 0xcc, 0xfb, 0xd6, 0x35, 0xef,
	0xfb, 0x29, 0x19, 0x8e, 0x23, 0x16, 0x1f, 0x39, 0xb3, 0x99, 0x70, 0xbd, 0x1b, 0x82, 0xe3, 0x56,
	0x89, 0xa3, 0x86, 0x62, 0x0f, 0x67, 0x1a, 0x3e, 0x3e, 0xfa, 0x98, 0x79, 0x17, 0x9e, 0x4f, 0xa7,
	0xd4, 0x35, 0x37, 0xc4, 0xb3, 0x90, 0x59, 0x06, 0x31, 0x3e, 0x25, 0x9b, 0xe0, 0x94, 0x6e, 0x14,
	0xfa, 0x73, 0x3b, 0x8a, 0xe2, 0xa7, 0x00, 0xe6, 0x73, 0x1e, 0xd3, 0xc0, 0xdc, 0x14, 0xb8, 0x9b,
	0xac, 0x76, 0xd7, 0xb8, 0x4f, 0xba, 0xaf, 0x7d, 0x2f, 0xf0, 0x40, 0xc8, 0x9b, 0xe2, 0x4a, 0x1b,
	0xa5, 0x2b, 0xc9, 0x5d, 0xbb, 0x9b, 0x48, 0x2c, 0x14, 0xee, 0x35, 0xa7, 0xcc, 0x34, 0xa5, 0x70,
	0x09, 0xfc, 0x47, 0x6d, 0xbd, 0x89, 0xfc, 0x04, 0x02, 0xe5, 0x53, 0x16, 0x05, 0xe6, 0x07, 0xb5,
	0xda, 0x92, 0x18, 0x88, 0x60, 0x0f, 0x2e, 0x72, 0x6c, 0x74, 0xd5, 0x5f, 0x4a, 0xaf, 0xdd, 0xf3,
	0x18, 0x9d, 0xc4, 0xf8, 0x18, 0x5b, 0x82, 0xf9, 0xea, 0xdb, 0x12, 0x7c, 0xeb, 0x67, 0x10, 0x04,
	0xca, 0x3e, 0x85, 0xb1, 0xe2, 0x9c, 0xce, 0xcd, 0x86, 0xa0, 0xc1, 0xbf, 0x68, 0x38, 0x22, 0xea,
	0xaa, 0xb8, 0x2a, 0x17, 0x8f, 0x9a, 0x0f, 0x1b, 0xd6, 0x5f, 0xda, 0x64, 0x2d, 0xf3, 0xd4, 0x83,
	0x10, 0x02, 0x7b, 0x38, 0xa1, 0xc6, 0xc7, 0x64, 0x79, 0x77, 0x0a, 0x06, 0x0e, 0x3b, 0x21, 0x9c,
	0x44, 0x5d, 0x41, 0xd8, 0xb3, 0x97, 0x9d, 0x02, 0x14, 0x63, 0x90, 0xc0, 0x7b, 0x3d, 0x73, 0x9d,
	0x98, 0xaa, 0xe8, 0x2b, 0xc3, 0xfc, 0x9a, 0x53, 0xde, 0x40, 0x57, 0xc9, 0x32, 0x05, 0x06, 0xe9,
	0x3a, 0x57, 0xc9, 0x10, 0x6c, 0xe2, 0x64, 0xb8, 0xc6, 0x0e, 0xb9, 0x51, 0xb9, 0x24, 0x86, 0x55,
	0x19, 0xce, 0x6f, 0x4c, 0x6a, 0xf6, 0x8c, 0x6f, 0x93, 0xd1, 0xfe, 0x64, 0x27, 0x85, 0x1c, 0xb8,
	0x10, 0xc8, 0x10, 0x79, 0x44, 0x75, 0x20, 0x4a, 0x30, 0xa6, 0x22, 0x8e, 0x63, 0xa8, 0xe6, 0x4f,
	0xd0, 0x6a, 0x45, 0x18, 0x37, 0xec, 0xb5, 0x59, 0x79, 0xc3, 0x38, 0x20, 0xeb, 0x36, 0x9d, 0x7a,
	0x60, 0x28, 0x8c, 0xba, 0x36, 0xe5, 0x51, 0xc2, 0x26, 0x54, 0x46, 0xa7, 0xc1, 0xce, 0xcd, 0x92,
	0x28, 0xe9, 0xbe, 0xbd, 0xce, 0xaa, 0x34, 0x90, 0x7d, 0x0c, 0x9b, 0x62, 0xbc, 0x45, 0xd3, 0xce,
	0x38, 0xf5, 0xaf, 0xe6, 0x64, 0xb0, 0x0a, 0x09, 0x4a, 0x60, 0x27, 0x61, 0x58, 0x94, 0x80, 0x48,
	0x09, 0x58, 0x79, 0x03, 0xfd, 0x5b, 0x3d, 0xd3, 0x40, 0xe6, 0x2a, 0x2e, 0xdf, 0xe6, 0xc7, 0x60,
	0xb1, 0x10, 0xdb, 0x21, 0x04, 0x1c, 0x84, 0xa7, 0x11, 0xc4, 0xb1, 0x46, 0x8d, 0x37, 0x6a, 0x18,
	0x60, 0xb2, 0xf9, 0xc2, 0xfa, 0x4d, 0x43, 0xb3, 0xa2, 0x97, 0xb0, 0xc3, 0x3c, 0x48, 0xca, 0x97,
	0x67, 0xb3, 0x52, 0x44, 0x6e, 0xbd, 0x67, 0x44, 0x4e, 0xe3, 0x49, 0x3b, 0x8f, 0x27, 0xd6, 0x57,
	0x4d, 0xc8, 0x5a, 0x74, 0xe6, 0x47, 0x73, 0x81, 0xf2, 0x00, 0xaa, 0x0b, 0xf0, 0x70, 0x30, 0xd2,
	0xdd, 0x58, 0x18, 0xef, 0x60, 0x67, 0x53, 0xf1, 0x97, 0x85, 0xd6, 0xab, 0xb4, 0x8c, 0xb1, 0xfb,
	0x93, 0x14, 0x11, 0xcb, 0x90, 0x3d, 0xca, 0xc1, 0xbb, 0x5c, 0xa9, 0x46, 0x99, 0x6e, 0x87, 0xae,
	0x06, 0x33, 0x96, 0x49, 0x13, 0x8c, 0x49, 0x1e, 0xdd, 0xf4, 0x5c, 0xa4, 0x51, 0x16, 0x24, 0x69,
	0x96, 0x24, 0xcd, 0x4c, 0x83, 0x21, 0x8e, 0x7a, 0x23, 0x89, 0xd3, 0x91, 0x38, 0x4c, 0x83, 0x69,
	0x2f, 0xd3, 0x2d, 0xbc, 0x0c, 0xf8, 0x22, 0xbe, 0x5f, 0x9e, 0x45, 0x55, 0x31, 0xb1, 0x1c, 0x17,
	0xa0, 0x28, 0xb1, 0xf4, 0x36, 0x94, 0xb8, 0x7f, 0xb5, 0xc4, 0x49, 0x8a, 0x68, 0xbd, 0x25, 0x37,
	0x73, 0xad, 0x15, 0x53, 0x01, 0x1c, 0x7c, 0xe4, 0xbc, 0xf3, 0x82, 0x24, 0x18, 0x53, 0xb0, 0xb4,
	0x50, 0xea, 0xd1, 0xb0, 0x97, 0x83, 0x02, 0x14, 0x93, 0xf6, 0x11, 0x5c, 0x02, 0x20, 0xcf, 0xa8,
	0xe3, 0xc7, 0x67, 0xf3, 0x14, 0x5d, 0x6a, 0x6f, 0x23, 0xa8, 0xdb, 0xb4, 0xce, 0xc9, 0x6d, 0x50,
	0xf5, 0x04, 0x3c, 0x9c, 0x56, 0x5c, 0x9b, 0x1f, 0x84, 0xb3, 0x24, 0x16, 0xf6, 0xe3, 0x27, 0xe8,
	0x38, 0x2a, 0x6e, 0x75, 0x27, 0x72, 0x69, 0x6c, 0x13, 0xa3, 0x4a, 0x24, 0xcc, 0xa8, 0x6f, 0x1b,
	0x95, 0x68, 0xc0, 0xad, 0x2f, 0x1b, 0xe4, 0xce, 0xe5, 0xa7, 0xbd, 0x4c, 0x62, 0x3c, 0x6e, 0x5c,
	0xcb, 0xb4, 0x29, 0x6c, 0xf3, 0xce, 0x65, 0xc5, 0x4d, 0x8a, 0x58, 0x77, 0x2c, 0x84, 0xad, 0xde,
	0x53, 0xc7, 0xf3, 0x13, 0xa6, 0x2e, 0x97, 0xbf, 0x48, 0xca, 0x47, 0x6d, 0xdb, 0xbd, 0x53, 0x85,
	0x67, 0x1d, 0x41, 0x09, 0xa4, 0x6e, 0x8a, 0xf5, 0x96, 0x77, 0x0d, 0x6d, 0x40, 0x21, 0x91, 0xa2,
	0x2a, 0x1d, 0xf4, 0xb8, 0x5a, 0xa3, 0x67, 0x6e, 0x96, 0xf9, 0x29, 0x79, 0xf5, 0xdb, 0x35, 0xaf,
	0x77, 0x3b, 0xa4, 0x29, 0x1c, 0x55, 0xa5, 0x51, 0xdb, 0xda, 0x15, 0xf6, 0xc9, 0xad, 0xf4, 0x06,
	0x45, 0x43, 0x96, 0x72, 0x55, 0xed, 0xbb, 0x59, 0x67, 0xdf, 0x16, 0x25, 0x1f, 0xd6, 0xb3, 0x51,
	0xe2, 0xec, 0xd7, 0xf2, 0xa9, 0x56, 0xf3, 0x45, 0xa4, 0xca, 0x31, 0x7b, 0xc4, 0xd0, 0x8f, 0x59,
	0xa8, 0x7c, 0x48, 0xad, 0x02, 0x4f, 0x69, 0x7e, 0x09, 0xd9, 0x71, 0x2b, 0x26, 0xeb, 0x05, 0x2e,
	0x5f, 0x43, 0xe5, 0xdf, 0xd1, 0x0f, 0x18, 0xec, 0xac, 0xd7, 0x88, 0x93, 0x9e, 0xfa, 0x09, 0xe9,
	0x2a, 0x7a, 0xac, 0x01, 0xf2, 0x3e, 0xaa, 0xe5, 0xb0, 0x50, 0xeb, 0x52, 0x5a, 0x7a, 0x97, 0x02,
	0xcf, 0xd3, 0xcf, 0xea, 0xd3, 0x42, 0x4d, 0xda, 0x2c, 0xd5, 0xa4, 0x50, 0x07, 0x1f, 0xcc, 0x76,
	0x5d, 0x17, 0x2e, 0x95, 0x26, 0xf9, 0xbe, 0x97, 0x02, 0xac, 0x4f, 0xc9, 0x0d, 0xa4, 0x94, 0x45,
	0xcd, 0x98, 0x45, 0x33, 0xca, 0x62, 0x8f, 0x8a, 0x3a, 0xed, 0x58, 0x64, 0xaa, 0xb1, 0x13, 0x9f,
	0x29, 0x9e, 0x84, 0x67, 0x10, 0xeb, 0x21, 0x19, 0xea, 0x81, 0xfe, 0x3d, 0x3a, 0xc8, 0x5f, 0x90,
	0xb5, 0x43, 0x48, 0xab, 0xea, 0x5d, 0xd4, 0x43, 0xc1, 0x71, 0x10, 0xb4, 0x20, 0x3b, 0x26, 0x7e,
	0xcc, 0x55, 0xc0, 0x22, 0x41, 0x06, 0x41, 0x21, 0x5e, 0x40, 0x0d, 0xfe, 0x2a, 0x3a, 0xa7, 0xa9,
	0x22, 0xfa, 0x61, 0x0a, 0xb0, 0x5e, 0x11, 0x43, 0x67, 0xa9, 0x5e, 0xed, 0x0e, 0x19, 0x28, 0x08,
	0xa8, 0x94, 0xab, 0x5c, 0x36, 0x98, 0xe4, 0xa0, 0x05, 0x5c, 0x13, 0x72, 0x4b, 0x70, 0x7d, 0xef,
	0x30, 0x57, 0x14, 0xa6, 0x75, 0xb5, 0x30, 0xed, 0xf2, 0xb1, 0x8c, 0x7c, 0x58, 0x7f, 0xac, 0x12,
	0x0b, 0xe2, 0x76, 0x5d, 0x51, 0x95, 0x0a, 0xb8, 0x51, 0x57, 0x55, 0x2d, 0x12, 0xf5, 0x5c, 0xbe,
	0xc9, 0x75, 0x23, 0xd7, 0xd7, 0x13, 0x50, 0xbd, 0x56, 0x29, 0xac, 0x15, 0x68, 0x9a, 0x25, 0x1a,
	0x7c, 0x4b, 0x85, 0x2f, 0x44, 0x95, 0x4e, 0x3b, 0xe0, 0x39, 0xc8, 0xfa, 0x7d, 0x93, 0x2c, 0x23,
	0xdb, 0x6b, 0x79, 0xff, 0xbd, 0x9a, 0xea, 0x39, 0x2d, 0x80, 0x2b, 0xfa, 0xc3, 0x92, 0x54, 0x95,
	0x17, 0x85, 0x41, 0xc5, 0xc8, 0xd5, 0x81, 0xe8, 0xa8, 0x4f, 0x9d, 0xc0, 0xf3, 0xe7, 0xaa, 0xbc,
	0xed, 0x9c, 0x8a, 0x55, 0x49, 0x59, 0x9d, 0xab, 0x95, 0xd5, 0xbd, 0x5c, 0x70, 0xe1, 0x5e, 0xb2,
	0x86, 0x48, 0x05, 0x7f, 0xa1, 0xfc, 0x1b, 0x6e, 0xc0, 0xa0, 0x2e, 0x78, 0x3c, 0x17, 0x05, 0x04,
	0xd0, 0xf3, 0x14, 0x60, 0x3d, 0x27, 0x2b, 0x99, 0x56, 0xae, 0xa5, 0x69, 0x08, 0x25, 0x6a, 0xfa,
	0x91, 0x65, 0x25, 0x35, 0xfe, 0xe0, 0xd6, 0x6f, 0x1b, 0x64, 0x78, 0x18, 0x39, 0xee, 0x63, 0xc7,
	0x47, 0xc5, 0x30, 0xd4, 0x4c, 0xa6, 0x47, 0xcd, 0xfd, 0x47, 0x13, 0x1d, 0x58, 0xc0, 0xc2, 0xce,
	0x50, 0x59, 0x4c, 0x8e, 0x85, 0x40, 0xec, 0x9f, 0x74, 0xde, 0x5a, 0xa5, 0x08, 0xed, 0x6e, 0x11,
	0x6e, 0x7d, 0xd5, 0xa8, 0x36, 0xcf, 0x28, 0x17, 0xc0, 0xf6, 0xa0, 0x97, 0xcc, 0x1e, 0xbc, 0xef,
	0xa7, 0x00, 0xe3, 0x29, 0xe9, 0xa6, 0x53, 0x09, 0x19, 0x91, 0xef, 0x2d, 0xe8, 0xb2, 0xb7, 0x15,
	0xba, 0x9c, 0x00, 0x74, 0x23, 0xb9, 0xda, 0x7a, 0x44, 0x86, 0xfa, 0xc6, 0x7b, 0x75, 0x6d, 0x0c,
	0x4c, 0x21, 0xeb, 0xaf, 0x8b, 0x6a, 0xc9, 0xa3, 0xac, 0xa6, 0x16, 0x00, 0xe2, 0x7b, 0x60, 0x43,
	0xfc, 0x12, 0x5a, 0x5e, 0xa1, 0xb7, 0x9e, 0xdd, 0x63, 0x6a, 0x8d, 0xf5, 0xa9, 0x0c, 0xd2, 0x32,
	0x7c, 0x2b, 0x75, 0x0d, 0xb9, 0x06, 0xc3, 0x37, 0x5b, 0x2e, 0x4e, 0xc2, 0xd0, 0x52, 0xf1, 0xef,
	0xc1, 0x58, 0x9d, 0xd8, 0x39, 0x11, 0xab, 0x6b, 0xbe, 0x93, 0xca, 0x35, 0x02, 0xa1, 0x2d, 0xe7,
	0x79, 0x67, 0x6a, 0x8d, 0x7b, 0x63, 0x9c, 0x2e, 0x4e, 0x22, 0x5f, 0x79, 0x41, 0x6f, 0xa6, 0xd6,
	0x10, 0x63, 0x06, 0xda, 0x58, 0xa0, 0x7a, 0x58, 0x73, 0xd1, 0x61, 0xad, 0x2b, 0x0e, 0x6b, 0x97,
	0x0e, 0xfb, 0x53, 0x03, 0xd5, 0x26, 0x15, 0x81, 0x3e, 0xb4, 0x17, 0x25, 0x27, 0x3e, 0x7d, 0x93,
	0x3d, 0x4b, 0xc3, 0x1e, 0xb8, 0x39, 0x08, 0x15, 0x79, 0x10, 0xc6, 0x74, 0x4a, 0x59, 0x9e, 0xb0,
	0xa0, 0xd0, 0xf7, 0x34, 0x98, 0x34, 0xaf, 0x70, 0x2a, 0x11, 0xa4, 0xe0, 0x60, 0x5e, 0x0a, 0x50,
	0x3b, 0xa9, 0x84, 0x12, 0xe9, 0x18, 0x7a, 0xe1, 0x70, 0x7a, 0x4c, 0x63, 0x49, 0x26, 0x87, 0x72,
	0xcb, 0xbc, 0x00, 0x45, 0xda, 0x57, 0x50, 0xea, 0x2b, 0xe7, 0x6f, 0x63, 0xd9, 0x6f, 0xfd, 0xb7,
	0x4d, 0xba, 0xca, 0xf1, 0x31, 0x82, 0xe4, 0x89, 0x2c, 0xcd, 0xc5, 0x79, 0x1e, 0x2b, 0x36, 0x4d,
	0xad, 0xeb, 0x36, 0x4d, 0x5f, 0x5c, 0xda, 0x42, 0x08, 0xe9, 0x06, 0x3b, 0x1f, 0x97, 0x1c, 0xe4,
	0x12, 0x6c, 0xfb, 0xa6, 0x7b, 0x49, 0x27, 0xf2, 0x19, 0xe8, 0x3d, 0xdb, 0x92, 0x73, 0xcb, 0xea,
	0x38, 0x25, 0xc7, 0x80, 0x27, 0xc9, 0xb1, 0x2b, 0x3d, 0x5d, 0xa7, 0xa6, 0xa7, 0xfb, 0x84, 0x74,
	0xf6, 0x2f, 0x04, 0xef, 0x6e, 0x6d, 0x2b, 0xaa, 0x14, 0x28, 0x70, 0xec, 0x0e, 0x15, 0xa8, 0xc6,
	0x2e, 0x19, 0xe9, 0x71, 0x26, 0x1d, 0x03, 0xdc, 0xaa, 0x84, 0x83, 0x1c, 0xc7, 0x1e, 0xe9, 0x11,
	0x88, 0x57, 0x7a, 0xc7, 0x7e, 0x4d, 0xef, 0x08, 0xc9, 0xc7, 0x8e, 0x7c, 0x31, 0xee, 0x20, 0x32,
	0xf9, 0x30, 0xb9, 0xac, 0x74, 0x95, 0x83, 0x9a, 0xae, 0x12, 0xcb, 0xaf, 0x2c, 0xb9, 0x89, 0xb6,
	0x1e, 0xcb, 0xaf, 0x0c, 0x52, 0x4e, 0x0b, 0xa3, 0x6a, 0x5a, 0xc8, 0xfb, 0xd2, 0xe5, 0x05, 0x7d,
	0xe9, 0x4a, 0x6d, 0xdd, 0x1e, 0x42, 0x6c, 0xd1, 0xd4, 0xf7, 0x7f, 0x76, 0xe6, 0xb2, 0xeb, 0x6e,
	0x65, 0x5d, 0x37, 0x68, 0xe5, 0x08, 0xca, 0x4e, 0x1c, 0x91, 0x4a, 0x97, 0xed, 0x06, 0x72, 0x89,
	0x13, 0xad, 0x36, 0x5e, 0x6c, 0xa1, 0xb5, 0x5f, 0x36, 0x54, 0x6a, 0x5d, 0x31, 0x54, 0x7a, 0x08,
	0x3c, 0x53, 0xf8, 0x65, 0x23, 0xac, 0x0c, 0x01, 0x4e, 0xcb, 0x70, 0x8b, 0x62, 0x2f, 0x5d, 0x57,
	0xec, 0x4a, 0xc5, 0xd0, 0xa9, 0xab, 0x18, 0x8a, 0x5f, 0x3f, 0xba, 0x95, 0xaf, 0x1f, 0x3f, 0x22,
	0xfd, 0x74, 0x28, 0xc3, 0x45, 0xe6, 0xaf, 0x5a, 0x29, 0x6a, 0x2c, 0xc5, 0xb1, 0xfb, 0x51, 0x8a,
	0x8d, 0xd7, 0x56, 0x45, 0xc1, 0xe2, 0xa9, 0x02, 0x4f, 0x11, 0x8b, 0xa5, 0x04, 0x29, 0x95, 0x12,
	0x92, 0x67, 0x34, 0x9b, 0x09, 0x9e, 0x83, 0x45, 0x3c, 0x15, 0x22, 0xaa, 0x42, 0x51, 0xa9, 0x36,
	0x46, 0x1a, 0xf3, 0x88, 0xeb, 0x40, 0xfd, 0x9b, 0xcb, 0xa8, 0xf0, 0xcd, 0x05, 0x4b, 0xb5, 0xa2,
	0xbd, 0x22, 0x8e, 0x34, 0xe9, 0xb5, 0xb8, 0xbc, 0x61, 0xfd, 0xbd, 0x59, 0x36, 0x6f, 0xe3, 0x8d,
	0x66, 0x2f, 0x39, 0x38, 0x6d, 0xe4, 0xac, 0xc5, 0x9f, 0x3f, 0x34, 0x9b, 0xd2, 0xe8, 0xb5, 0x7a,
	0xaf, 0x55, 0xa8, 0xf7, 0x9e, 0xe1, 0x84, 0xf0, 0xd7, 0x09, 0xbc, 0x33, 0x7f, 0x8f, 0xb1, 0xa9,
	0xc1, 0x2a, 0x34, 0x32, 0xf5, 0x5f, 0x78, 0x38, 0xae, 0x53, 0xe3, 0x29, 0x48, 0xfd, 0x72, 0xad,
	0xb9, 0x77, 0xa7, 0xe0, 0xde, 0xb5, 0xea, 0xea, 0x5e, 0xa2, 0x2e, 0x9c, 0x9a, 0xab, 0x81, 0xb7,
	0x8a, 0x82, 0x1b, 0xb5, 0xc3, 0x6e, 0xbb, 0xab, 0x06, 0xdd, 0xd6, 0x17, 0x64, 0xa8, 0x9b, 0x5c,
	0x61, 0xf8, 0x92, 0xdb, 0xea, 0x82, 0xe1, 0x4b, 0x66, 0xb0, 0xf9, 0xf0, 0x25, 0xa3, 0xb5, 0x3e,
	0x27, 0x1d, 0x39, 0xaa, 0x47, 0x6b, 0x7c, 0xe6, 0x30, 0xf7, 0x10, 0x17, 0xaa, 0x3a, 0xe8, 0x9f,
	0xa5, 0x80, 0x2c, 0xe1, 0xb6, 0xb4, 0x84, 0x8b, 0xf6, 0x1b, 0x9d, 0xc6, 0x92, 0x42, 0xa5, 0x68,
	0x9e, 0x02, 0xa0, 0x9f, 0xd3, 0x67, 0xa5, 0x88, 0x2c, 0x86, 0xe0, 0xcf, 0x1c, 0x9e, 0x96, 0x5e,
	0x7d, 0x27, 0x05, 0x60, 0x90, 0x16, 0xbb, 0x8a, 0x42, 0x1d, 0x33, 0x74, 0x34, 0x98, 0xf0, 0x72,
	0x31, 0xc5, 0x4f, 0x91, 0xd2, 0xbe, 0x40, 0x07, 0x5a, 0xaf, 0x49, 0x47, 0x6a, 0xd1, 0xf8, 0x21,
	0x69, 0x63, 0x31, 0xa3, 0xa2, 0xe7, 0xb7, 0x6a, 0xbe, 0x36, 0x95, 0xdb, 0x70, 0xbb, 0x8d, 0xd5,
	0x4e, 0x9d, 0xac, 0x96, 0x4d, 0x48, 0xfe, 0x25, 0xa2, 0x50, 0x25, 0x36, 0x4b, 0x55, 0xe2, 0x5d,
	0xb2, 0x22, 0xab, 0xc4, 0xec, 0x01, 0x14, 0xa3, 0x15, 0x5e, 0x04, 0x3f, 0xfe, 0xe6, 0xbf, 0xff,
	0xf9, 0x51, 0xe3, 0xcb, 0x7f, 0x7d, 0xd4, 0xf8, 0x23, 0xfc, 0xfe, 0x0a, 0xbf, 0xbf, 0xc1, 0xef,
	0x1f, 0xf0, 0xfb, 0xf3, 0x1f, 0x6e, 0x37, 0x7e, 0xd5, 0x82, 0x5b, 0xfe, 0x2f, 0x00, 0x00, 0xff,
	0xff, 0x0d, 0x51, 0xf6, 0x00, 0xf0, 0x1e, 0x00, 0x00,
}
