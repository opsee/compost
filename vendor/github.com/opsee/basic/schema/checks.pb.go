// Code generated by protoc-gen-gogo.
// source: checks.proto
// DO NOT EDIT!

/*
	Package schema is a generated protocol buffer package.

	It is generated from these files:
		checks.proto
		region.proto
		stack.proto
		user.proto

	It has these top-level messages:
		Target
		Check
		Notification
		Assertion
		Header
		HttpCheck
		CloudWatchCheck
		CloudWatchMetric
		CloudWatchResponse
		Tag
		Metric
		HttpResponse
		CheckResponse
		CheckResult
		Region
		Vpc
		Subnet
		BastionState
		Stack
		RoleStack
		User
		Customer
*/
package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import opsee_types "github.com/opsee/protobuf/opseeproto/types"
import opsee_types1 "github.com/opsee/protobuf/opseeproto/types"
import opsee_types2 "github.com/opsee/protobuf/opseeproto/types"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/opsee/protobuf/opseeproto"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"
import github_com_opsee_protobuf_plugin_graphql_scalars "github.com/opsee/protobuf/plugin/graphql/scalars"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Target struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Id      string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{0} }

type Check struct {
	Id         string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Interval   int32                  `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Target     *Target                `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	LastRun    *opsee_types.Timestamp `protobuf:"bytes,4,opt,name=last_run,json=lastRun" json:"last_run,omitempty"`
	CheckSpec  *opsee_types1.Any      `protobuf:"bytes,5,opt,name=check_spec,json=checkSpec" json:"check_spec,omitempty"`
	Name       string                 `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Assertions []*Assertion           `protobuf:"bytes,7,rep,name=assertions" json:"assertions,omitempty"`
	Results    []*CheckResult         `protobuf:"bytes,8,rep,name=results" json:"results,omitempty"`
	// Types that are valid to be assigned to Spec:
	//	*Check_HttpCheck
	//	*Check_CloudwatchCheck
	Spec          isCheck_Spec    `protobuf_oneof:"spec"`
	Notifications []*Notification `protobuf:"bytes,9,rep,name=notifications" json:"notifications,omitempty"`
}

func (m *Check) Reset()                    { *m = Check{} }
func (m *Check) String() string            { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()               {}
func (*Check) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{1} }

type isCheck_Spec interface {
	isCheck_Spec()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Check_HttpCheck struct {
	HttpCheck *HttpCheck `protobuf:"bytes,101,opt,name=http_check,json=httpCheck,oneof"`
}
type Check_CloudwatchCheck struct {
	CloudwatchCheck *CloudWatchCheck `protobuf:"bytes,102,opt,name=cloudwatch_check,json=cloudwatchCheck,oneof"`
}

func (*Check_HttpCheck) isCheck_Spec()       {}
func (*Check_CloudwatchCheck) isCheck_Spec() {}

func (m *Check) GetSpec() isCheck_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Check) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Check) GetLastRun() *opsee_types.Timestamp {
	if m != nil {
		return m.LastRun
	}
	return nil
}

func (m *Check) GetCheckSpec() *opsee_types1.Any {
	if m != nil {
		return m.CheckSpec
	}
	return nil
}

func (m *Check) GetAssertions() []*Assertion {
	if m != nil {
		return m.Assertions
	}
	return nil
}

func (m *Check) GetResults() []*CheckResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *Check) GetHttpCheck() *HttpCheck {
	if x, ok := m.GetSpec().(*Check_HttpCheck); ok {
		return x.HttpCheck
	}
	return nil
}

func (m *Check) GetCloudwatchCheck() *CloudWatchCheck {
	if x, ok := m.GetSpec().(*Check_CloudwatchCheck); ok {
		return x.CloudwatchCheck
	}
	return nil
}

func (m *Check) GetNotifications() []*Notification {
	if m != nil {
		return m.Notifications
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Check) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Check_OneofMarshaler, _Check_OneofUnmarshaler, _Check_OneofSizer, []interface{}{
		(*Check_HttpCheck)(nil),
		(*Check_CloudwatchCheck)(nil),
	}
}

func _Check_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Check)
	// spec
	switch x := m.Spec.(type) {
	case *Check_HttpCheck:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpCheck); err != nil {
			return err
		}
	case *Check_CloudwatchCheck:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudwatchCheck); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Check.Spec has unexpected type %T", x)
	}
	return nil
}

func _Check_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Check)
	switch tag {
	case 101: // spec.http_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpCheck)
		err := b.DecodeMessage(msg)
		m.Spec = &Check_HttpCheck{msg}
		return true, err
	case 102: // spec.cloudwatch_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudWatchCheck)
		err := b.DecodeMessage(msg)
		m.Spec = &Check_CloudwatchCheck{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Check_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Check)
	// spec
	switch x := m.Spec.(type) {
	case *Check_HttpCheck:
		s := proto.Size(x.HttpCheck)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Check_CloudwatchCheck:
		s := proto.Size(x.CloudwatchCheck)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Notification struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{2} }

type Assertion struct {
	// key is one of "code", "header", "body".
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// In the case of key=header, value would be the header field.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// relationship is one of: "equal" "notEqual" "empty" "notEmpty" "contain" "notContain" "regExp"
	Relationship string `protobuf:"bytes,3,opt,name=relationship,proto3" json:"relationship,omitempty"`
	Operand      string `protobuf:"bytes,4,opt,name=operand,proto3" json:"operand,omitempty"`
}

func (m *Assertion) Reset()                    { *m = Assertion{} }
func (m *Assertion) String() string            { return proto.CompactTextString(m) }
func (*Assertion) ProtoMessage()               {}
func (*Assertion) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{3} }

type Header struct {
	Name   string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Values []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{4} }

type HttpCheck struct {
	Name     string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Path     string    `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Protocol string    `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port     int32     `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Verb     string    `protobuf:"bytes,5,opt,name=verb,proto3" json:"verb,omitempty"`
	Headers  []*Header `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	Body     string    `protobuf:"bytes,7,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *HttpCheck) Reset()                    { *m = HttpCheck{} }
func (m *HttpCheck) String() string            { return proto.CompactTextString(m) }
func (*HttpCheck) ProtoMessage()               {}
func (*HttpCheck) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{5} }

func (m *HttpCheck) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

type CloudWatchCheck struct {
	Metrics []*CloudWatchMetric `protobuf:"bytes,1,rep,name=metrics" json:"metrics,omitempty"`
}

func (m *CloudWatchCheck) Reset()                    { *m = CloudWatchCheck{} }
func (m *CloudWatchCheck) String() string            { return proto.CompactTextString(m) }
func (*CloudWatchCheck) ProtoMessage()               {}
func (*CloudWatchCheck) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{6} }

func (m *CloudWatchCheck) GetMetrics() []*CloudWatchMetric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type CloudWatchMetric struct {
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CloudWatchMetric) Reset()                    { *m = CloudWatchMetric{} }
func (m *CloudWatchMetric) String() string            { return proto.CompactTextString(m) }
func (*CloudWatchMetric) ProtoMessage()               {}
func (*CloudWatchMetric) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{7} }

type CloudWatchResponse struct {
	// The AWS CloudWatch metric namespace, e.g. AWS/RDS
	Namespace string                `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Metrics   []*Metric             `protobuf:"bytes,2,rep,name=metrics" json:"metrics,omitempty"`
	Errors    []*opsee_types2.Error `protobuf:"bytes,3,rep,name=errors" json:"errors,omitempty"`
}

func (m *CloudWatchResponse) Reset()                    { *m = CloudWatchResponse{} }
func (m *CloudWatchResponse) String() string            { return proto.CompactTextString(m) }
func (*CloudWatchResponse) ProtoMessage()               {}
func (*CloudWatchResponse) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{8} }

func (m *CloudWatchResponse) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *CloudWatchResponse) GetErrors() []*opsee_types2.Error {
	if m != nil {
		return m.Errors
	}
	return nil
}

type Tag struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{9} }

type Metric struct {
	Name      string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value     float64                `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	Tags      []*Tag                 `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	Timestamp *opsee_types.Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	Unit      string                 `protobuf:"bytes,5,opt,name=unit,proto3" json:"unit,omitempty"`
	Statistic string                 `protobuf:"bytes,6,opt,name=statistic,proto3" json:"statistic,omitempty"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (m *Metric) String() string            { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{10} }

func (m *Metric) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Metric) GetTimestamp() *opsee_types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type HttpResponse struct {
	Code    int32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Body    string    `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	Headers []*Header `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty"`
	Metrics []*Metric `protobuf:"bytes,4,rep,name=metrics" json:"metrics,omitempty"`
	Host    string    `protobuf:"bytes,5,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *HttpResponse) Reset()                    { *m = HttpResponse{} }
func (m *HttpResponse) String() string            { return proto.CompactTextString(m) }
func (*HttpResponse) ProtoMessage()               {}
func (*HttpResponse) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{11} }

func (m *HttpResponse) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HttpResponse) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type CheckResponse struct {
	Target   *Target           `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	Response *opsee_types1.Any `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
	Error    string            `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Passing  bool              `protobuf:"varint,4,opt,name=passing,proto3" json:"passing,omitempty"`
	// Types that are valid to be assigned to Reply:
	//	*CheckResponse_HttpResponse
	//	*CheckResponse_CloudwatchResponse
	Reply isCheckResponse_Reply `protobuf_oneof:"reply"`
}

func (m *CheckResponse) Reset()                    { *m = CheckResponse{} }
func (m *CheckResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckResponse) ProtoMessage()               {}
func (*CheckResponse) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{12} }

type isCheckResponse_Reply interface {
	isCheckResponse_Reply()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CheckResponse_HttpResponse struct {
	HttpResponse *HttpResponse `protobuf:"bytes,101,opt,name=http_response,json=httpResponse,oneof"`
}
type CheckResponse_CloudwatchResponse struct {
	CloudwatchResponse *CloudWatchResponse `protobuf:"bytes,102,opt,name=cloudwatch_response,json=cloudwatchResponse,oneof"`
}

func (*CheckResponse_HttpResponse) isCheckResponse_Reply()       {}
func (*CheckResponse_CloudwatchResponse) isCheckResponse_Reply() {}

func (m *CheckResponse) GetReply() isCheckResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *CheckResponse) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *CheckResponse) GetResponse() *opsee_types1.Any {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *CheckResponse) GetHttpResponse() *HttpResponse {
	if x, ok := m.GetReply().(*CheckResponse_HttpResponse); ok {
		return x.HttpResponse
	}
	return nil
}

func (m *CheckResponse) GetCloudwatchResponse() *CloudWatchResponse {
	if x, ok := m.GetReply().(*CheckResponse_CloudwatchResponse); ok {
		return x.CloudwatchResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CheckResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CheckResponse_OneofMarshaler, _CheckResponse_OneofUnmarshaler, _CheckResponse_OneofSizer, []interface{}{
		(*CheckResponse_HttpResponse)(nil),
		(*CheckResponse_CloudwatchResponse)(nil),
	}
}

func _CheckResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CheckResponse)
	// reply
	switch x := m.Reply.(type) {
	case *CheckResponse_HttpResponse:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpResponse); err != nil {
			return err
		}
	case *CheckResponse_CloudwatchResponse:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudwatchResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CheckResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _CheckResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CheckResponse)
	switch tag {
	case 101: // reply.http_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpResponse)
		err := b.DecodeMessage(msg)
		m.Reply = &CheckResponse_HttpResponse{msg}
		return true, err
	case 102: // reply.cloudwatch_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudWatchResponse)
		err := b.DecodeMessage(msg)
		m.Reply = &CheckResponse_CloudwatchResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CheckResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CheckResponse)
	// reply
	switch x := m.Reply.(type) {
	case *CheckResponse_HttpResponse:
		s := proto.Size(x.HttpResponse)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CheckResponse_CloudwatchResponse:
		s := proto.Size(x.CloudwatchResponse)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CheckResult struct {
	CheckId    string                 `protobuf:"bytes,1,opt,name=check_id,json=checkId,proto3" json:"check_id,omitempty"`
	CustomerId string                 `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	Timestamp  *opsee_types.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Passing    bool                   `protobuf:"varint,4,opt,name=passing,proto3" json:"passing,omitempty"`
	Responses  []*CheckResponse       `protobuf:"bytes,5,rep,name=responses" json:"responses,omitempty"`
	Target     *Target                `protobuf:"bytes,6,opt,name=target" json:"target,omitempty"`
	CheckName  string                 `protobuf:"bytes,7,opt,name=check_name,json=checkName,proto3" json:"check_name,omitempty"`
	Version    int32                  `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *CheckResult) Reset()                    { *m = CheckResult{} }
func (m *CheckResult) String() string            { return proto.CompactTextString(m) }
func (*CheckResult) ProtoMessage()               {}
func (*CheckResult) Descriptor() ([]byte, []int) { return fileDescriptorChecks, []int{13} }

func (m *CheckResult) GetTimestamp() *opsee_types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *CheckResult) GetResponses() []*CheckResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *CheckResult) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterType((*Target)(nil), "opsee.Target")
	proto.RegisterType((*Check)(nil), "opsee.Check")
	proto.RegisterType((*Notification)(nil), "opsee.Notification")
	proto.RegisterType((*Assertion)(nil), "opsee.Assertion")
	proto.RegisterType((*Header)(nil), "opsee.Header")
	proto.RegisterType((*HttpCheck)(nil), "opsee.HttpCheck")
	proto.RegisterType((*CloudWatchCheck)(nil), "opsee.CloudWatchCheck")
	proto.RegisterType((*CloudWatchMetric)(nil), "opsee.CloudWatchMetric")
	proto.RegisterType((*CloudWatchResponse)(nil), "opsee.CloudWatchResponse")
	proto.RegisterType((*Tag)(nil), "opsee.Tag")
	proto.RegisterType((*Metric)(nil), "opsee.Metric")
	proto.RegisterType((*HttpResponse)(nil), "opsee.HttpResponse")
	proto.RegisterType((*CheckResponse)(nil), "opsee.CheckResponse")
	proto.RegisterType((*CheckResult)(nil), "opsee.CheckResult")
}
func (this *Target) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Target)
	if !ok {
		that2, ok := that.(Target)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *Check) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.LastRun.Equal(that1.LastRun) {
		return false
	}
	if !this.CheckSpec.Equal(that1.CheckSpec) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if !this.Assertions[i].Equal(that1.Assertions[i]) {
			return false
		}
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if that1.Spec == nil {
		if this.Spec != nil {
			return false
		}
	} else if this.Spec == nil {
		return false
	} else if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if len(this.Notifications) != len(that1.Notifications) {
		return false
	}
	for i := range this.Notifications {
		if !this.Notifications[i].Equal(that1.Notifications[i]) {
			return false
		}
	}
	return true
}
func (this *Check_HttpCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check_HttpCheck)
	if !ok {
		that2, ok := that.(Check_HttpCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HttpCheck.Equal(that1.HttpCheck) {
		return false
	}
	return true
}
func (this *Check_CloudwatchCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check_CloudwatchCheck)
	if !ok {
		that2, ok := that.(Check_CloudwatchCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CloudwatchCheck.Equal(that1.CloudwatchCheck) {
		return false
	}
	return true
}
func (this *Notification) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Notification)
	if !ok {
		that2, ok := that.(Notification)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Assertion) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Assertion)
	if !ok {
		that2, ok := that.(Assertion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Relationship != that1.Relationship {
		return false
	}
	if this.Operand != that1.Operand {
		return false
	}
	return true
}
func (this *Header) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Header)
	if !ok {
		that2, ok := that.(Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *HttpCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HttpCheck)
	if !ok {
		that2, ok := that.(HttpCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Verb != that1.Verb {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if this.Body != that1.Body {
		return false
	}
	return true
}
func (this *CloudWatchCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CloudWatchCheck)
	if !ok {
		that2, ok := that.(CloudWatchCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return false
	}
	for i := range this.Metrics {
		if !this.Metrics[i].Equal(that1.Metrics[i]) {
			return false
		}
	}
	return true
}
func (this *CloudWatchMetric) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CloudWatchMetric)
	if !ok {
		that2, ok := that.(CloudWatchMetric)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *CloudWatchResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CloudWatchResponse)
	if !ok {
		that2, ok := that.(CloudWatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return false
	}
	for i := range this.Metrics {
		if !this.Metrics[i].Equal(that1.Metrics[i]) {
			return false
		}
	}
	if len(this.Errors) != len(that1.Errors) {
		return false
	}
	for i := range this.Errors {
		if !this.Errors[i].Equal(that1.Errors[i]) {
			return false
		}
	}
	return true
}
func (this *Tag) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Tag)
	if !ok {
		that2, ok := that.(Tag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Metric) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Metric)
	if !ok {
		that2, ok := that.(Metric)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if !this.Tags[i].Equal(that1.Tags[i]) {
			return false
		}
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if this.Statistic != that1.Statistic {
		return false
	}
	return true
}
func (this *HttpResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HttpResponse)
	if !ok {
		that2, ok := that.(HttpResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return false
	}
	for i := range this.Metrics {
		if !this.Metrics[i].Equal(that1.Metrics[i]) {
			return false
		}
	}
	if this.Host != that1.Host {
		return false
	}
	return true
}
func (this *CheckResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse)
	if !ok {
		that2, ok := that.(CheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if this.Passing != that1.Passing {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *CheckResponse_HttpResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse_HttpResponse)
	if !ok {
		that2, ok := that.(CheckResponse_HttpResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HttpResponse.Equal(that1.HttpResponse) {
		return false
	}
	return true
}
func (this *CheckResponse_CloudwatchResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse_CloudwatchResponse)
	if !ok {
		that2, ok := that.(CheckResponse_CloudwatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CloudwatchResponse.Equal(that1.CloudwatchResponse) {
		return false
	}
	return true
}
func (this *CheckResult) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResult)
	if !ok {
		that2, ok := that.(CheckResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CheckId != that1.CheckId {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.Passing != that1.Passing {
		return false
	}
	if len(this.Responses) != len(that1.Responses) {
		return false
	}
	for i := range this.Responses {
		if !this.Responses[i].Equal(that1.Responses[i]) {
			return false
		}
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if this.CheckName != that1.CheckName {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}

type TargetGetter interface {
	GetTarget() *Target
}

var GraphQLTargetType *github_com_graphql_go_graphql.Object

type CheckGetter interface {
	GetCheck() *Check
}

var GraphQLCheckType *github_com_graphql_go_graphql.Object
var GraphQLCheckSpecUnion *github_com_graphql_go_graphql.Union

type NotificationGetter interface {
	GetNotification() *Notification
}

var GraphQLNotificationType *github_com_graphql_go_graphql.Object

type AssertionGetter interface {
	GetAssertion() *Assertion
}

var GraphQLAssertionType *github_com_graphql_go_graphql.Object

type HeaderGetter interface {
	GetHeader() *Header
}

var GraphQLHeaderType *github_com_graphql_go_graphql.Object

type HttpCheckGetter interface {
	GetHttpCheck() *HttpCheck
}

var GraphQLHttpCheckType *github_com_graphql_go_graphql.Object

type CloudWatchCheckGetter interface {
	GetCloudWatchCheck() *CloudWatchCheck
}

var GraphQLCloudWatchCheckType *github_com_graphql_go_graphql.Object

type CloudWatchMetricGetter interface {
	GetCloudWatchMetric() *CloudWatchMetric
}

var GraphQLCloudWatchMetricType *github_com_graphql_go_graphql.Object

type CloudWatchResponseGetter interface {
	GetCloudWatchResponse() *CloudWatchResponse
}

var GraphQLCloudWatchResponseType *github_com_graphql_go_graphql.Object

type TagGetter interface {
	GetTag() *Tag
}

var GraphQLTagType *github_com_graphql_go_graphql.Object

type MetricGetter interface {
	GetMetric() *Metric
}

var GraphQLMetricType *github_com_graphql_go_graphql.Object

type HttpResponseGetter interface {
	GetHttpResponse() *HttpResponse
}

var GraphQLHttpResponseType *github_com_graphql_go_graphql.Object

type CheckResponseGetter interface {
	GetCheckResponse() *CheckResponse
}

var GraphQLCheckResponseType *github_com_graphql_go_graphql.Object
var GraphQLCheckResponseReplyUnion *github_com_graphql_go_graphql.Union

type CheckResultGetter interface {
	GetCheckResult() *CheckResult
}

var GraphQLCheckResultType *github_com_graphql_go_graphql.Object

func (g *Check_HttpCheck) GetHttpCheck() *HttpCheck {
	return g.HttpCheck
}
func (g *Check_CloudwatchCheck) GetCloudWatchCheck() *CloudWatchCheck {
	return g.CloudwatchCheck
}
func (g *CheckResponse_HttpResponse) GetHttpResponse() *HttpResponse {
	return g.HttpResponse
}
func (g *CheckResponse_CloudwatchResponse) GetCloudWatchResponse() *CloudWatchResponse {
	return g.CloudwatchResponse
}

func init() {
	GraphQLTargetType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaTarget",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Type, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Type, nil
						}
						return nil, fmt.Errorf("field type not resolved")
					},
				},
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"address": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Address, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Address, nil
						}
						return nil, fmt.Errorf("field address not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"interval": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Interval, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Interval, nil
						}
						return nil, fmt.Errorf("field interval not resolved")
					},
				},
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"last_run": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.LastRun == nil {
								return nil, nil
							}
							return obj.GetLastRun(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.LastRun == nil {
								return nil, nil
							}
							return face.GetLastRun(), nil
						}
						return nil, fmt.Errorf("field last_run not resolved")
					},
				},
				"check_spec": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Any,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.CheckSpec == nil {
								return nil, nil
							}
							return obj.GetCheckSpec(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.CheckSpec == nil {
								return nil, nil
							}
							return face.GetCheckSpec(), nil
						}
						return nil, fmt.Errorf("field check_spec not resolved")
					},
				},
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"assertions": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLAssertionType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Assertions, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Assertions, nil
						}
						return nil, fmt.Errorf("field assertions not resolved")
					},
				},
				"results": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLCheckResultType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Results, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Results, nil
						}
						return nil, fmt.Errorf("field results not resolved")
					},
				},
				"notifications": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLNotificationType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Notifications, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Notifications, nil
						}
						return nil, fmt.Errorf("field notifications not resolved")
					},
				},
				"spec": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLCheckSpecUnion,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if !ok {
							return nil, fmt.Errorf("field spec not resolved")
						}
						return obj.GetSpec(), nil
					},
				},
			}
		}),
	})
	GraphQLNotificationType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaNotification",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Notification)
						if ok {
							return obj.Type, nil
						}
						inter, ok := p.Source.(NotificationGetter)
						if ok {
							face := inter.GetNotification()
							if face == nil {
								return nil, nil
							}
							return face.Type, nil
						}
						return nil, fmt.Errorf("field type not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Notification)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(NotificationGetter)
						if ok {
							face := inter.GetNotification()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
			}
		}),
	})
	GraphQLAssertionType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaAssertion",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"key": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "key is one of \"code\", \"header\", \"body\".",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Key, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Key, nil
						}
						return nil, fmt.Errorf("field key not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "In the case of key=header, value would be the header field.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
				"relationship": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "relationship is one of: \"equal\" \"notEqual\" \"empty\" \"notEmpty\" \"contain\" \"notContain\" \"regExp\"",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Relationship, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Relationship, nil
						}
						return nil, fmt.Errorf("field relationship not resolved")
					},
				},
				"operand": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Operand, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Operand, nil
						}
						return nil, fmt.Errorf("field operand not resolved")
					},
				},
			}
		}),
	})
	GraphQLHeaderType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHeader",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Header)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(HeaderGetter)
						if ok {
							face := inter.GetHeader()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"values": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Header)
						if ok {
							return obj.Values, nil
						}
						inter, ok := p.Source.(HeaderGetter)
						if ok {
							face := inter.GetHeader()
							if face == nil {
								return nil, nil
							}
							return face.Values, nil
						}
						return nil, fmt.Errorf("field values not resolved")
					},
				},
			}
		}),
	})
	GraphQLHttpCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHttpCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"path": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Path, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Path, nil
						}
						return nil, fmt.Errorf("field path not resolved")
					},
				},
				"protocol": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Protocol, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Protocol, nil
						}
						return nil, fmt.Errorf("field protocol not resolved")
					},
				},
				"port": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Port, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Port, nil
						}
						return nil, fmt.Errorf("field port not resolved")
					},
				},
				"verb": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Verb, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Verb, nil
						}
						return nil, fmt.Errorf("field verb not resolved")
					},
				},
				"headers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLHeaderType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Headers, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Headers, nil
						}
						return nil, fmt.Errorf("field headers not resolved")
					},
				},
				"body": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Body, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Body, nil
						}
						return nil, fmt.Errorf("field body not resolved")
					},
				},
			}
		}),
	})
	GraphQLCloudWatchCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCloudWatchCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"metrics": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLCloudWatchMetricType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchCheck)
						if ok {
							return obj.Metrics, nil
						}
						inter, ok := p.Source.(CloudWatchCheckGetter)
						if ok {
							face := inter.GetCloudWatchCheck()
							if face == nil {
								return nil, nil
							}
							return face.Metrics, nil
						}
						return nil, fmt.Errorf("field metrics not resolved")
					},
				},
			}
		}),
	})
	GraphQLCloudWatchMetricType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCloudWatchMetric",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"namespace": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchMetric)
						if ok {
							return obj.Namespace, nil
						}
						inter, ok := p.Source.(CloudWatchMetricGetter)
						if ok {
							face := inter.GetCloudWatchMetric()
							if face == nil {
								return nil, nil
							}
							return face.Namespace, nil
						}
						return nil, fmt.Errorf("field namespace not resolved")
					},
				},
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchMetric)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(CloudWatchMetricGetter)
						if ok {
							face := inter.GetCloudWatchMetric()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
			}
		}),
	})
	GraphQLCloudWatchResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCloudWatchResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"namespace": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The AWS CloudWatch metric namespace, e.g. AWS/RDS",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchResponse)
						if ok {
							return obj.Namespace, nil
						}
						inter, ok := p.Source.(CloudWatchResponseGetter)
						if ok {
							face := inter.GetCloudWatchResponse()
							if face == nil {
								return nil, nil
							}
							return face.Namespace, nil
						}
						return nil, fmt.Errorf("field namespace not resolved")
					},
				},
				"metrics": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLMetricType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchResponse)
						if ok {
							return obj.Metrics, nil
						}
						inter, ok := p.Source.(CloudWatchResponseGetter)
						if ok {
							face := inter.GetCloudWatchResponse()
							if face == nil {
								return nil, nil
							}
							return face.Metrics, nil
						}
						return nil, fmt.Errorf("field metrics not resolved")
					},
				},
				"errors": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_opsee_protobuf_plugin_graphql_scalars.Error),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchResponse)
						if ok {
							return obj.Errors, nil
						}
						inter, ok := p.Source.(CloudWatchResponseGetter)
						if ok {
							face := inter.GetCloudWatchResponse()
							if face == nil {
								return nil, nil
							}
							return face.Errors, nil
						}
						return nil, fmt.Errorf("field errors not resolved")
					},
				},
			}
		}),
	})
	GraphQLTagType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaTag",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Tag)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(TagGetter)
						if ok {
							face := inter.GetTag()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Tag)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(TagGetter)
						if ok {
							face := inter.GetTag()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
			}
		}),
	})
	GraphQLMetricType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaMetric",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Float,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
				"tags": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLTagType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Tags, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Tags, nil
						}
						return nil, fmt.Errorf("field tags not resolved")
					},
				},
				"timestamp": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							if obj.Timestamp == nil {
								return nil, nil
							}
							return obj.GetTimestamp(), nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							if face.Timestamp == nil {
								return nil, nil
							}
							return face.GetTimestamp(), nil
						}
						return nil, fmt.Errorf("field timestamp not resolved")
					},
				},
				"unit": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Unit, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Unit, nil
						}
						return nil, fmt.Errorf("field unit not resolved")
					},
				},
				"statistic": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Statistic, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Statistic, nil
						}
						return nil, fmt.Errorf("field statistic not resolved")
					},
				},
			}
		}),
	})
	GraphQLHttpResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHttpResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"code": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Code, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Code, nil
						}
						return nil, fmt.Errorf("field code not resolved")
					},
				},
				"body": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Body, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Body, nil
						}
						return nil, fmt.Errorf("field body not resolved")
					},
				},
				"headers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLHeaderType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Headers, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Headers, nil
						}
						return nil, fmt.Errorf("field headers not resolved")
					},
				},
				"metrics": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLMetricType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Metrics, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Metrics, nil
						}
						return nil, fmt.Errorf("field metrics not resolved")
					},
				},
				"host": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Host, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Host, nil
						}
						return nil, fmt.Errorf("field host not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheckResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"response": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Any,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							if obj.Response == nil {
								return nil, nil
							}
							return obj.GetResponse(), nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							if face.Response == nil {
								return nil, nil
							}
							return face.GetResponse(), nil
						}
						return nil, fmt.Errorf("field response not resolved")
					},
				},
				"error": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							return obj.Error, nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							return face.Error, nil
						}
						return nil, fmt.Errorf("field error not resolved")
					},
				},
				"passing": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							return obj.Passing, nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							return face.Passing, nil
						}
						return nil, fmt.Errorf("field passing not resolved")
					},
				},
				"reply": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLCheckResponseReplyUnion,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if !ok {
							return nil, fmt.Errorf("field reply not resolved")
						}
						return obj.GetReply(), nil
					},
				},
			}
		}),
	})
	GraphQLCheckResultType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheckResult",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"check_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CheckId, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CheckId, nil
						}
						return nil, fmt.Errorf("field check_id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"timestamp": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							if obj.Timestamp == nil {
								return nil, nil
							}
							return obj.GetTimestamp(), nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							if face.Timestamp == nil {
								return nil, nil
							}
							return face.GetTimestamp(), nil
						}
						return nil, fmt.Errorf("field timestamp not resolved")
					},
				},
				"passing": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Passing, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Passing, nil
						}
						return nil, fmt.Errorf("field passing not resolved")
					},
				},
				"responses": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLCheckResponseType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Responses, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Responses, nil
						}
						return nil, fmt.Errorf("field responses not resolved")
					},
				},
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"check_name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CheckName, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CheckName, nil
						}
						return nil, fmt.Errorf("field check_name not resolved")
					},
				},
				"version": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Version, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Version, nil
						}
						return nil, fmt.Errorf("field version not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckSpecUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "CheckSpec",
		Description: "",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLHttpCheckType,
			GraphQLCloudWatchCheckType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *Check_HttpCheck:
				return GraphQLHttpCheckType
			case *Check_CloudwatchCheck:
				return GraphQLCloudWatchCheckType
			}
			return nil
		},
	})
	GraphQLCheckResponseReplyUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "CheckResponseReply",
		Description: "",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLHttpResponseType,
			GraphQLCloudWatchResponseType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *CheckResponse_HttpResponse:
				return GraphQLHttpResponseType
			case *CheckResponse_CloudwatchResponse:
				return GraphQLCloudWatchResponseType
			}
			return nil
		},
	})
}
func (m *Target) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Target) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Type) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Id) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Address) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Address)))
		i += copy(data[i:], m.Address)
	}
	return i, nil
}

func (m *Check) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Check) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.Interval != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintChecks(data, i, uint64(m.Interval))
	}
	if m.Target != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(m.Target.Size()))
		n1, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.LastRun != nil {
		data[i] = 0x22
		i++
		i = encodeVarintChecks(data, i, uint64(m.LastRun.Size()))
		n2, err := m.LastRun.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CheckSpec != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintChecks(data, i, uint64(m.CheckSpec.Size()))
		n3, err := m.CheckSpec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Name) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Assertions) > 0 {
		for _, msg := range m.Assertions {
			data[i] = 0x3a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0x42
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Notifications) > 0 {
		for _, msg := range m.Notifications {
			data[i] = 0x4a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Spec != nil {
		nn4, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	return i, nil
}

func (m *Check_HttpCheck) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.HttpCheck != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x6
		i++
		i = encodeVarintChecks(data, i, uint64(m.HttpCheck.Size()))
		n5, err := m.HttpCheck.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Check_CloudwatchCheck) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.CloudwatchCheck != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x6
		i++
		i = encodeVarintChecks(data, i, uint64(m.CloudwatchCheck.Size()))
		n6, err := m.CloudwatchCheck.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Notification) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Notification) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *Assertion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Assertion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if len(m.Relationship) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Relationship)))
		i += copy(data[i:], m.Relationship)
	}
	if len(m.Operand) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Operand)))
		i += copy(data[i:], m.Operand)
	}
	return i, nil
}

func (m *Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *HttpCheck) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HttpCheck) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Path) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Protocol) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Protocol)))
		i += copy(data[i:], m.Protocol)
	}
	if m.Port != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintChecks(data, i, uint64(m.Port))
	}
	if len(m.Verb) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Verb)))
		i += copy(data[i:], m.Verb)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x32
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Body) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	return i, nil
}

func (m *CloudWatchCheck) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CloudWatchCheck) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			data[i] = 0xa
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CloudWatchMetric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CloudWatchMetric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *CloudWatchResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CloudWatchResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			data[i] = 0x12
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			data[i] = 0x1a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Tag) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *Metric) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Metric) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Value != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Checks(data, i, uint64(math.Float64bits(float64(m.Value))))
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0x1a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Timestamp != nil {
		data[i] = 0x22
		i++
		i = encodeVarintChecks(data, i, uint64(m.Timestamp.Size()))
		n7, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Unit) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Statistic) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Statistic)))
		i += copy(data[i:], m.Statistic)
	}
	return i, nil
}

func (m *HttpResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HttpResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintChecks(data, i, uint64(m.Code))
	}
	if len(m.Body) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x1a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			data[i] = 0x22
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Host) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	return i, nil
}

func (m *CheckResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CheckResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(m.Target.Size()))
		n8, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Response != nil {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(m.Response.Size()))
		n9, err := m.Response.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Error) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.Error)))
		i += copy(data[i:], m.Error)
	}
	if m.Passing {
		data[i] = 0x20
		i++
		if m.Passing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Reply != nil {
		nn10, err := m.Reply.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *CheckResponse_HttpResponse) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.HttpResponse != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x6
		i++
		i = encodeVarintChecks(data, i, uint64(m.HttpResponse.Size()))
		n11, err := m.HttpResponse.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *CheckResponse_CloudwatchResponse) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.CloudwatchResponse != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x6
		i++
		i = encodeVarintChecks(data, i, uint64(m.CloudwatchResponse.Size()))
		n12, err := m.CloudwatchResponse.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *CheckResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CheckResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CheckId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.CheckId)))
		i += copy(data[i:], m.CheckId)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if m.Timestamp != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintChecks(data, i, uint64(m.Timestamp.Size()))
		n13, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Passing {
		data[i] = 0x20
		i++
		if m.Passing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			data[i] = 0x2a
			i++
			i = encodeVarintChecks(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Target != nil {
		data[i] = 0x32
		i++
		i = encodeVarintChecks(data, i, uint64(m.Target.Size()))
		n14, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.CheckName) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintChecks(data, i, uint64(len(m.CheckName)))
		i += copy(data[i:], m.CheckName)
	}
	if m.Version != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintChecks(data, i, uint64(m.Version))
	}
	return i, nil
}

func encodeFixed64Checks(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Checks(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintChecks(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTarget(r randyChecks, easy bool) *Target {
	this := &Target{}
	this.Name = randStringChecks(r)
	this.Type = randStringChecks(r)
	this.Id = randStringChecks(r)
	this.Address = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck(r randyChecks, easy bool) *Check {
	this := &Check{}
	this.Id = randStringChecks(r)
	this.Interval = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Interval *= -1
	}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LastRun = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CheckSpec = opsee_types1.NewPopulatedAny(r, easy)
	}
	this.Name = randStringChecks(r)
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Assertions = make([]*Assertion, v1)
		for i := 0; i < v1; i++ {
			this.Assertions[i] = NewPopulatedAssertion(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Results = make([]*CheckResult, v2)
		for i := 0; i < v2; i++ {
			this.Results[i] = NewPopulatedCheckResult(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(5)
		this.Notifications = make([]*Notification, v3)
		for i := 0; i < v3; i++ {
			this.Notifications[i] = NewPopulatedNotification(r, easy)
		}
	}
	oneofNumber_Spec := []int32{101, 102}[r.Intn(2)]
	switch oneofNumber_Spec {
	case 101:
		this.Spec = NewPopulatedCheck_HttpCheck(r, easy)
	case 102:
		this.Spec = NewPopulatedCheck_CloudwatchCheck(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck_HttpCheck(r randyChecks, easy bool) *Check_HttpCheck {
	this := &Check_HttpCheck{}
	this.HttpCheck = NewPopulatedHttpCheck(r, easy)
	return this
}
func NewPopulatedCheck_CloudwatchCheck(r randyChecks, easy bool) *Check_CloudwatchCheck {
	this := &Check_CloudwatchCheck{}
	this.CloudwatchCheck = NewPopulatedCloudWatchCheck(r, easy)
	return this
}
func NewPopulatedNotification(r randyChecks, easy bool) *Notification {
	this := &Notification{}
	this.Type = randStringChecks(r)
	this.Value = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAssertion(r randyChecks, easy bool) *Assertion {
	this := &Assertion{}
	this.Key = randStringChecks(r)
	this.Value = randStringChecks(r)
	this.Relationship = randStringChecks(r)
	this.Operand = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHeader(r randyChecks, easy bool) *Header {
	this := &Header{}
	this.Name = randStringChecks(r)
	v4 := r.Intn(10)
	this.Values = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.Values[i] = randStringChecks(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHttpCheck(r randyChecks, easy bool) *HttpCheck {
	this := &HttpCheck{}
	this.Name = randStringChecks(r)
	this.Path = randStringChecks(r)
	this.Protocol = randStringChecks(r)
	this.Port = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	this.Verb = randStringChecks(r)
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Headers = make([]*Header, v5)
		for i := 0; i < v5; i++ {
			this.Headers[i] = NewPopulatedHeader(r, easy)
		}
	}
	this.Body = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudWatchCheck(r randyChecks, easy bool) *CloudWatchCheck {
	this := &CloudWatchCheck{}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Metrics = make([]*CloudWatchMetric, v6)
		for i := 0; i < v6; i++ {
			this.Metrics[i] = NewPopulatedCloudWatchMetric(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudWatchMetric(r randyChecks, easy bool) *CloudWatchMetric {
	this := &CloudWatchMetric{}
	this.Namespace = randStringChecks(r)
	this.Name = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudWatchResponse(r randyChecks, easy bool) *CloudWatchResponse {
	this := &CloudWatchResponse{}
	this.Namespace = randStringChecks(r)
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Metrics = make([]*Metric, v7)
		for i := 0; i < v7; i++ {
			this.Metrics[i] = NewPopulatedMetric(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Errors = make([]*opsee_types2.Error, v8)
		for i := 0; i < v8; i++ {
			this.Errors[i] = opsee_types2.NewPopulatedError(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTag(r randyChecks, easy bool) *Tag {
	this := &Tag{}
	this.Name = randStringChecks(r)
	this.Value = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetric(r randyChecks, easy bool) *Metric {
	this := &Metric{}
	this.Name = randStringChecks(r)
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Tags = make([]*Tag, v9)
		for i := 0; i < v9; i++ {
			this.Tags[i] = NewPopulatedTag(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Timestamp = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	this.Unit = randStringChecks(r)
	this.Statistic = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHttpResponse(r randyChecks, easy bool) *HttpResponse {
	this := &HttpResponse{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Body = randStringChecks(r)
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Headers = make([]*Header, v10)
		for i := 0; i < v10; i++ {
			this.Headers[i] = NewPopulatedHeader(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(5)
		this.Metrics = make([]*Metric, v11)
		for i := 0; i < v11; i++ {
			this.Metrics[i] = NewPopulatedMetric(r, easy)
		}
	}
	this.Host = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckResponse(r randyChecks, easy bool) *CheckResponse {
	this := &CheckResponse{}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Response = opsee_types1.NewPopulatedAny(r, easy)
	}
	this.Error = randStringChecks(r)
	this.Passing = bool(bool(r.Intn(2) == 0))
	oneofNumber_Reply := []int32{101, 102}[r.Intn(2)]
	switch oneofNumber_Reply {
	case 101:
		this.Reply = NewPopulatedCheckResponse_HttpResponse(r, easy)
	case 102:
		this.Reply = NewPopulatedCheckResponse_CloudwatchResponse(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckResponse_HttpResponse(r randyChecks, easy bool) *CheckResponse_HttpResponse {
	this := &CheckResponse_HttpResponse{}
	this.HttpResponse = NewPopulatedHttpResponse(r, easy)
	return this
}
func NewPopulatedCheckResponse_CloudwatchResponse(r randyChecks, easy bool) *CheckResponse_CloudwatchResponse {
	this := &CheckResponse_CloudwatchResponse{}
	this.CloudwatchResponse = NewPopulatedCloudWatchResponse(r, easy)
	return this
}
func NewPopulatedCheckResult(r randyChecks, easy bool) *CheckResult {
	this := &CheckResult{}
	this.CheckId = randStringChecks(r)
	this.CustomerId = randStringChecks(r)
	if r.Intn(10) != 0 {
		this.Timestamp = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	this.Passing = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.Responses = make([]*CheckResponse, v12)
		for i := 0; i < v12; i++ {
			this.Responses[i] = NewPopulatedCheckResponse(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	this.CheckName = randStringChecks(r)
	this.Version = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyChecks interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneChecks(r randyChecks) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringChecks(r randyChecks) string {
	v13 := r.Intn(100)
	tmps := make([]rune, v13)
	for i := 0; i < v13; i++ {
		tmps[i] = randUTF8RuneChecks(r)
	}
	return string(tmps)
}
func randUnrecognizedChecks(r randyChecks, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldChecks(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldChecks(data []byte, r randyChecks, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateChecks(data, uint64(key))
		v14 := r.Int63()
		if r.Intn(2) == 0 {
			v14 *= -1
		}
		data = encodeVarintPopulateChecks(data, uint64(v14))
	case 1:
		data = encodeVarintPopulateChecks(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateChecks(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateChecks(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateChecks(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateChecks(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Target) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *Check) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovChecks(uint64(m.Interval))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.LastRun != nil {
		l = m.LastRun.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.CheckSpec != nil {
		l = m.CheckSpec.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.Assertions) > 0 {
		for _, e := range m.Assertions {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.Notifications) > 0 {
		for _, e := range m.Notifications {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.Spec != nil {
		n += m.Spec.Size()
	}
	return n
}

func (m *Check_HttpCheck) Size() (n int) {
	var l int
	_ = l
	if m.HttpCheck != nil {
		l = m.HttpCheck.Size()
		n += 2 + l + sovChecks(uint64(l))
	}
	return n
}
func (m *Check_CloudwatchCheck) Size() (n int) {
	var l int
	_ = l
	if m.CloudwatchCheck != nil {
		l = m.CloudwatchCheck.Size()
		n += 2 + l + sovChecks(uint64(l))
	}
	return n
}
func (m *Notification) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *Assertion) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Relationship)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Operand)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	return n
}

func (m *HttpCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovChecks(uint64(m.Port))
	}
	l = len(m.Verb)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *CloudWatchCheck) Size() (n int) {
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	return n
}

func (m *CloudWatchMetric) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *CloudWatchResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *Metric) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Statistic)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *HttpResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovChecks(uint64(m.Code))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	return n
}

func (m *CheckResponse) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Passing {
		n += 2
	}
	if m.Reply != nil {
		n += m.Reply.Size()
	}
	return n
}

func (m *CheckResponse_HttpResponse) Size() (n int) {
	var l int
	_ = l
	if m.HttpResponse != nil {
		l = m.HttpResponse.Size()
		n += 2 + l + sovChecks(uint64(l))
	}
	return n
}
func (m *CheckResponse_CloudwatchResponse) Size() (n int) {
	var l int
	_ = l
	if m.CloudwatchResponse != nil {
		l = m.CloudwatchResponse.Size()
		n += 2 + l + sovChecks(uint64(l))
	}
	return n
}
func (m *CheckResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.CheckId)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Passing {
		n += 2
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	l = len(m.CheckName)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovChecks(uint64(m.Version))
	}
	return n
}

func sovChecks(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozChecks(x uint64) (n int) {
	return sovChecks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Target) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Target: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Target: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Interval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Target{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRun == nil {
				m.LastRun = &opsee_types.Timestamp{}
			}
			if err := m.LastRun.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckSpec == nil {
				m.CheckSpec = &opsee_types1.Any{}
			}
			if err := m.CheckSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assertions = append(m.Assertions, &Assertion{})
			if err := m.Assertions[len(m.Assertions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &CheckResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notifications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notifications = append(m.Notifications, &Notification{})
			if err := m.Notifications[len(m.Notifications)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpCheck{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Spec = &Check_HttpCheck{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudwatchCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudWatchCheck{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Spec = &Check_CloudwatchCheck{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notification) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Assertion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assertion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assertion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relationship", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relationship = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operand = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpCheck) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verb = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudWatchCheck) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudWatchCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudWatchCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &CloudWatchMetric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudWatchMetric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudWatchMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudWatchMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudWatchResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudWatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudWatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &opsee_types2.Error{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metric) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &opsee_types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statistic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metric{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Target{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &opsee_types1.Any{}
			}
			if err := m.Response.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passing = bool(v != 0)
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HttpResponse{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &CheckResponse_HttpResponse{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudwatchResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudWatchResponse{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reply = &CheckResponse_CloudwatchResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &opsee_types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passing = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &CheckResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Target{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChecks(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthChecks
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowChecks
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipChecks(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthChecks = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChecks   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorChecks = []byte{
	// 1081 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0x1c, 0x45,
	0x10, 0x66, 0xf6, 0x67, 0x76, 0xb7, 0xbc, 0x4e, 0xac, 0x76, 0x64, 0x36, 0x16, 0x71, 0xac, 0x91,
	0x50, 0x22, 0x08, 0x76, 0x30, 0x41, 0x80, 0x6f, 0x59, 0x07, 0xc9, 0x48, 0x10, 0x45, 0x8d, 0x25,
	0x24, 0x2e, 0xd6, 0x78, 0xb6, 0xbd, 0x33, 0xca, 0xee, 0xcc, 0x68, 0xba, 0x37, 0x68, 0x0f, 0x48,
	0x5c, 0x10, 0x2f, 0xc1, 0x89, 0x03, 0x70, 0xe1, 0xce, 0x31, 0x47, 0x0e, 0x1c, 0x78, 0x04, 0xe0,
	0x29, 0x38, 0xd2, 0x5d, 0xfd, 0x33, 0x3d, 0xf6, 0xc6, 0x49, 0x0e, 0x23, 0x75, 0xfd, 0x7c, 0xdd,
	0xd5, 0x55, 0x5f, 0x57, 0x0d, 0x0c, 0x93, 0x94, 0x25, 0x4f, 0xf9, 0x5e, 0x59, 0x15, 0xa2, 0x20,
	0xdd, 0xa2, 0xe4, 0x8c, 0x6d, 0x1f, 0x4e, 0x33, 0x91, 0x2e, 0xce, 0xf6, 0x92, 0x62, 0xbe, 0x8f,
	0x9a, 0x7d, 0x34, 0x9f, 0x2d, 0xce, 0xb5, 0x88, 0xd2, 0xbe, 0x58, 0x96, 0x8c, 0xef, 0x8b, 0x6c,
	0xce, 0xb8, 0x88, 0xe7, 0xa5, 0xde, 0x62, 0xfb, 0xc1, 0x6b, 0x60, 0xe3, 0x7c, 0x69, 0x50, 0x1f,
	0xbd, 0x06, 0x8a, 0x55, 0x55, 0x51, 0x99, 0x88, 0xb7, 0xdf, 0xf3, 0x80, 0xd3, 0x62, 0x5a, 0xd4,
	0x38, 0x25, 0x69, 0x98, 0x5a, 0x19, 0xf7, 0xfb, 0xaf, 0x74, 0x0e, 0x2e, 0x35, 0x22, 0x3a, 0x87,
	0xf0, 0x24, 0xae, 0xa6, 0x4c, 0x10, 0x02, 0x9d, 0x3c, 0x9e, 0xb3, 0x51, 0xb0, 0x1b, 0xdc, 0x1d,
	0x50, 0x5c, 0x93, 0x11, 0x74, 0x54, 0x50, 0xa3, 0x96, 0xd2, 0x8d, 0x3b, 0xdf, 0xfd, 0x7c, 0x2b,
	0xa0, 0xa8, 0x21, 0x37, 0xa0, 0x95, 0x4d, 0x46, 0x6d, 0x4f, 0x2f, 0x65, 0xe9, 0xdf, 0x8b, 0x27,
	0x93, 0x8a, 0x71, 0x3e, 0xea, 0xe0, 0x36, 0x56, 0x8c, 0xbe, 0xef, 0x40, 0xf7, 0x48, 0xd5, 0x82,
	0x5c, 0x43, 0xa4, 0x3e, 0x45, 0x61, 0x76, 0xa1, 0x9f, 0xe5, 0x82, 0x55, 0xcf, 0xe2, 0x19, 0x9e,
	0xd3, 0x35, 0xfb, 0x39, 0x2d, 0x79, 0x17, 0x42, 0x81, 0x31, 0xe2, 0x79, 0x6b, 0x07, 0xeb, 0x7b,
	0xfa, 0x06, 0x3a, 0x70, 0xe3, 0x6e, 0x5c, 0xc8, 0xfb, 0xd0, 0x9f, 0xc5, 0x5c, 0x9c, 0x56, 0x8b,
	0x1c, 0x63, 0x58, 0x3b, 0xd8, 0x32, 0xee, 0x98, 0xde, 0xbd, 0x13, 0x5b, 0x50, 0xda, 0x53, 0x7e,
	0x74, 0x91, 0x93, 0x0f, 0x01, 0x90, 0x26, 0xa7, 0xbc, 0x64, 0xc9, 0xa8, 0x8b, 0xa0, 0x8d, 0x06,
	0xe8, 0x61, 0xbe, 0x34, 0xc7, 0x0c, 0xd0, 0xf3, 0x4b, 0xe9, 0xa8, 0x92, 0x83, 0x09, 0x0b, 0xfd,
	0xe4, 0x60, 0xda, 0xee, 0x03, 0xc4, 0x9c, 0xb3, 0x4a, 0x64, 0x45, 0xce, 0x47, 0xbd, 0xdd, 0xb6,
	0xb7, 0xe1, 0x43, 0x6b, 0xa0, 0x9e, 0x0f, 0xb9, 0x07, 0x3d, 0x99, 0xa6, 0xc5, 0x4c, 0xf0, 0x51,
	0x1f, 0xdd, 0x89, 0x71, 0xc7, 0x9c, 0x51, 0x34, 0x51, 0xeb, 0x42, 0x3e, 0x81, 0xf5, 0xbc, 0x10,
	0xd9, 0x79, 0x96, 0xc4, 0xfa, 0x88, 0x01, 0x62, 0x36, 0x0d, 0xe6, 0xb1, 0x67, 0xa3, 0x4d, 0x4f,
	0x99, 0x1e, 0x48, 0x85, 0x28, 0x4f, 0xf1, 0x1a, 0x23, 0xd6, 0xb8, 0xeb, 0xb1, 0x34, 0xe0, 0x79,
	0xc7, 0x6f, 0xd0, 0x41, 0x6a, 0x05, 0x72, 0x04, 0x1b, 0xc9, 0xac, 0x58, 0x4c, 0xbe, 0x89, 0x45,
	0x92, 0x1a, 0xe0, 0x79, 0x23, 0xb3, 0x47, 0xca, 0xfc, 0x95, 0x32, 0x5b, 0xf8, 0xf5, 0x1a, 0x81,
	0xaa, 0x71, 0x08, 0x1d, 0x95, 0xdd, 0xe8, 0x63, 0x18, 0xfa, 0xe1, 0x29, 0xd6, 0x21, 0xc3, 0x0c,
	0xeb, 0x0c, 0xb7, 0xba, 0xb2, 0xec, 0x0b, 0x43, 0x3b, 0xaa, 0x85, 0xe8, 0x5b, 0x18, 0xb8, 0xdc,
	0x91, 0x2d, 0x68, 0x3f, 0x65, 0x4b, 0x8d, 0x32, 0xa9, 0x57, 0x8a, 0xd5, 0x50, 0x72, 0x17, 0x86,
	0x15, 0x9b, 0xe9, 0x0c, 0xa4, 0x59, 0xd9, 0xa0, 0x6d, 0xc3, 0xa2, 0x08, 0x5c, 0x94, 0xac, 0x8a,
	0xf3, 0x89, 0x25, 0xb0, 0x11, 0xa3, 0x43, 0x08, 0x8f, 0x59, 0x3c, 0x61, 0x95, 0xab, 0x7b, 0x70,
	0xa9, 0xee, 0x5b, 0x10, 0xe2, 0x81, 0x5c, 0x1e, 0xdf, 0x96, 0x60, 0x23, 0x45, 0x7f, 0x06, 0x30,
	0x70, 0xc9, 0x7d, 0xd1, 0x43, 0x2b, 0x63, 0x91, 0x36, 0x1f, 0x9a, 0xd2, 0xa8, 0xe7, 0x81, 0x2f,
	0x35, 0x29, 0x66, 0x8d, 0xb8, 0x9d, 0x16, 0xb1, 0x45, 0x25, 0x30, 0xe0, 0xae, 0xc3, 0x4a, 0x8d,
	0xb2, 0x3c, 0x63, 0xd5, 0x19, 0x52, 0xda, 0xed, 0xaa, 0x34, 0xe4, 0x0e, 0xf4, 0x52, 0xbc, 0x0d,
	0x97, 0xf4, 0x6d, 0x7b, 0x6f, 0x4a, 0xdf, 0x91, 0x5a, 0xab, 0x0a, 0xf6, 0xac, 0x98, 0x2c, 0x25,
	0x89, 0x31, 0x58, 0xb5, 0x8e, 0x1e, 0xc1, 0xf5, 0x0b, 0x15, 0x97, 0xb4, 0xea, 0xcd, 0x99, 0xa8,
	0xb2, 0x84, 0xcb, 0x6b, 0xa9, 0xfd, 0xde, 0xbc, 0x44, 0x8d, 0x2f, 0xd0, 0x4e, 0xad, 0x9f, 0xdc,
	0x65, 0xe3, 0xa2, 0x91, 0xbc, 0x05, 0x03, 0x95, 0x0e, 0x5e, 0xc6, 0x89, 0xcd, 0x4f, 0xad, 0x70,
	0x89, 0x6b, 0xd5, 0x89, 0x8b, 0x7e, 0x08, 0x80, 0xd4, 0xdb, 0xc8, 0x87, 0x52, 0xca, 0x4a, 0xb2,
	0x97, 0x6c, 0x74, 0xa7, 0x8e, 0xb6, 0xd5, 0xb8, 0xfd, 0x85, 0x18, 0xc9, 0x3b, 0x10, 0xea, 0x76,
	0x2c, 0x53, 0xef, 0xbf, 0x4a, 0xdd, 0x15, 0x3e, 0x55, 0x26, 0x6a, 0x3c, 0xa2, 0x7d, 0x68, 0x9f,
	0xc4, 0xd3, 0x95, 0xd5, 0x5d, 0x4d, 0xe8, 0xe7, 0x01, 0x84, 0xe6, 0xde, 0xab, 0x40, 0xdb, 0x3e,
	0x28, 0x30, 0xd5, 0x33, 0x84, 0xde, 0x91, 0xaf, 0x26, 0x9e, 0xda, 0xa8, 0xc0, 0xf5, 0xc3, 0x29,
	0x45, 0x3d, 0x79, 0x00, 0x03, 0x37, 0xb8, 0x5e, 0xd2, 0x05, 0x6b, 0x47, 0x15, 0xc5, 0x22, 0xcf,
	0x84, 0xa6, 0x0b, 0xc5, 0xb5, 0x4a, 0xa4, 0x34, 0x8a, 0x8c, 0x8b, 0x2c, 0xd1, 0x9d, 0x8e, 0xd6,
	0x8a, 0xe8, 0xc7, 0x00, 0x86, 0x8a, 0xd8, 0x2e, 0xef, 0x72, 0x8b, 0xa4, 0x98, 0xe8, 0x8b, 0x74,
	0x29, 0xae, 0x1d, 0x85, 0x5a, 0x35, 0x85, 0x7c, 0xfe, 0xb5, 0xaf, 0xe4, 0x9f, 0x57, 0xaa, 0xce,
	0x95, 0xa5, 0x92, 0xa7, 0xa4, 0x05, 0x77, 0xc1, 0xab, 0x75, 0xf4, 0x4b, 0x0b, 0xd6, 0x6d, 0x03,
	0xd5, 0xf1, 0xbd, 0xed, 0x46, 0x49, 0xb0, 0x62, 0x94, 0xb8, 0x21, 0x72, 0x0f, 0xfa, 0x95, 0x81,
	0x60, 0xd8, 0x2b, 0xe6, 0x01, 0x75, 0x1e, 0xaa, 0xbc, 0xc8, 0x01, 0xfd, 0x3e, 0xa9, 0x16, 0x54,
	0x2b, 0x29, 0x65, 0x87, 0xcf, 0xf2, 0x29, 0x56, 0xa0, 0x4f, 0xad, 0x48, 0x0e, 0x61, 0x1d, 0x7b,
	0xb0, 0x3b, 0x42, 0xb7, 0xe1, 0x4d, 0xaf, 0x0d, 0xdb, 0x80, 0x65, 0x2b, 0x1d, 0xa6, 0x7e, 0x82,
	0x3f, 0x87, 0x4d, 0xaf, 0x19, 0xbb, 0x1d, 0x74, 0x3f, 0xbe, 0x79, 0xe9, 0xd1, 0x79, 0xfb, 0x90,
	0x1a, 0x67, 0xb5, 0xe3, 0x1e, 0x74, 0x2b, 0x56, 0xce, 0x96, 0xd1, 0x6f, 0x2d, 0x58, 0xf3, 0x46,
	0x0d, 0xb9, 0x09, 0x7d, 0x3d, 0x12, 0xdd, 0xa8, 0xee, 0xa1, 0xfc, 0xd9, 0x84, 0xdc, 0x86, 0xb5,
	0x64, 0xc1, 0x45, 0x31, 0x67, 0x95, 0xb2, 0xea, 0xaa, 0x82, 0x55, 0x49, 0x87, 0x06, 0xf9, 0xda,
	0xaf, 0x4a, 0xbe, 0x17, 0xa7, 0xeb, 0x00, 0x06, 0xf6, 0x9e, 0x5c, 0x96, 0x57, 0x91, 0xe0, 0xc6,
	0x85, 0xe9, 0x88, 0x46, 0x5a, 0xbb, 0x79, 0x75, 0x0e, 0xaf, 0xaa, 0xf3, 0x2d, 0x3b, 0xf9, 0xf1,
	0xf5, 0xe9, 0x1e, 0xa7, 0x27, 0xfc, 0x63, 0xdd, 0x95, 0x7b, 0xb2, 0x5b, 0x72, 0x39, 0x1c, 0xe4,
	0x54, 0x56, 0x84, 0xb6, 0xe2, 0xf8, 0xd1, 0x7f, 0xff, 0xec, 0x04, 0xbf, 0xfe, 0xbb, 0x13, 0xfc,
	0x2e, 0xbf, 0x3f, 0xe4, 0xf7, 0x97, 0xfc, 0xfe, 0x96, 0xdf, 0xf3, 0x9f, 0x6e, 0x07, 0x70, 0x2d,
	0x29, 0xf6, 0xbc, 0x9f, 0xac, 0xf1, 0x70, 0x2c, 0xff, 0x34, 0x24, 0xec, 0x89, 0x92, 0x9e, 0x04,
	0x5f, 0x87, 0x5c, 0x9e, 0x31, 0x8f, 0xcf, 0x42, 0x34, 0x7f, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x36, 0x23, 0xeb, 0xdc, 0xa6, 0x0a, 0x00, 0x00,
}
