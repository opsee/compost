// Code generated by protoc-gen-gogo.
// source: aws_data.proto
// DO NOT EDIT!

/*
	Package schema is a generated protocol buffer package.

	It is generated from these files:
		aws_data.proto
		checks.proto
		stack.proto
		user.proto

	It has these top-level messages:
		Region
		Vpc
		Subnet
		Group
		Instance
		Target
		Check
		Assertion
		Header
		HttpCheck
		CloudWatchCheck
		CloudWatchMetric
		CloudWatchResponse
		Tag
		Metric
		HttpResponse
		CheckResponse
		CheckResult
		BastionState
		Stack
		User
		Customer
*/
package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/opsee/protobuf/opseeproto"
import opsee_types "github.com/opsee/protobuf/opseeproto/types"
import opsee_aws_autoscaling "github.com/opsee/basic/schema/aws/autoscaling"
import opsee_aws_ec2 "github.com/opsee/basic/schema/aws/ec2"
import opsee_aws_elb "github.com/opsee/basic/schema/aws/elb"
import opsee_aws_rds "github.com/opsee/basic/schema/aws/rds"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"
import github_com_opsee_protobuf_plugin_graphql_scalars "github.com/opsee/protobuf/plugin/graphql/scalars"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

// An Opsee region object representing an AWS region.
type Region struct {
	// The region identifier, e.g. us-west-1.
	Region     string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The region's supported platforms [EC2-VPC, Classic].
	SupportedPlatforms []string `protobuf:"bytes,3,rep,name=supported_platforms,json=supportedPlatforms" json:"supported_platforms,omitempty"`
	// The region's VPCs.
	Vpcs []*Vpc `protobuf:"bytes,4,rep,name=vpcs" json:"vpcs,omitempty"`
	// The region's subnets.
	Subnets []*Subnet `protobuf:"bytes,5,rep,name=subnets" json:"subnets,omitempty"`
}

func (m *Region) Reset()                    { *m = Region{} }
func (m *Region) String() string            { return proto.CompactTextString(m) }
func (*Region) ProtoMessage()               {}
func (*Region) Descriptor() ([]byte, []int) { return fileDescriptorAwsData, []int{0} }

func (m *Region) GetVpcs() []*Vpc {
	if m != nil {
		return m.Vpcs
	}
	return nil
}

func (m *Region) GetSubnets() []*Subnet {
	if m != nil {
		return m.Subnets
	}
	return nil
}

// An Opsee VPC object representing an AWS VPC resource.
type Vpc struct {
	// The VPC identifier.
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The raw AWS VPC data.
	Resource *opsee_aws_ec2.Vpc `protobuf:"bytes,3,opt,name=resource" json:"resource,omitempty"`
	// The last seen number of instances in the VPC. This value is cached, so it may not be consistent.
	InstanceCount int32 `protobuf:"varint,4,opt,name=instance_count,json=instanceCount,proto3" json:"instance_count,omitempty"`
}

func (m *Vpc) Reset()                    { *m = Vpc{} }
func (m *Vpc) String() string            { return proto.CompactTextString(m) }
func (*Vpc) ProtoMessage()               {}
func (*Vpc) Descriptor() ([]byte, []int) { return fileDescriptorAwsData, []int{1} }

func (m *Vpc) GetResource() *opsee_aws_ec2.Vpc {
	if m != nil {
		return m.Resource
	}
	return nil
}

// An Opsee subnet object representing an AWS Subnet resource.
type Subnet struct {
	// The subnet identifier.
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The raw AWS subnet data.
	Resource *opsee_aws_ec2.Subnet `protobuf:"bytes,3,opt,name=resource" json:"resource,omitempty"`
	// The last seen number of instances in the Subnet. This value is cached, so it may not be consistent.
	InstanceCount int32 `protobuf:"varint,4,opt,name=instance_count,json=instanceCount,proto3" json:"instance_count,omitempty"`
	// The type of route to the internet, may be one of [public, nat, gateway, private, occluded].
	Routing string `protobuf:"bytes,5,opt,name=routing,proto3" json:"routing,omitempty"`
}

func (m *Subnet) Reset()                    { *m = Subnet{} }
func (m *Subnet) String() string            { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()               {}
func (*Subnet) Descriptor() ([]byte, []int) { return fileDescriptorAwsData, []int{2} }

func (m *Subnet) GetResource() *opsee_aws_ec2.Subnet {
	if m != nil {
		return m.Resource
	}
	return nil
}

// An Opsee group target representing an AWS group resource.
type Group struct {
	// The AWS group identifier.
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The type of AWS resource.
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// The raw AWS resource data.
	//
	// Types that are valid to be assigned to Resource:
	//	*Group_SecurityGroup
	//	*Group_LoadBalancer
	//	*Group_AutoscalingGroup
	Resource isGroup_Resource `protobuf_oneof:"resource"`
	// The last seen number of instances in the group target. This value is cached, so it may not be consistent.
	InstanceCount int32 `protobuf:"varint,4,opt,name=instance_count,json=instanceCount,proto3" json:"instance_count,omitempty"`
	// The last seen instances in the group target. This value is cached, so it may not be consistent.
	Instances []*Instance            `protobuf:"bytes,5,rep,name=instances" json:"instances,omitempty"`
	CreatedAt *opsee_types.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	UpdatedAt *opsee_types.Timestamp `protobuf:"bytes,7,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptorAwsData, []int{3} }

type isGroup_Resource interface {
	isGroup_Resource()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Group_SecurityGroup struct {
	SecurityGroup *opsee_aws_ec2.SecurityGroup `protobuf:"bytes,101,opt,name=security_group,json=securityGroup,oneof"`
}
type Group_LoadBalancer struct {
	LoadBalancer *opsee_aws_elb.LoadBalancerDescription `protobuf:"bytes,102,opt,name=load_balancer,json=loadBalancer,oneof"`
}
type Group_AutoscalingGroup struct {
	AutoscalingGroup *opsee_aws_autoscaling.Group `protobuf:"bytes,103,opt,name=autoscaling_group,json=autoscalingGroup,oneof"`
}

func (*Group_SecurityGroup) isGroup_Resource()    {}
func (*Group_LoadBalancer) isGroup_Resource()     {}
func (*Group_AutoscalingGroup) isGroup_Resource() {}

func (m *Group) GetResource() isGroup_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Group) GetSecurityGroup() *opsee_aws_ec2.SecurityGroup {
	if x, ok := m.GetResource().(*Group_SecurityGroup); ok {
		return x.SecurityGroup
	}
	return nil
}

func (m *Group) GetLoadBalancer() *opsee_aws_elb.LoadBalancerDescription {
	if x, ok := m.GetResource().(*Group_LoadBalancer); ok {
		return x.LoadBalancer
	}
	return nil
}

func (m *Group) GetAutoscalingGroup() *opsee_aws_autoscaling.Group {
	if x, ok := m.GetResource().(*Group_AutoscalingGroup); ok {
		return x.AutoscalingGroup
	}
	return nil
}

func (m *Group) GetInstances() []*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *Group) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Group) GetUpdatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Group) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Group_OneofMarshaler, _Group_OneofUnmarshaler, _Group_OneofSizer, []interface{}{
		(*Group_SecurityGroup)(nil),
		(*Group_LoadBalancer)(nil),
		(*Group_AutoscalingGroup)(nil),
	}
}

func _Group_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Group)
	// resource
	switch x := m.Resource.(type) {
	case *Group_SecurityGroup:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SecurityGroup); err != nil {
			return err
		}
	case *Group_LoadBalancer:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadBalancer); err != nil {
			return err
		}
	case *Group_AutoscalingGroup:
		_ = b.EncodeVarint(103<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutoscalingGroup); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Group.Resource has unexpected type %T", x)
	}
	return nil
}

func _Group_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Group)
	switch tag {
	case 101: // resource.security_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(opsee_aws_ec2.SecurityGroup)
		err := b.DecodeMessage(msg)
		m.Resource = &Group_SecurityGroup{msg}
		return true, err
	case 102: // resource.load_balancer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(opsee_aws_elb.LoadBalancerDescription)
		err := b.DecodeMessage(msg)
		m.Resource = &Group_LoadBalancer{msg}
		return true, err
	case 103: // resource.autoscaling_group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(opsee_aws_autoscaling.Group)
		err := b.DecodeMessage(msg)
		m.Resource = &Group_AutoscalingGroup{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Group_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Group)
	// resource
	switch x := m.Resource.(type) {
	case *Group_SecurityGroup:
		s := proto.Size(x.SecurityGroup)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Group_LoadBalancer:
		s := proto.Size(x.LoadBalancer)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Group_AutoscalingGroup:
		s := proto.Size(x.AutoscalingGroup)
		n += proto.SizeVarint(103<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// An Opsee instance target representing an AWS instance resource.
type Instance struct {
	// The AWS instance identifier.
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"`
	// The type of AWS resource.
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// The raw AWS resource data.
	//
	// Types that are valid to be assigned to Resource:
	//	*Instance_Instance
	//	*Instance_DbInstance
	Resource isInstance_Resource `protobuf_oneof:"resource"`
	// The last seen group targets that the instance belongs to. This value is cached, so it may not be consistent.
	Groups    []*Group               `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
	CreatedAt *opsee_types.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	UpdatedAt *opsee_types.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptorAwsData, []int{4} }

type isInstance_Resource interface {
	isInstance_Resource()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Instance_Instance struct {
	Instance *opsee_aws_ec2.Instance `protobuf:"bytes,101,opt,name=instance,oneof"`
}
type Instance_DbInstance struct {
	DbInstance *opsee_aws_rds.DBInstance `protobuf:"bytes,102,opt,name=db_instance,json=dbInstance,oneof"`
}

func (*Instance_Instance) isInstance_Resource()   {}
func (*Instance_DbInstance) isInstance_Resource() {}

func (m *Instance) GetResource() isInstance_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Instance) GetInstance() *opsee_aws_ec2.Instance {
	if x, ok := m.GetResource().(*Instance_Instance); ok {
		return x.Instance
	}
	return nil
}

func (m *Instance) GetDbInstance() *opsee_aws_rds.DBInstance {
	if x, ok := m.GetResource().(*Instance_DbInstance); ok {
		return x.DbInstance
	}
	return nil
}

func (m *Instance) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *Instance) GetCreatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Instance) GetUpdatedAt() *opsee_types.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Instance) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Instance_OneofMarshaler, _Instance_OneofUnmarshaler, _Instance_OneofSizer, []interface{}{
		(*Instance_Instance)(nil),
		(*Instance_DbInstance)(nil),
	}
}

func _Instance_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Instance)
	// resource
	switch x := m.Resource.(type) {
	case *Instance_Instance:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Instance); err != nil {
			return err
		}
	case *Instance_DbInstance:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DbInstance); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Instance.Resource has unexpected type %T", x)
	}
	return nil
}

func _Instance_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Instance)
	switch tag {
	case 101: // resource.instance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(opsee_aws_ec2.Instance)
		err := b.DecodeMessage(msg)
		m.Resource = &Instance_Instance{msg}
		return true, err
	case 102: // resource.db_instance
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(opsee_aws_rds.DBInstance)
		err := b.DecodeMessage(msg)
		m.Resource = &Instance_DbInstance{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Instance_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Instance)
	// resource
	switch x := m.Resource.(type) {
	case *Instance_Instance:
		s := proto.Size(x.Instance)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Instance_DbInstance:
		s := proto.Size(x.DbInstance)
		n += proto.SizeVarint(102<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Region)(nil), "opsee.Region")
	proto.RegisterType((*Vpc)(nil), "opsee.Vpc")
	proto.RegisterType((*Subnet)(nil), "opsee.Subnet")
	proto.RegisterType((*Group)(nil), "opsee.Group")
	proto.RegisterType((*Instance)(nil), "opsee.Instance")
}
func (this *Region) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Region)
	if !ok {
		that2, ok := that.(Region)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if len(this.SupportedPlatforms) != len(that1.SupportedPlatforms) {
		return false
	}
	for i := range this.SupportedPlatforms {
		if this.SupportedPlatforms[i] != that1.SupportedPlatforms[i] {
			return false
		}
	}
	if len(this.Vpcs) != len(that1.Vpcs) {
		return false
	}
	for i := range this.Vpcs {
		if !this.Vpcs[i].Equal(that1.Vpcs[i]) {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	return true
}
func (this *Vpc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Vpc)
	if !ok {
		that2, ok := that.(Vpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if this.InstanceCount != that1.InstanceCount {
		return false
	}
	return true
}
func (this *Subnet) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Subnet)
	if !ok {
		that2, ok := that.(Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if this.InstanceCount != that1.InstanceCount {
		return false
	}
	if this.Routing != that1.Routing {
		return false
	}
	return true
}
func (this *Group) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Group)
	if !ok {
		that2, ok := that.(Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if that1.Resource == nil {
		if this.Resource != nil {
			return false
		}
	} else if this.Resource == nil {
		return false
	} else if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if this.InstanceCount != that1.InstanceCount {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (this *Group_SecurityGroup) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Group_SecurityGroup)
	if !ok {
		that2, ok := that.(Group_SecurityGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SecurityGroup.Equal(that1.SecurityGroup) {
		return false
	}
	return true
}
func (this *Group_LoadBalancer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Group_LoadBalancer)
	if !ok {
		that2, ok := that.(Group_LoadBalancer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.LoadBalancer.Equal(that1.LoadBalancer) {
		return false
	}
	return true
}
func (this *Group_AutoscalingGroup) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Group_AutoscalingGroup)
	if !ok {
		that2, ok := that.(Group_AutoscalingGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.AutoscalingGroup.Equal(that1.AutoscalingGroup) {
		return false
	}
	return true
}
func (this *Instance) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if that1.Resource == nil {
		if this.Resource != nil {
			return false
		}
	} else if this.Resource == nil {
		return false
	} else if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if !this.Groups[i].Equal(that1.Groups[i]) {
			return false
		}
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	return true
}
func (this *Instance_Instance) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Instance_Instance)
	if !ok {
		that2, ok := that.(Instance_Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Instance.Equal(that1.Instance) {
		return false
	}
	return true
}
func (this *Instance_DbInstance) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Instance_DbInstance)
	if !ok {
		that2, ok := that.(Instance_DbInstance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DbInstance.Equal(that1.DbInstance) {
		return false
	}
	return true
}

type RegionGetter interface {
	GetRegion() *Region
}

var GraphQLRegionType *github_com_graphql_go_graphql.Object

type VpcGetter interface {
	GetVpc() *Vpc
}

var GraphQLVpcType *github_com_graphql_go_graphql.Object

type SubnetGetter interface {
	GetSubnet() *Subnet
}

var GraphQLSubnetType *github_com_graphql_go_graphql.Object

type GroupGetter interface {
	GetGroup() *Group
}

var GraphQLGroupType *github_com_graphql_go_graphql.Object
var GraphQLGroupResourceUnion *github_com_graphql_go_graphql.Union

type InstanceGetter interface {
	GetInstance() *Instance
}

var GraphQLInstanceType *github_com_graphql_go_graphql.Object
var GraphQLInstanceResourceUnion *github_com_graphql_go_graphql.Union

func (g *Instance_Instance) GetInstance() *opsee_aws_ec2.Instance {
	return g.Instance
}
func (g *Instance_DbInstance) GetDBInstance() *opsee_aws_rds.DBInstance {
	return g.DbInstance
}
func (g *Group_SecurityGroup) GetSecurityGroup() *opsee_aws_ec2.SecurityGroup {
	return g.SecurityGroup
}
func (g *Group_LoadBalancer) GetLoadBalancerDescription() *opsee_aws_elb.LoadBalancerDescription {
	return g.LoadBalancer
}
func (g *Group_AutoscalingGroup) GetGroup() *opsee_aws_autoscaling.Group {
	return g.AutoscalingGroup
}

func init() {
	GraphQLRegionType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaRegion",
		Description: "An Opsee region object representing an AWS region.",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"region": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The region identifier, e.g. us-west-1.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Region)
						if ok {
							return obj.Region, nil
						}
						inter, ok := p.Source.(RegionGetter)
						if ok {
							face := inter.GetRegion()
							if face == nil {
								return nil, nil
							}
							return face.Region, nil
						}
						return nil, fmt.Errorf("field region not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Region)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(RegionGetter)
						if ok {
							face := inter.GetRegion()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"supported_platforms": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "The region's supported platforms [EC2-VPC, Classic].",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Region)
						if ok {
							return obj.SupportedPlatforms, nil
						}
						inter, ok := p.Source.(RegionGetter)
						if ok {
							face := inter.GetRegion()
							if face == nil {
								return nil, nil
							}
							return face.SupportedPlatforms, nil
						}
						return nil, fmt.Errorf("field supported_platforms not resolved")
					},
				},
				"vpcs": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLVpcType),
					Description: "The region's VPCs.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Region)
						if ok {
							return obj.Vpcs, nil
						}
						inter, ok := p.Source.(RegionGetter)
						if ok {
							face := inter.GetRegion()
							if face == nil {
								return nil, nil
							}
							return face.Vpcs, nil
						}
						return nil, fmt.Errorf("field vpcs not resolved")
					},
				},
				"subnets": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLSubnetType),
					Description: "The region's subnets.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Region)
						if ok {
							return obj.Subnets, nil
						}
						inter, ok := p.Source.(RegionGetter)
						if ok {
							face := inter.GetRegion()
							if face == nil {
								return nil, nil
							}
							return face.Subnets, nil
						}
						return nil, fmt.Errorf("field subnets not resolved")
					},
				},
			}
		}),
	})
	GraphQLVpcType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaVpc",
		Description: "An Opsee VPC object representing an AWS VPC resource.",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The VPC identifier.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Vpc)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(VpcGetter)
						if ok {
							face := inter.GetVpc()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Vpc)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(VpcGetter)
						if ok {
							face := inter.GetVpc()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"resource": &github_com_graphql_go_graphql.Field{
					Type:        opsee_aws_ec2.GraphQLVpcType,
					Description: "The raw AWS VPC data.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Vpc)
						if ok {
							if obj.Resource == nil {
								return nil, nil
							}
							return obj.GetResource(), nil
						}
						inter, ok := p.Source.(VpcGetter)
						if ok {
							face := inter.GetVpc()
							if face == nil {
								return nil, nil
							}
							if face.Resource == nil {
								return nil, nil
							}
							return face.GetResource(), nil
						}
						return nil, fmt.Errorf("field resource not resolved")
					},
				},
				"instance_count": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "The last seen number of instances in the VPC. This value is cached, so it may not be consistent.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Vpc)
						if ok {
							return obj.InstanceCount, nil
						}
						inter, ok := p.Source.(VpcGetter)
						if ok {
							face := inter.GetVpc()
							if face == nil {
								return nil, nil
							}
							return face.InstanceCount, nil
						}
						return nil, fmt.Errorf("field instance_count not resolved")
					},
				},
			}
		}),
	})
	GraphQLSubnetType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaSubnet",
		Description: "An Opsee subnet object representing an AWS Subnet resource.",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The subnet identifier.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Subnet)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(SubnetGetter)
						if ok {
							face := inter.GetSubnet()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Subnet)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(SubnetGetter)
						if ok {
							face := inter.GetSubnet()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"resource": &github_com_graphql_go_graphql.Field{
					Type:        opsee_aws_ec2.GraphQLSubnetType,
					Description: "The raw AWS subnet data.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Subnet)
						if ok {
							if obj.Resource == nil {
								return nil, nil
							}
							return obj.GetResource(), nil
						}
						inter, ok := p.Source.(SubnetGetter)
						if ok {
							face := inter.GetSubnet()
							if face == nil {
								return nil, nil
							}
							if face.Resource == nil {
								return nil, nil
							}
							return face.GetResource(), nil
						}
						return nil, fmt.Errorf("field resource not resolved")
					},
				},
				"instance_count": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "The last seen number of instances in the Subnet. This value is cached, so it may not be consistent.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Subnet)
						if ok {
							return obj.InstanceCount, nil
						}
						inter, ok := p.Source.(SubnetGetter)
						if ok {
							face := inter.GetSubnet()
							if face == nil {
								return nil, nil
							}
							return face.InstanceCount, nil
						}
						return nil, fmt.Errorf("field instance_count not resolved")
					},
				},
				"routing": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The type of route to the internet, may be one of [public, nat, gateway, private, occluded].",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Subnet)
						if ok {
							return obj.Routing, nil
						}
						inter, ok := p.Source.(SubnetGetter)
						if ok {
							face := inter.GetSubnet()
							if face == nil {
								return nil, nil
							}
							return face.Routing, nil
						}
						return nil, fmt.Errorf("field routing not resolved")
					},
				},
			}
		}),
	})
	GraphQLGroupType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaGroup",
		Description: "An Opsee group target representing an AWS group resource.",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The AWS group identifier.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The type of AWS resource.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							return obj.Type, nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							return face.Type, nil
						}
						return nil, fmt.Errorf("field type not resolved")
					},
				},
				"instance_count": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "The last seen number of instances in the group target. This value is cached, so it may not be consistent.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							return obj.InstanceCount, nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							return face.InstanceCount, nil
						}
						return nil, fmt.Errorf("field instance_count not resolved")
					},
				},
				"instances": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLInstanceType),
					Description: "The last seen instances in the group target. This value is cached, so it may not be consistent.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							return obj.Instances, nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							return face.Instances, nil
						}
						return nil, fmt.Errorf("field instances not resolved")
					},
				},
				"created_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field created_at not resolved")
					},
				},
				"updated_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if ok {
							if obj.UpdatedAt == nil {
								return nil, nil
							}
							return obj.GetUpdatedAt(), nil
						}
						inter, ok := p.Source.(GroupGetter)
						if ok {
							face := inter.GetGroup()
							if face == nil {
								return nil, nil
							}
							if face.UpdatedAt == nil {
								return nil, nil
							}
							return face.GetUpdatedAt(), nil
						}
						return nil, fmt.Errorf("field updated_at not resolved")
					},
				},
				"resource": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLGroupResourceUnion,
					Description: "The raw AWS resource data.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Group)
						if !ok {
							return nil, fmt.Errorf("field resource not resolved")
						}
						return obj.GetResource(), nil
					},
				},
			}
		}),
	})
	GraphQLInstanceType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaInstance",
		Description: "An Opsee instance target representing an AWS instance resource.",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The AWS instance identifier.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The type of AWS resource.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							return obj.Type, nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							return face.Type, nil
						}
						return nil, fmt.Errorf("field type not resolved")
					},
				},
				"groups": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLGroupType),
					Description: "The last seen group targets that the instance belongs to. This value is cached, so it may not be consistent.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							return obj.Groups, nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							return face.Groups, nil
						}
						return nil, fmt.Errorf("field groups not resolved")
					},
				},
				"created_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field created_at not resolved")
					},
				},
				"updated_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if ok {
							if obj.UpdatedAt == nil {
								return nil, nil
							}
							return obj.GetUpdatedAt(), nil
						}
						inter, ok := p.Source.(InstanceGetter)
						if ok {
							face := inter.GetInstance()
							if face == nil {
								return nil, nil
							}
							if face.UpdatedAt == nil {
								return nil, nil
							}
							return face.GetUpdatedAt(), nil
						}
						return nil, fmt.Errorf("field updated_at not resolved")
					},
				},
				"resource": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLInstanceResourceUnion,
					Description: "The raw AWS resource data.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Instance)
						if !ok {
							return nil, fmt.Errorf("field resource not resolved")
						}
						return obj.GetResource(), nil
					},
				},
			}
		}),
	})
	GraphQLGroupResourceUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "GroupResource",
		Description: "The raw AWS resource data.",
		Types: []*github_com_graphql_go_graphql.Object{
			opsee_aws_ec2.GraphQLSecurityGroupType,
			opsee_aws_elb.GraphQLLoadBalancerDescriptionType,
			opsee_aws_autoscaling.GraphQLGroupType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *Group_SecurityGroup:
				return opsee_aws_ec2.GraphQLSecurityGroupType
			case *Group_LoadBalancer:
				return opsee_aws_elb.GraphQLLoadBalancerDescriptionType
			case *Group_AutoscalingGroup:
				return opsee_aws_autoscaling.GraphQLGroupType
			}
			return nil
		},
	})
	GraphQLInstanceResourceUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "InstanceResource",
		Description: "The raw AWS resource data.",
		Types: []*github_com_graphql_go_graphql.Object{
			opsee_aws_ec2.GraphQLInstanceType,
			opsee_aws_rds.GraphQLDBInstanceType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *Instance_Instance:
				return opsee_aws_ec2.GraphQLInstanceType
			case *Instance_DbInstance:
				return opsee_aws_rds.GraphQLDBInstanceType
			}
			return nil
		},
	})
}
func (m *Region) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Region) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Region)))
		i += copy(data[i:], m.Region)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if len(m.SupportedPlatforms) > 0 {
		for _, s := range m.SupportedPlatforms {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Vpcs) > 0 {
		for _, msg := range m.Vpcs {
			data[i] = 0x22
			i++
			i = encodeVarintAwsData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			data[i] = 0x2a
			i++
			i = encodeVarintAwsData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Vpc) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Vpc) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if m.Resource != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAwsData(data, i, uint64(m.Resource.Size()))
		n1, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.InstanceCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAwsData(data, i, uint64(m.InstanceCount))
	}
	return i, nil
}

func (m *Subnet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Subnet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if m.Resource != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAwsData(data, i, uint64(m.Resource.Size()))
		n2, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.InstanceCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAwsData(data, i, uint64(m.InstanceCount))
	}
	if len(m.Routing) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Routing)))
		i += copy(data[i:], m.Routing)
	}
	return i, nil
}

func (m *Group) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Group) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if len(m.Type) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.InstanceCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAwsData(data, i, uint64(m.InstanceCount))
	}
	if len(m.Instances) > 0 {
		for _, msg := range m.Instances {
			data[i] = 0x2a
			i++
			i = encodeVarintAwsData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreatedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAwsData(data, i, uint64(m.CreatedAt.Size()))
		n3, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.UpdatedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAwsData(data, i, uint64(m.UpdatedAt.Size()))
		n4, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Resource != nil {
		nn5, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *Group_SecurityGroup) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.SecurityGroup != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x6
		i++
		i = encodeVarintAwsData(data, i, uint64(m.SecurityGroup.Size()))
		n6, err := m.SecurityGroup.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Group_LoadBalancer) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.LoadBalancer != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x6
		i++
		i = encodeVarintAwsData(data, i, uint64(m.LoadBalancer.Size()))
		n7, err := m.LoadBalancer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Group_AutoscalingGroup) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.AutoscalingGroup != nil {
		data[i] = 0xba
		i++
		data[i] = 0x6
		i++
		i = encodeVarintAwsData(data, i, uint64(m.AutoscalingGroup.Size()))
		n8, err := m.AutoscalingGroup.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Instance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Instance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.CustomerId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.CustomerId)))
		i += copy(data[i:], m.CustomerId)
	}
	if len(m.Type) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAwsData(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			data[i] = 0x22
			i++
			i = encodeVarintAwsData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreatedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAwsData(data, i, uint64(m.CreatedAt.Size()))
		n9, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.UpdatedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAwsData(data, i, uint64(m.UpdatedAt.Size()))
		n10, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Resource != nil {
		nn11, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *Instance_Instance) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Instance != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x6
		i++
		i = encodeVarintAwsData(data, i, uint64(m.Instance.Size()))
		n12, err := m.Instance.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Instance_DbInstance) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.DbInstance != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x6
		i++
		i = encodeVarintAwsData(data, i, uint64(m.DbInstance.Size()))
		n13, err := m.DbInstance.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func encodeFixed64AwsData(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32AwsData(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAwsData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedRegion(r randyAwsData, easy bool) *Region {
	this := &Region{}
	this.Region = randStringAwsData(r)
	this.CustomerId = randStringAwsData(r)
	v1 := r.Intn(10)
	this.SupportedPlatforms = make([]string, v1)
	for i := 0; i < v1; i++ {
		this.SupportedPlatforms[i] = randStringAwsData(r)
	}
	if r.Intn(10) == 0 {
		v2 := r.Intn(5)
		this.Vpcs = make([]*Vpc, v2)
		for i := 0; i < v2; i++ {
			this.Vpcs[i] = NewPopulatedVpc(r, easy)
		}
	}
	if r.Intn(10) == 0 {
		v3 := r.Intn(5)
		this.Subnets = make([]*Subnet, v3)
		for i := 0; i < v3; i++ {
			this.Subnets[i] = NewPopulatedSubnet(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVpc(r randyAwsData, easy bool) *Vpc {
	this := &Vpc{}
	this.Id = randStringAwsData(r)
	this.CustomerId = randStringAwsData(r)
	if r.Intn(10) != 0 {
		this.Resource = opsee_aws_ec2.NewPopulatedVpc(r, easy)
	}
	this.InstanceCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.InstanceCount *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSubnet(r randyAwsData, easy bool) *Subnet {
	this := &Subnet{}
	this.Id = randStringAwsData(r)
	this.CustomerId = randStringAwsData(r)
	if r.Intn(10) != 0 {
		this.Resource = opsee_aws_ec2.NewPopulatedSubnet(r, easy)
	}
	this.InstanceCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.InstanceCount *= -1
	}
	this.Routing = randStringAwsData(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGroup(r randyAwsData, easy bool) *Group {
	this := &Group{}
	this.Id = randStringAwsData(r)
	this.CustomerId = randStringAwsData(r)
	this.Type = randStringAwsData(r)
	this.InstanceCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.InstanceCount *= -1
	}
	if r.Intn(10) == 0 {
		v4 := r.Intn(5)
		this.Instances = make([]*Instance, v4)
		for i := 0; i < v4; i++ {
			this.Instances[i] = NewPopulatedInstance(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UpdatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	oneofNumber_Resource := []int32{101, 102, 103}[r.Intn(3)]
	switch oneofNumber_Resource {
	case 101:
		this.Resource = NewPopulatedGroup_SecurityGroup(r, easy)
	case 102:
		this.Resource = NewPopulatedGroup_LoadBalancer(r, easy)
	case 103:
		this.Resource = NewPopulatedGroup_AutoscalingGroup(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedGroup_SecurityGroup(r randyAwsData, easy bool) *Group_SecurityGroup {
	this := &Group_SecurityGroup{}
	this.SecurityGroup = opsee_aws_ec2.NewPopulatedSecurityGroup(r, easy)
	return this
}
func NewPopulatedGroup_LoadBalancer(r randyAwsData, easy bool) *Group_LoadBalancer {
	this := &Group_LoadBalancer{}
	this.LoadBalancer = opsee_aws_elb.NewPopulatedLoadBalancerDescription(r, easy)
	return this
}
func NewPopulatedGroup_AutoscalingGroup(r randyAwsData, easy bool) *Group_AutoscalingGroup {
	this := &Group_AutoscalingGroup{}
	this.AutoscalingGroup = opsee_aws_autoscaling.NewPopulatedGroup(r, easy)
	return this
}
func NewPopulatedInstance(r randyAwsData, easy bool) *Instance {
	this := &Instance{}
	this.Id = randStringAwsData(r)
	this.CustomerId = randStringAwsData(r)
	this.Type = randStringAwsData(r)
	if r.Intn(10) == 0 {
		v5 := r.Intn(5)
		this.Groups = make([]*Group, v5)
		for i := 0; i < v5; i++ {
			this.Groups[i] = NewPopulatedGroup(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UpdatedAt = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	oneofNumber_Resource := []int32{101, 102}[r.Intn(2)]
	switch oneofNumber_Resource {
	case 101:
		this.Resource = NewPopulatedInstance_Instance(r, easy)
	case 102:
		this.Resource = NewPopulatedInstance_DbInstance(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInstance_Instance(r randyAwsData, easy bool) *Instance_Instance {
	this := &Instance_Instance{}
	this.Instance = opsee_aws_ec2.NewPopulatedInstance(r, easy)
	return this
}
func NewPopulatedInstance_DbInstance(r randyAwsData, easy bool) *Instance_DbInstance {
	this := &Instance_DbInstance{}
	this.DbInstance = opsee_aws_rds.NewPopulatedDBInstance(r, easy)
	return this
}

type randyAwsData interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneAwsData(r randyAwsData) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringAwsData(r randyAwsData) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneAwsData(r)
	}
	return string(tmps)
}
func randUnrecognizedAwsData(r randyAwsData, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldAwsData(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldAwsData(data []byte, r randyAwsData, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateAwsData(data, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		data = encodeVarintPopulateAwsData(data, uint64(v7))
	case 1:
		data = encodeVarintPopulateAwsData(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateAwsData(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateAwsData(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateAwsData(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateAwsData(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Region) Size() (n int) {
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	if len(m.SupportedPlatforms) > 0 {
		for _, s := range m.SupportedPlatforms {
			l = len(s)
			n += 1 + l + sovAwsData(uint64(l))
		}
	}
	if len(m.Vpcs) > 0 {
		for _, e := range m.Vpcs {
			l = e.Size()
			n += 1 + l + sovAwsData(uint64(l))
		}
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovAwsData(uint64(l))
		}
	}
	return n
}

func (m *Vpc) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.InstanceCount != 0 {
		n += 1 + sovAwsData(uint64(m.InstanceCount))
	}
	return n
}

func (m *Subnet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.InstanceCount != 0 {
		n += 1 + sovAwsData(uint64(m.InstanceCount))
	}
	l = len(m.Routing)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	return n
}

func (m *Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.InstanceCount != 0 {
		n += 1 + sovAwsData(uint64(m.InstanceCount))
	}
	if len(m.Instances) > 0 {
		for _, e := range m.Instances {
			l = e.Size()
			n += 1 + l + sovAwsData(uint64(l))
		}
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	return n
}

func (m *Group_SecurityGroup) Size() (n int) {
	var l int
	_ = l
	if m.SecurityGroup != nil {
		l = m.SecurityGroup.Size()
		n += 2 + l + sovAwsData(uint64(l))
	}
	return n
}
func (m *Group_LoadBalancer) Size() (n int) {
	var l int
	_ = l
	if m.LoadBalancer != nil {
		l = m.LoadBalancer.Size()
		n += 2 + l + sovAwsData(uint64(l))
	}
	return n
}
func (m *Group_AutoscalingGroup) Size() (n int) {
	var l int
	_ = l
	if m.AutoscalingGroup != nil {
		l = m.AutoscalingGroup.Size()
		n += 2 + l + sovAwsData(uint64(l))
	}
	return n
}
func (m *Instance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.CustomerId)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAwsData(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAwsData(uint64(l))
		}
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovAwsData(uint64(l))
	}
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	return n
}

func (m *Instance_Instance) Size() (n int) {
	var l int
	_ = l
	if m.Instance != nil {
		l = m.Instance.Size()
		n += 2 + l + sovAwsData(uint64(l))
	}
	return n
}
func (m *Instance_DbInstance) Size() (n int) {
	var l int
	_ = l
	if m.DbInstance != nil {
		l = m.DbInstance.Size()
		n += 2 + l + sovAwsData(uint64(l))
	}
	return n
}

func sovAwsData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAwsData(x uint64) (n int) {
	return sovAwsData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Region) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedPlatforms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedPlatforms = append(m.SupportedPlatforms, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vpcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vpcs = append(m.Vpcs, &Vpc{})
			if err := m.Vpcs[len(m.Vpcs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &Subnet{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vpc) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vpc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vpc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &opsee_aws_ec2.Vpc{}
			}
			if err := m.Resource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceCount", wireType)
			}
			m.InstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InstanceCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAwsData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &opsee_aws_ec2.Subnet{}
			}
			if err := m.Resource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceCount", wireType)
			}
			m.InstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InstanceCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routing = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceCount", wireType)
			}
			m.InstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InstanceCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instances = append(m.Instances, &Instance{})
			if err := m.Instances[len(m.Instances)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &opsee_types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &opsee_aws_ec2.SecurityGroup{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &Group_SecurityGroup{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &opsee_aws_elb.LoadBalancerDescription{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &Group_LoadBalancer{v}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoscalingGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &opsee_aws_autoscaling.Group{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &Group_AutoscalingGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Group{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &opsee_types.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &opsee_aws_ec2.Instance{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &Instance_Instance{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbInstance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAwsData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &opsee_aws_rds.DBInstance{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &Instance_DbInstance{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAwsData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAwsData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAwsData(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAwsData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAwsData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAwsData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAwsData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAwsData(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAwsData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAwsData   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorAwsData = []byte{
	// 701 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x4d, 0x93, 0x36, 0xd3, 0x26, 0xc0, 0x22, 0x8a, 0xa9, 0x50, 0x5b, 0x45, 0xfc, 0xf4,
	0x52, 0x9b, 0x16, 0xf5, 0x00, 0xe2, 0xd2, 0x10, 0x04, 0x15, 0x20, 0x55, 0x2e, 0x02, 0x89, 0x8b,
	0x65, 0xaf, 0xb7, 0xae, 0x25, 0x27, 0x6b, 0x79, 0xd7, 0xa0, 0x3e, 0x04, 0x2f, 0xc1, 0x89, 0x0b,
	0x77, 0x24, 0x2e, 0x1c, 0x39, 0xf2, 0x08, 0x80, 0x78, 0x08, 0x6e, 0x30, 0x5e, 0xef, 0xa6, 0x56,
	0x2a, 0xd1, 0x06, 0x71, 0x58, 0x69, 0x67, 0xe6, 0xfb, 0x66, 0xbf, 0x9d, 0x19, 0xaf, 0xa1, 0x1b,
	0xbc, 0x11, 0x7e, 0x14, 0xc8, 0xc0, 0xc9, 0x72, 0x2e, 0x39, 0x69, 0xf2, 0x4c, 0x30, 0xb6, 0xbc,
	0x11, 0x27, 0xf2, 0xb0, 0x08, 0x1d, 0xca, 0x87, 0x6e, 0xcc, 0x63, 0xee, 0xaa, 0x68, 0x58, 0x1c,
	0x28, 0x4b, 0x19, 0x6a, 0x57, 0xb1, 0x96, 0x6f, 0xd7, 0xe0, 0x2a, 0xc1, 0x31, 0x5e, 0x99, 0x15,
	0x41, 0x6d, 0x35, 0xe3, 0xde, 0x99, 0x18, 0xf2, 0x28, 0x63, 0xc2, 0x95, 0xc9, 0x90, 0x09, 0x19,
	0x0c, 0x33, 0xcd, 0xbd, 0x7b, 0x82, 0x1b, 0x06, 0x22, 0xa1, 0xae, 0xa0, 0x87, 0x6c, 0x18, 0xb8,
	0x78, 0x23, 0x37, 0x28, 0x24, 0x17, 0x34, 0x48, 0x93, 0x51, 0x5c, 0x25, 0xd1, 0xd4, 0xcd, 0xd3,
	0xa9, 0x8c, 0x6e, 0x4d, 0x4d, 0x49, 0xc3, 0x69, 0x29, 0x79, 0x24, 0xea, 0x94, 0xde, 0x27, 0x0b,
	0x5a, 0x1e, 0x8b, 0x13, 0x3e, 0x22, 0x4b, 0xd0, 0xca, 0xd5, 0xce, 0xb6, 0xd6, 0xac, 0xf5, 0xb6,
	0xa7, 0x2d, 0xb2, 0x0a, 0x0b, 0xb4, 0x10, 0x92, 0x0f, 0x59, 0xee, 0x27, 0x91, 0x3d, 0xa3, 0x82,
	0x60, 0x5c, 0xbb, 0x11, 0x71, 0xe1, 0x92, 0x28, 0xb2, 0x8c, 0xe7, 0x92, 0x45, 0x7e, 0x96, 0x06,
	0xf2, 0x80, 0xe7, 0x43, 0x61, 0x37, 0xd6, 0x1a, 0x08, 0x24, 0xe3, 0xd0, 0x9e, 0x89, 0x90, 0x15,
	0x98, 0x7d, 0x9d, 0x51, 0x61, 0xcf, 0x22, 0x62, 0x61, 0x0b, 0x9c, 0xaa, 0x41, 0x2f, 0x32, 0xea,
	0x29, 0x3f, 0xb9, 0x05, 0x73, 0xa2, 0x08, 0x47, 0x4c, 0x0a, 0xbb, 0xa9, 0x20, 0x1d, 0x0d, 0xd9,
	0x57, 0x5e, 0xcf, 0x44, 0x7b, 0x6f, 0x2d, 0x68, 0x20, 0x8d, 0x74, 0x61, 0x06, 0x95, 0x55, 0xb2,
	0x71, 0x77, 0xba, 0x64, 0x07, 0xe6, 0x73, 0x26, 0x78, 0x91, 0x53, 0x86, 0x3a, 0x2d, 0x3c, 0x82,
	0xe8, 0x23, 0xb0, 0x48, 0x0e, 0xb6, 0x42, 0xa9, 0x19, 0x63, 0xc8, 0x0d, 0xe8, 0x26, 0x23, 0x9c,
	0x85, 0x11, 0x65, 0x3e, 0xe5, 0xc5, 0x48, 0xa2, 0x76, 0x6b, 0xbd, 0xe9, 0x75, 0x8c, 0xf7, 0x41,
	0xe9, 0xec, 0x7d, 0xc0, 0x6a, 0x56, 0x1a, 0xa7, 0x97, 0xb4, 0x79, 0x42, 0xd2, 0xe5, 0x09, 0x49,
	0xfa, 0xf6, 0xd3, 0xaa, 0x22, 0x36, 0xcc, 0xe5, 0xbc, 0x90, 0x38, 0x93, 0x58, 0xce, 0xf2, 0x58,
	0x63, 0xf6, 0x7e, 0x37, 0xa0, 0xf9, 0x08, 0x8d, 0x6c, 0x7a, 0xb9, 0x04, 0x66, 0xcb, 0x39, 0x52,
	0x52, 0xdb, 0x9e, 0xda, 0x9f, 0x55, 0xcf, 0x06, 0xb4, 0x8d, 0xc3, 0x34, 0xf8, 0xbc, 0xbe, 0xea,
	0xae, 0xf6, 0x7b, 0xc7, 0x08, 0xb2, 0x0d, 0x40, 0x73, 0x16, 0x94, 0xc3, 0x15, 0x48, 0xbb, 0xa5,
	0x4a, 0xb3, 0xa4, 0xf1, 0xd5, 0x28, 0x3f, 0x37, 0x1f, 0xaa, 0xd7, 0xd6, 0xc8, 0x1d, 0x59, 0xd2,
	0x8a, 0x2c, 0x32, 0xb4, 0xb9, 0xbf, 0xd3, 0x34, 0x12, 0x69, 0x0f, 0xa1, 0x2b, 0x18, 0x2d, 0xf2,
	0x44, 0x1e, 0xf9, 0x71, 0x59, 0x1a, 0x9b, 0x29, 0xea, 0xb5, 0xc9, 0x66, 0x68, 0x90, 0x2a, 0xdf,
	0xe3, 0x73, 0x5e, 0x47, 0xd4, 0x1d, 0xe4, 0x19, 0x74, 0x52, 0x1e, 0x44, 0x7e, 0x18, 0xa4, 0xe5,
	0x2d, 0x72, 0xfb, 0x40, 0x65, 0xb9, 0x59, 0xcf, 0x92, 0x86, 0xce, 0x53, 0xc4, 0xf4, 0x35, 0x64,
	0xc0, 0x04, 0xcd, 0x93, 0x4c, 0xe2, 0x37, 0x87, 0xf9, 0x16, 0xd3, 0x5a, 0x88, 0x3c, 0x81, 0x8b,
	0xb5, 0xa7, 0x45, 0x0b, 0x8b, 0x4f, 0x08, 0xab, 0x61, 0x1c, 0x23, 0xec, 0x42, 0xcd, 0xa9, 0x7c,
	0x7d, 0x38, 0x9e, 0xb4, 0xde, 0xcf, 0x19, 0x98, 0x37, 0x45, 0xff, 0x3f, 0x43, 0x70, 0x1d, 0x5a,
	0x4a, 0x9e, 0xf9, 0xbc, 0x17, 0xb5, 0x3e, 0x75, 0xb6, 0xa7, 0x63, 0x13, 0x4d, 0x6d, 0xfe, 0x5b,
	0x53, 0x5b, 0x67, 0x6d, 0xea, 0x36, 0xcc, 0x9b, 0x79, 0xd2, 0xed, 0xbc, 0x32, 0xd1, 0x4e, 0x53,
	0x03, 0x2c, 0xd8, 0x18, 0x4a, 0xee, 0xc3, 0x42, 0x14, 0xfa, 0x63, 0x66, 0xd5, 0xc2, 0xab, 0x35,
	0x26, 0xbe, 0xa6, 0xce, 0xa0, 0x5f, 0xe3, 0x42, 0x14, 0x1a, 0xab, 0x5e, 0xe6, 0xfe, 0xe0, 0xd7,
	0xf7, 0x15, 0xeb, 0xfd, 0x8f, 0x15, 0xeb, 0x23, 0xae, 0x2f, 0xb8, 0xbe, 0xe2, 0xfa, 0x86, 0xeb,
	0xf3, 0xbb, 0x55, 0x0b, 0xba, 0x94, 0x3b, 0xb5, 0x9f, 0x54, 0x7f, 0x71, 0xe7, 0xe5, 0xfe, 0x00,
	0xff, 0x8d, 0x7b, 0xa5, 0xb5, 0x67, 0xbd, 0x6a, 0x55, 0x0f, 0x78, 0xd8, 0x52, 0xe1, 0x3b, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x3b, 0x9b, 0x10, 0xeb, 0x3d, 0x07, 0x00, 0x00,
}
